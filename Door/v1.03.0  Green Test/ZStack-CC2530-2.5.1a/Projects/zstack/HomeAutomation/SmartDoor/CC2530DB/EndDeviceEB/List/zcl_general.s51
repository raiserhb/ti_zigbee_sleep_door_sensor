///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.10.1.10194/W32 for 8051        08/Aug/2017  09:25:02 /
// Copyright 2004-2011 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data_rom                                          /
//    Dptr setup         =  1,16                                              /
//    Source file        =  D:\work space\Smart Product\Two YHY\Door\v1.03.0  /
//                           Green\ZStack-CC2530-2.5.1a\COMPONENTS\stack\zcl\ /
//                          zcl_general.c                                     /
//    Command line       =  -f "D:\work space\Smart Product\Two               /
//                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proj /
//                          ects\zstack\HomeAutomation\SmartDoor\CC2530DB\..\ /
//                          Tools\CC2530DB\f8wEndev.cfg" (-DCPU32MHZ          /
//                          -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3        /
//                          -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3             /
//                          -DHAL_KEY=FALSE -DHAL_LED=FALSE -DHAL_LCD=FALSE   /
//                          -DHAL_ADC=FALSE -DNV_RESTORE -DNV_INIT            /
//                          -DPOWER_SAVING -DTC_LINKKEY_JOIN) -f "D:\work     /
//                          space\Smart Product\Two YHY\Door\v1.03.0          /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\Tools\CC2530DB\f8w /
//                          Config.cfg" (-DZIGBEEPRO -DSECURE=1               /
//                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                 /
//                          -DDEFAULT_CHANLIST=0x06108800                     /
//                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                      /
//                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M /
//                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             /
//                          -DBEACON_REQ_DELAY_MASK=0x00FF                    /
//                          -DLINK_STATUS_JITTER_MASK=0x007F                  /
//                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P /
//                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           /
//                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3   /
//                          -DNWK_MAX_DATA_RETRIES=2                          /
//                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        /
//                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40          /
//                          -DNWK_MAX_BINDING_ENTRIES=4                       /
//                          -DMAX_BINDING_CLUSTER_IDS=4                       /
//                          -DDEFAULT_KEY={0x58,0x69,0x6E,0x67,0x48,0x75,     /
//                          0x6F,0x59,0x75,0x61,0x6E,0x53,0x6D,0x61,0x72,     /
//                          0x74} -DMAC_MAX_FRAME_SIZE=116                    /
//                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const    /
//                          __code" -DGENERIC=__generic                       /
//                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=0          /
//                          -DQUEUED_POLL_RATE=0 -DRESPONSE_POLL_RATE=0       /
//                          -DREJOIN_POLL_RATE=440) -f "D:\work space\Smart   /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\Tools\CC2530DB\f8w /
//                          ZCL.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_REPORT     /
//                          -DZCL_BASIC -DZCL_IDENTIFY -DZCL_ON_OFF           /
//                          -DZCL_KEY_ESTABLISH -DZCL_KEY_ESTABLISHMENT_KEY_G /
//                          ENERATE_TIMEOUT=4 -DZCL_KEY_ESTABLISHMENT_MAC_GEN /
//                          ERATE_TIMEOUT=10 -DZCL_KEY_ESTABLISHMENT_EKEY_GEN /
//                          ERATE_TIMEOUT=10 -DZCL_LOAD_CONTROL               /
//                          -DZCL_SIMPLE_METERING -DZCL_PRICING               /
//                          -DZCL_MESSAGE -DZCL_TUNNELING -DZCL_TOU)          /
//                          -DZCL_DEVICE_MGMT "D:\work space\Smart            /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\COMPONENTS\stack\zcl\z /
//                          cl_general.c" -lC "D:\work space\Smart            /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\EndDeviceEB\List\"    /
//                          -lA "D:\work space\Smart Product\Two              /
//                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proj /
//                          ects\zstack\HomeAutomation\SmartDoor\CC2530DB\End /
//                          DeviceEB\List\" --diag_suppress Pe001,Pa010 -o    /
//                          "D:\work space\Smart Product\Two                  /
//                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proj /
//                          ects\zstack\HomeAutomation\SmartDoor\CC2530DB\End /
//                          DeviceEB\Obj\" -e --debug --core=plain            /
//                          --dptr=16,1 --data_model=large                    /
//                          --code_model=banked --calling_convention=xdata_re /
//                          entrant --place_constants=data_rom                /
//                          --nr_virtual_regs 16 -I "D:\work space\Smart      /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\" -I "D:\work         /
//                          space\Smart Product\Two YHY\Door\v1.03.0          /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\Source\" -I        /
//                          "D:\work space\Smart Product\Two                  /
//                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proj /
//                          ects\zstack\HomeAutomation\SmartDoor\CC2530DB\..\ /
//                          ..\Source\" -I "D:\work space\Smart Product\Two   /
//                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proj /
//                          ects\zstack\HomeAutomation\SmartDoor\CC2530DB\..\ /
//                          ..\..\ZMain\TI2530DB\" -I "D:\work space\Smart    /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\hal\include\" -I "D:\work space\Smart        /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\hal\target\CC2530EB\" -I "D:\work            /
//                          space\Smart Product\Two YHY\Door\v1.03.0          /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\mac\include\" -I "D:\work space\Smart        /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\mac\high_level\" -I "D:\work space\Smart     /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\mac\low_level\srf04\" -I "D:\work            /
//                          space\Smart Product\Two YHY\Door\v1.03.0          /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\mac\low_level\srf04\single_chip\" -I         /
//                          "D:\work space\Smart Product\Two                  /
//                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proj /
//                          ects\zstack\HomeAutomation\SmartDoor\CC2530DB\..\ /
//                          ..\..\..\..\Components\mt\" -I "D:\work           /
//                          space\Smart Product\Two YHY\Door\v1.03.0          /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\osal\include\" -I "D:\work space\Smart       /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\services\saddr\" -I "D:\work space\Smart     /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\services\sdata\" -I "D:\work space\Smart     /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\stack\af\" -I "D:\work space\Smart           /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\stack\nwk\" -I "D:\work space\Smart          /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\stack\sapi\" -I "D:\work space\Smart         /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\stack\sec\" -I "D:\work space\Smart          /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\stack\sys\" -I "D:\work space\Smart          /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\stack\zcl\" -I "D:\work space\Smart          /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\stack\zdo\" -I "D:\work space\Smart          /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\zmac\" -I "D:\work space\Smart Product\Two   /
//                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proj /
//                          ects\zstack\HomeAutomation\SmartDoor\CC2530DB\..\ /
//                          ..\..\..\..\Components\zmac\f8w\" -Oh             /
//                          --require_prototypes                              /
//    List file          =  D:\work space\Smart Product\Two YHY\Door\v1.03.0  /
//                           Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeA /
//                          utomation\SmartDoor\CC2530DB\EndDeviceEB\List\zcl /
//                          _general.s51                                      /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME zcl_general

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?CALL_IND
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?PUSH_XSTACK_I_ONE
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?US_SWITCH_SPARSE
        EXTERN ?V0
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN __INIT_XDATA_Z

        FUNCTION ??zclGeneral_HdlInSpecificCommands?relay,0203H
        FUNCTION ??zclGeneral_HdlIncoming?relay,0203H
        FUNCTION ??zclGeneral_ProcessInIdentity?relay,0203H
        PUBLIC ??zclGeneral_RegisterCmdCallbacks?relay
        FUNCTION ??zclGeneral_RegisterCmdCallbacks?relay,0203H
        PUBLIC ??zclGeneral_SendIdentify?relay
        FUNCTION ??zclGeneral_SendIdentify?relay,0203H
        PUBLIC ??zclGeneral_SendIdentifyQueryResponse?relay
        FUNCTION ??zclGeneral_SendIdentifyQueryResponse?relay,0203H
        FUNCTION zclGeneral_HdlInSpecificCommands,0a1203H
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        FUNCTION zclGeneral_HdlIncoming,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        FUNCTION zclGeneral_ProcessInIdentity,021203H
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 28, STACK
        PUBLIC zclGeneral_RegisterCmdCallbacks
        FUNCTION zclGeneral_RegisterCmdCallbacks,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 14, STACK
        PUBLIC zclGeneral_SendIdentify
        FUNCTION zclGeneral_SendIdentify,021203H
        ARGFRAME XSTACK, 2, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 23, STACK
        PUBLIC zclGeneral_SendIdentifyQueryResponse
        FUNCTION zclGeneral_SendIdentifyQueryResponse,021203H
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 23, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA_SP SP IDATA
        CFI StackFrame CFA_PSP16 PSP16 XDATA
        CFI StackFrame CFA_XSP16 XSP16 XDATA
        CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
        CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
        CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
        CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
        CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
        CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
        CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
        CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
        CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
        CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
        CFI VirtualResource ?RET:24
        CFI Resource ?BRET_EXT:8
        CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
        CFI ResourceParts PSP16 PSPH, PSPL
        CFI ResourceParts XSP16 XSPH, XSPL
        CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-3
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B Undefined
        CFI A Undefined
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 Undefined
        CFI R5 Undefined
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT Frame(CFA_SP, 3)
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-2
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B SameValue
        CFI A SameValue
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 SameValue
        CFI R1 SameValue
        CFI R2 SameValue
        CFI R3 SameValue
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT SameValue
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon1
        
zcl_registerPlugin  SYMBOL "zcl_registerPlugin"
osal_mem_alloc      SYMBOL "osal_mem_alloc"
zcl_SendCommand     SYMBOL "zcl_SendCommand"
zclFindAttrRec      SYMBOL "zclFindAttrRec"
zclReadAttrData     SYMBOL "zclReadAttrData"
??osal_mem_alloc?relay SYMBOL "?relay", osal_mem_alloc
??zclFindAttrRec?relay SYMBOL "?relay", zclFindAttrRec
??zclReadAttrData?relay SYMBOL "?relay", zclReadAttrData
??zcl_SendCommand?relay SYMBOL "?relay", zcl_SendCommand
??zcl_registerPlugin?relay SYMBOL "?relay", zcl_registerPlugin
zclGeneral_RegisterCmdCallbacks SYMBOL "zclGeneral_RegisterCmdCallbacks"
??zclGeneral_RegisterCmdCallbacks?relay SYMBOL "?relay", zclGeneral_RegisterCmdCallbacks
zclGeneral_SendIdentify SYMBOL "zclGeneral_SendIdentify"
??zclGeneral_SendIdentify?relay SYMBOL "?relay", zclGeneral_SendIdentify
zclGeneral_SendIdentifyQueryResponse SYMBOL "zclGeneral_SendIdentifyQueryResponse"
??zclGeneral_SendIdentifyQueryResponse?relay SYMBOL "?relay", zclGeneral_SendIdentifyQueryResponse

        EXTERN zcl_registerPlugin
        FUNCTION zcl_registerPlugin,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN osal_mem_alloc
        FUNCTION osal_mem_alloc,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN zcl_SendCommand
        FUNCTION zcl_SendCommand,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN zclFindAttrRec
        FUNCTION zclFindAttrRec,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN zclReadAttrData
        FUNCTION zclReadAttrData,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN ??osal_mem_alloc?relay
        FUNCTION ??osal_mem_alloc?relay,00H
        EXTERN ??zclFindAttrRec?relay
        FUNCTION ??zclFindAttrRec?relay,00H
        EXTERN ??zclReadAttrData?relay
        FUNCTION ??zclReadAttrData?relay,00H
        EXTERN ??zcl_SendCommand?relay
        FUNCTION ??zcl_SendCommand?relay,00H
        EXTERN ??zcl_registerPlugin?relay
        FUNCTION ??zcl_registerPlugin?relay,00H

// D:\work space\Smart Product\Two YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\COMPONENTS\stack\zcl\zcl_general.c
//    1 /**************************************************************************************************
//    2   Filename:       zcl_general.c
//    3   Revised:        $Date: 2011-12-14 16:30:16 -0800 (Wed, 14 Dec 2011) $
//    4   Revision:       $Revision: 28678 $
//    5 
//    6   Description:    Zigbee Cluster Library - General.  This application receives all
//    7                   ZCL messages and initially parses them before passing to application.
//    8 
//    9 
//   10   Copyright 2006-2011 Texas Instruments Incorporated. All rights reserved.
//   11 
//   12   IMPORTANT: Your use of this Software is limited to those specific rights
//   13   granted under the terms of a software license agreement between the user
//   14   who downloaded the software, his/her employer (which must be your employer)
//   15   and Texas Instruments Incorporated (the "License").  You may not use this
//   16   Software unless you agree to abide by the terms of the License. The License
//   17   limits your use, and you acknowledge, that the Software may not be modified,
//   18   copied or distributed unless embedded on a Texas Instruments microcontroller
//   19   or used solely and exclusively in conjunction with a Texas Instruments radio
//   20   frequency transceiver, which is integrated into your product.  Other than for
//   21   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   22   works of, modify, distribute, perform, display or sell this Software and/or
//   23   its documentation for any purpose.
//   24 
//   25   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   26   PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   27   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   28   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   29   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   30   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   31   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   32   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   33   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   34   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   35   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   36 
//   37   Should you have any questions regarding your right to use this Software,
//   38   contact Texas Instruments Incorporated at www.TI.com.
//   39 **************************************************************************************************/
//   40 
//   41 /*********************************************************************
//   42  * INCLUDES
//   43  */
//   44 #include "ZComDef.h"
//   45 #include "OSAL.h"
//   46 #include "OSAL_Nv.h"
//   47 #include "zcl.h"
//   48 #include "zcl_general.h"
//   49 #include "ZDApp.h"
//   50 
//   51 #if defined ( INTER_PAN )
//   52   #include "stub_aps.h"
//   53 #endif
//   54 
//   55 /*********************************************************************
//   56  * MACROS
//   57  */
//   58 #define locationTypeAbsolute( a )          ( (a) & LOCATION_TYPE_ABSOLUTE )
//   59 #define locationType2D( a )                ( (a) & LOCATION_TYPE_2_D )
//   60 #define locationTypeCoordinateSystem( a )  ( (a) & LOCATION_TYPE_COORDINATE_SYSTEM )
//   61 
//   62 #ifdef ZCL_SCENES
//   63 #define zclGeneral_ScenesRemaingCapacity() ( ZCL_GEN_MAX_SCENES - zclGeneral_CountAllScenes() )
//   64 #endif // ZCL_SCENES
//   65 
//   66 /*********************************************************************
//   67  * CONSTANTS
//   68  */
//   69 
//   70 /*********************************************************************
//   71  * TYPEDEFS
//   72  */
//   73 typedef struct zclGenCBRec
//   74 {
//   75   struct zclGenCBRec        *next;
//   76   uint8                     endpoint; // Used to link it into the endpoint descriptor
//   77   zclGeneral_AppCallbacks_t *CBs;     // Pointer to Callback function
//   78 } zclGenCBRec_t;
//   79 
//   80 typedef struct zclGenSceneItem
//   81 {
//   82   struct zclGenSceneItem    *next;
//   83   uint8                     endpoint; // Used to link it into the endpoint descriptor
//   84   zclGeneral_Scene_t        scene;    // Scene info
//   85 } zclGenSceneItem_t;
//   86 
//   87 typedef struct zclGenAlarmItem
//   88 {
//   89   struct zclGenAlarmItem    *next;
//   90   uint8                     endpoint; // Used to link it into the endpoint descriptor
//   91   zclGeneral_Alarm_t        alarm;    // Alarm info
//   92 } zclGenAlarmItem_t;
//   93 
//   94 // Scene NV types
//   95 typedef struct
//   96 {
//   97   uint16                    numRecs;
//   98 } nvGenScenesHdr_t;
//   99 
//  100 typedef struct zclGenSceneNVItem
//  101 {
//  102   uint8                     endpoint;
//  103   zclGeneral_Scene_t        scene;
//  104 } zclGenSceneNVItem_t;
//  105 
//  106 /*********************************************************************
//  107  * GLOBAL VARIABLES
//  108  */
//  109 
//  110 /*********************************************************************
//  111  * GLOBAL FUNCTIONS
//  112  */
//  113 
//  114 /*********************************************************************
//  115  * LOCAL VARIABLES
//  116  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  117 static zclGenCBRec_t *zclGenCBs = (zclGenCBRec_t *)NULL;
zclGenCBs:
        DS 2
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  118 static uint8 zclGenPluginRegisted = FALSE;
zclGenPluginRegisted:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  119 #ifdef ZCL_SCENES
//  120 static zclGenSceneItem_t *zclGenSceneTable = (zclGenSceneItem_t *)NULL;
//  121 #endif // ZCL_SCENES
//  122 #ifdef ZCL_ALARMS
//  123 static zclGenAlarmItem_t *zclGenAlarmTable = (zclGenAlarmItem_t *)NULL;
//  124 #endif // ZCL_ALARMS
//  125 
//  126 /*********************************************************************
//  127  * LOCAL FUNCTIONS
//  128  */
//  129 static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg );
//  130 static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg );
//  131 static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint );
//  132 
//  133 // Device Configuration and Installation clusters
//  134 #ifdef ZCL_BASIC
//  135 static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  136 #endif // ZCL_BASIC
//  137 
//  138 #ifdef ZCL_IDENTIFY
//  139 static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  140 #endif // ZCL_IDENTIFY
//  141 
//  142 // Groups and Scenes clusters
//  143 #ifdef ZCL_GROUPS
//  144 static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg );
//  145 static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  146 static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData );
//  147 #endif // ZCL_GROUPS
//  148 
//  149 #ifdef ZCL_SCENES
//  150 static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  151 static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  152 #endif // ZCL_SCENES
//  153 
//  154 // On/Off and Level Control Configuration clusters
//  155 #ifdef ZCL_ON_OFF
//  156 static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  157 #endif // ZCL_ONOFF
//  158 
//  159 #ifdef ZCL_LEVEL_CTRL
//  160 static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  161 #endif // ZCL_LEVEL_CTRL
//  162 
//  163 // Alarms cluster
//  164 #ifdef ZCL_ALARMS
//  165 static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  166 static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  167 #endif // ZCL_ALARMS
//  168 
//  169 // Location cluster
//  170 #ifdef ZCL_LOCATION
//  171 static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  172 static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  173 #endif // ZCL_LOCATION
//  174 
//  175 #ifdef ZCL_SCENES
//  176 static uint8 zclGeneral_ScenesInitNV( void );
//  177 static void zclGeneral_ScenesSetDefaultNV( void );
//  178 static void zclGeneral_ScenesWriteNV( void );
//  179 static uint16 zclGeneral_ScenesRestoreFromNV( void );
//  180 #endif // ZCL_SCENES
//  181 
//  182 /*********************************************************************
//  183  * @fn      zclGeneral_RegisterCmdCallbacks
//  184  *
//  185  * @brief   Register an applications command callbacks
//  186  *
//  187  * @param   endpoint - application's endpoint
//  188  * @param   callbacks - pointer to the callback record.
//  189  *
//  190  * @return  ZMemError if not able to allocate
//  191  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  192 ZStatus_t zclGeneral_RegisterCmdCallbacks( uint8 endpoint, zclGeneral_AppCallbacks_t *callbacks )
zclGeneral_RegisterCmdCallbacks:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function zclGeneral_RegisterCmdCallbacks
        CODE
//  193 {
        FUNCALL zclGeneral_RegisterCmdCallbacks, zcl_registerPlugin
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclGeneral_RegisterCmdCallbacks, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
        MOV     ?V0 + 0,R1
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  194   zclGenCBRec_t *pNewItem;
//  195   zclGenCBRec_t *pLoop;
//  196 
//  197   // Register as a ZCL Plugin
//  198   if ( zclGenPluginRegisted == FALSE )
        MOV     DPTR,#zclGenPluginRegisted
        MOVX    A,@DPTR
        JNZ     ??zclGeneral_RegisterCmdCallbacks_0
//  199   {
//  200     zcl_registerPlugin( ZCL_CLUSTER_ID_GEN_BASIC,
//  201                         ZCL_CLUSTER_ID_GEN_MULTISTATE_VALUE_BASIC,
//  202                         zclGeneral_HdlIncoming );
        ; Setup parameters for call to function zcl_registerPlugin
        MOV     ?V0 + 2,#??zclGeneral_HdlIncoming?relay & 0xff
        MOV     ?V0 + 3,#(??zclGeneral_HdlIncoming?relay >> 8) & 0xff
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     R4,#0x14
        MOV     R5,#0x0
        MOV     R2,#0x0
        MOV     R3,#0x0
        LCALL   ??zcl_registerPlugin?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
//  203 
//  204 #ifdef ZCL_SCENES
//  205     // Initialize NV items
//  206     zclGeneral_ScenesInitNV();
//  207 
//  208     // Restore the Scene table
//  209     zclGeneral_ScenesRestoreFromNV();
//  210 #endif // ZCL_SCENES
//  211 
//  212     zclGenPluginRegisted = TRUE;
        MOV     DPTR,#zclGenPluginRegisted
        MOV     A,#0x1
        MOVX    @DPTR,A
//  213   }
//  214 
//  215   // Fill in the new profile list
//  216   pNewItem = osal_mem_alloc( sizeof( zclGenCBRec_t ) );
??zclGeneral_RegisterCmdCallbacks_0:
        ; Setup parameters for call to function osal_mem_alloc
        MOV     R2,#0x5
        MOV     R3,#0x0
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     R0,?V0 + 2
        MOV     R1,?V0 + 3
//  217   if ( pNewItem == NULL )
        MOV     A,R0
        ORL     A,R1
        JNZ     ??zclGeneral_RegisterCmdCallbacks_1
//  218     return (ZMemError);
        MOV     R1,#0x10
        SJMP    ??zclGeneral_RegisterCmdCallbacks_2
//  219 
//  220   pNewItem->next = (zclGenCBRec_t *)NULL;
??zclGeneral_RegisterCmdCallbacks_1:
        MOV     DPL,R0
        MOV     DPH,R1
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
//  221   pNewItem->endpoint = endpoint;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
//  222   pNewItem->CBs = callbacks;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
//  223 
//  224   // Find spot in list
//  225   if (  zclGenCBs == NULL )
        MOV     DPTR,#zclGenCBs
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R2
        ORL     A,R3
        MOV     DPTR,#zclGenCBs
        JZ      ??zclGeneral_RegisterCmdCallbacks_3
//  226   {
//  227     zclGenCBs = pNewItem;
//  228   }
//  229   else
//  230   {
//  231     // Look for end of list
//  232     pLoop = zclGenCBs;
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        SJMP    ??zclGeneral_RegisterCmdCallbacks_4
//  233     while ( pLoop->next != NULL )
//  234       pLoop = pLoop->next;
??zclGeneral_RegisterCmdCallbacks_5:
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
??zclGeneral_RegisterCmdCallbacks_4:
        MOV     R5,A
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R2
        ORL     A,R3
        JNZ     ??zclGeneral_RegisterCmdCallbacks_5
//  235 
//  236     // Put new item at end of list
//  237     pLoop->next = pNewItem;
        MOV     DPL,R4
        MOV     DPH,R5
??zclGeneral_RegisterCmdCallbacks_3:
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  238   }
//  239 
//  240   return ( ZSuccess );
        MOV     R1,#0x0
        CFI EndBlock cfiBlock0
??zclGeneral_RegisterCmdCallbacks_2:
        REQUIRE ?Subroutine0
        ; // Fall through to label ?Subroutine0
//  241 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine0:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock1
//  242 
//  243 #ifdef ZCL_IDENTIFY
//  244 /*********************************************************************
//  245  * @fn      zclGeneral_SendIdentify
//  246  *
//  247  * @brief   Call to send out an Identify Command
//  248  *
//  249  * @param   srcEP - Sending application's endpoint
//  250  * @param   dstAddr - where you want the message to go
//  251  * @param   identifyTime - how long the device will continue to identify itself (in seconds)
//  252  * @param   seqNum - identification number for the transaction
//  253  *
//  254  * @return  ZStatus_t
//  255  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  256 ZStatus_t zclGeneral_SendIdentify( uint8 srcEP, afAddrType_t *dstAddr,
zclGeneral_SendIdentify:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function zclGeneral_SendIdentify
        CODE
//  257                       uint16 identifyTime, uint8 disableDefaultRsp, uint8 seqNum )
//  258 {
        FUNCALL zclGeneral_SendIdentify, zcl_SendCommand
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 23, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     A,R1
        MOV     R6,A
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine3 & 0xFFFF
//  259   uint8 buf[2];
//  260 
//  261   buf[0] = LO_UINT16( identifyTime );
//  262   buf[1] = HI_UINT16( identifyTime );
??CrossCallReturnLabel_2:
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine2 & 0xFFFF
//  263 
//  264   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
//  265                           COMMAND_IDENTIFY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  266                           disableDefaultRsp, 0, seqNum, 2, buf );
??CrossCallReturnLabel_0:
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     ?V0 + 0,#0x2
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     A,R7
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 17)
        CLR     A
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 19)
        MOV     A,R1
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     ?V0 + 0,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 21)
        MOV     ?V0 + 0,#0x1
        CFI EndBlock cfiBlock2
        REQUIRE ?Subroutine1
        ; // Fall through to label ?Subroutine1

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine1:
        CFI Block cfiBlock3 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 21)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     ?V0 + 0,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 23)
        MOV     R4,#0x3
        MOV     R5,#0x0
        MOV     A,R6
        MOV     R1,A
        LCALL   ??zcl_SendCommand?relay
        MOV     A,#0xb
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI EndBlock cfiBlock3
        REQUIRE ??Subroutine10_0
        ; // Fall through to label ??Subroutine10_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine10_0:
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock4
//  267 }
//  268 
//  269 /*********************************************************************
//  270  * @fn      zclGeneral_SendIdentifyQueryResponse
//  271  *
//  272  * @brief   Call to send out an Identify Query Response Command
//  273  *
//  274  * @param   srcEP - Sending application's endpoint
//  275  * @param   dstAddr - where you want the message to go
//  276  * @param   timeout - how long the device will continue to identify itself (in seconds)
//  277  * @param   seqNum - identification number for the transaction
//  278  *
//  279  * @return  ZStatus_t
//  280  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  281 ZStatus_t zclGeneral_SendIdentifyQueryResponse( uint8 srcEP, afAddrType_t *dstAddr,
zclGeneral_SendIdentifyQueryResponse:
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function zclGeneral_SendIdentifyQueryResponse
        CODE
//  282                             uint16 timeout, uint8 disableDefaultRsp, uint8 seqNum )
//  283 {
        FUNCALL zclGeneral_SendIdentifyQueryResponse, zcl_SendCommand
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 23, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     A,R1
        MOV     R6,A
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine3 & 0xFFFF
//  284   uint8 buf[2];
//  285 
//  286   buf[0] = LO_UINT16( timeout );
//  287   buf[1] = HI_UINT16( timeout );
??CrossCallReturnLabel_3:
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine2 & 0xFFFF
//  288 
//  289   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
//  290                           COMMAND_IDENTIFY_QUERY_RSP, TRUE,
//  291                           ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, 2, buf );
??CrossCallReturnLabel_1:
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     ?V0 + 0,#0x2
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     A,R7
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 17)
        CLR     A
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 19)
        MOV     A,R1
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     ?V0 + 0,#0x1
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 21)
        SJMP    ?Subroutine1
        CFI EndBlock cfiBlock5

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine3:
        CFI Block cfiCond6 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_2
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond7 Using cfiCommon0
        CFI (cfiCond7) NoFunction
        CFI (cfiCond7) Conditional ??CrossCallReturnLabel_3
        CFI (cfiCond7) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond7) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond7) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond7) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond7) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond7) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond7) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond7) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond7) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond7) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond7) CFA_SP SP+0
        CFI (cfiCond7) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiPicker8 Using cfiCommon1
        CFI (cfiPicker8) NoFunction
        CFI (cfiPicker8) Picker
        MOVX    A,@DPTR
        MOV     R7,A
        MOV     A,R4
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
        MOV     A,#0x1
        RET
        CFI EndBlock cfiCond6
        CFI EndBlock cfiCond7
        CFI EndBlock cfiPicker8

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine2:
        CFI Block cfiCond9 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_0
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond10 Using cfiCommon0
        CFI (cfiCond10) NoFunction
        CFI (cfiCond10) Conditional ??CrossCallReturnLabel_1
        CFI (cfiCond10) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond10) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond10) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond10) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond10) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond10) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond10) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond10) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond10) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond10) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond10) CFA_SP SP+0
        CFI (cfiCond10) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiPicker11 Using cfiCommon1
        CFI (cfiPicker11) NoFunction
        CFI (cfiPicker11) Picker
        MOV     A,R5
        MOVX    @DPTR,A
        ; Setup parameters for call to function zcl_SendCommand
        ; Setup parameters for call to function zcl_SendCommand
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        RET
        CFI EndBlock cfiCond9
        CFI EndBlock cfiCond10
        CFI EndBlock cfiPicker11
//  292 }
//  293 #endif // ZCL_IDENTIFY
//  294 
//  295 #ifdef ZCL_GROUPS
//  296 /*********************************************************************
//  297  * @fn      zclGeneral_SendGroupRequest
//  298  *
//  299  * @brief   Send a Group Request to a device.  You can also use the
//  300  *          appropriate macro.
//  301  *
//  302  * @param   srcEP - Sending Apps endpoint
//  303  * @param   dstAddr - where to send the request
//  304  * @param   cmd - one of the following:
//  305  *              COMMAND_GROUP_VIEW
//  306  *              COMMAND_GROUP_REMOVE
//  307  * @param   groupID -
//  308  *
//  309  * @return  ZStatus_t
//  310  */
//  311 ZStatus_t zclGeneral_SendGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  312                      uint8 cmd, uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
//  313 {
//  314   uint8 buf[2];
//  315 
//  316   buf[0] = LO_UINT16( groupID );
//  317   buf[1] = HI_UINT16( groupID );
//  318 
//  319   return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  320                             cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  321                             disableDefaultRsp, 0, seqNum, 2, buf ) );
//  322 }
//  323 
//  324 /*********************************************************************
//  325  * @fn      zclGeneral_SendAddGroupRequest
//  326  *
//  327  * @brief   Send the Add Group Request to a device
//  328  *
//  329  * @param   srcEP - Sending Apps endpoint
//  330  * @param   dstAddr - where to send the request
//  331  * @param   cmd - one of the following:
//  332  *                COMMAND_GROUP_ADD
//  333  *                COMMAND_GROUP_ADD_IF_IDENTIFYING
//  334  * @param   groupID - pointer to the group structure
//  335  * @param   groupName - pointer to Group Name.  This is a Zigbee
//  336  *          string data type, so the first byte is the length of the
//  337  *          name (in bytes), then the name.
//  338  *
//  339  * @return  ZStatus_t
//  340  */
//  341 ZStatus_t zclGeneral_SendAddGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  342                                           uint8 cmd, uint16 groupID, uint8 *groupName,
//  343                                           uint8 disableDefaultRsp, uint8 seqNum )
//  344 {
//  345   uint8 *buf;
//  346   uint8 *pBuf;
//  347   uint8 len;
//  348   ZStatus_t status;
//  349 
//  350   len = 2;    // Group ID
//  351   len += groupName[0] + 1;  // String + 1 for length
//  352 
//  353   buf = osal_mem_alloc( len );
//  354   if ( buf )
//  355   {
//  356     pBuf = buf;
//  357     *pBuf++ = LO_UINT16( groupID );
//  358     *pBuf++ = HI_UINT16( groupID );
//  359     *pBuf++ = groupName[0]; // string length
//  360     osal_memcpy( pBuf, &(groupName[1]), groupName[0] );
//  361 
//  362     status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  363                               cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  364                               disableDefaultRsp, 0, seqNum, len, buf );
//  365     osal_mem_free( buf );
//  366   }
//  367   else
//  368     status = ZMemError;
//  369 
//  370   return ( status );
//  371 }
//  372 
//  373 /*********************************************************************
//  374  * @fn      zclGeneral_SendGroupGetMembershipRequest
//  375  *
//  376  * @brief   Send a Get Group Membership (Resposne) Command to a device
//  377  *
//  378  * @param   srcEP - Sending Apps endpoint
//  379  * @param   dstAddr - where to send the request
//  380  * @param   cmd - one of the following:
//  381  *                COMMAND_GROUP_GET_MEMBERSHIP
//  382  *                COMMAND_GROUP_GET_MEMBERSHIP_RSP
//  383  * @param   groupID - pointer to the group structure
//  384  * @param   groupName - pointer to Group Name.  This is a Zigbee
//  385  *          string data type, so the first byte is the length of the
//  386  *          name (in bytes), then the name.
//  387  *
//  388  * @return  ZStatus_t
//  389  */
//  390 ZStatus_t zclGeneral_SendGroupGetMembershipRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  391                               uint8 cmd, uint8 rspCmd, uint8 direction, uint8 capacity,
//  392                               uint8 grpCnt, uint16 *grpList, uint8 disableDefaultRsp, uint8 seqNum )
//  393 {
//  394   uint8 *buf;
//  395   uint8 *pBuf;
//  396   uint8 len = 0;
//  397   uint8 i;
//  398   ZStatus_t status;
//  399 
//  400   if ( rspCmd )
//  401     len++;  // Capacity
//  402 
//  403   len++;  // Group Count
//  404   len += sizeof ( uint16 ) * grpCnt;  // Group List
//  405 
//  406   buf = osal_mem_alloc( len );
//  407   if ( buf )
//  408   {
//  409     pBuf = buf;
//  410     if ( rspCmd )
//  411       *pBuf++ = capacity;
//  412 
//  413     *pBuf++ = grpCnt;
//  414     for ( i = 0; i < grpCnt; i++ )
//  415     {
//  416       *pBuf++ = LO_UINT16( grpList[i] );
//  417       *pBuf++ = HI_UINT16( grpList[i] );
//  418     }
//  419 
//  420     status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  421                               cmd, TRUE, direction,
//  422                               disableDefaultRsp, 0, seqNum, len, buf );
//  423     osal_mem_free( buf );
//  424   }
//  425   else
//  426     status = ZMemError;
//  427 
//  428   return ( status );
//  429 }
//  430 
//  431 /*********************************************************************
//  432  * @fn      zclGeneral_SendGroupResponse
//  433  *
//  434  * @brief   Send Group Response (not Group View Response)
//  435  *
//  436  * @param   srcEP - Sending application's endpoint
//  437  * @param   dstAddr - where you want the message to go
//  438  * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
//  439  * @param   status - group command status
//  440  * @param   groupID - what group
//  441  *
//  442  * @return  ZStatus_t
//  443  */
//  444 ZStatus_t zclGeneral_SendGroupResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  445                                         uint8 cmd, uint8 status, uint16 groupID,
//  446                                         uint8 disableDefaultRsp, uint8 seqNum )
//  447 {
//  448   uint8 buf[3];
//  449 
//  450   buf[0] = status;
//  451   buf[1] = LO_UINT16( groupID );
//  452   buf[2] = HI_UINT16( groupID );
//  453 
//  454   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  455                           cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  456                           disableDefaultRsp, 0, seqNum, 3, buf );
//  457 }
//  458 
//  459 /*********************************************************************
//  460  * @fn      zclGeneral_SendGroupViewResponse
//  461  *
//  462  * @brief   Call to send Group Response Command
//  463  *
//  464  * @param   srcEP - Sending application's endpoint
//  465  * @param   dstAddr - where you want the message to go
//  466  * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
//  467  * @param   status - group command status
//  468  * @param   grp - group info
//  469  *
//  470  * @return  ZStatus_t
//  471  */
//  472 ZStatus_t zclGeneral_SendGroupViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  473                  uint8 status, aps_Group_t *grp, uint8 disableDefaultRsp, uint8 seqNum )
//  474 {
//  475   uint8 *buf;
//  476   uint8 len;
//  477   ZStatus_t stat;
//  478 
//  479   len = 1 + 2; // Status + Group ID
//  480 
//  481   if ( status == ZCL_STATUS_SUCCESS )
//  482     len += grp->name[0] + 1;  // String + 1 for length
//  483 
//  484   buf = osal_mem_alloc( len );
//  485   if ( buf )
//  486   {
//  487     buf[0] = status;
//  488     buf[1] = LO_UINT16( grp->ID );
//  489     buf[2] = HI_UINT16( grp->ID );
//  490 
//  491     if ( status == ZCL_STATUS_SUCCESS )
//  492     {
//  493       buf[3] = grp->name[0]; // string length
//  494       osal_memcpy( &buf[4], (&grp->name[1]), grp->name[0] );
//  495     }
//  496 
//  497     stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  498                             COMMAND_GROUP_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  499                             disableDefaultRsp, 0, seqNum, len, buf );
//  500     osal_mem_free( buf );
//  501   }
//  502   else
//  503     stat = ZMemError;
//  504 
//  505   return ( stat );
//  506 }
//  507 #endif // ZCL_GROUPS
//  508 
//  509 #ifdef ZCL_SCENES
//  510 /*********************************************************************
//  511  * @fn      zclGeneral_SendAddScene
//  512  *
//  513  * @brief   Send the Add Scene Request to a device
//  514  *
//  515  * @param   srcEP - Sending Apps endpoint
//  516  * @param   dstAddr - where to send the request
//  517  * @param   scene - pointer to the scene structure
//  518  *
//  519  * @return  ZStatus_t
//  520  */
//  521 ZStatus_t zclGeneral_SendAddScene( uint8 srcEP, afAddrType_t *dstAddr,
//  522                       zclGeneral_Scene_t *scene, uint8 disableDefaultRsp, uint8 seqNum )
//  523 {
//  524   uint8 *buf;
//  525   uint8 *pBuf;
//  526   uint8 len;
//  527   ZStatus_t status;
//  528 
//  529   len = 2 + 1 + 2;    // Group ID + Scene ID + transition time
//  530   len += scene->name[0] + 1; // String + 1 for length
//  531 
//  532   // Add something for the extension field length
//  533   len += scene->extLen;
//  534 
//  535   buf = osal_mem_alloc( len );
//  536   if ( buf )
//  537   {
//  538     pBuf = buf;
//  539     *pBuf++ = LO_UINT16( scene->groupID );
//  540     *pBuf++ = HI_UINT16( scene->groupID );
//  541     *pBuf++ = scene->ID;
//  542     *pBuf++ = LO_UINT16( scene->transTime );
//  543     *pBuf++ = HI_UINT16( scene->transTime );
//  544     *pBuf++ = scene->name[0]; // string length
//  545     osal_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
//  546     pBuf += scene->name[0]; // move pass name
//  547 
//  548     // Add the extension fields
//  549     if ( scene->extLen > 0 )
//  550       osal_memcpy( pBuf, scene->extField, scene->extLen );
//  551 
//  552     status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  553                               COMMAND_SCENE_ADD, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  554                               disableDefaultRsp, 0, seqNum, len, buf );
//  555     osal_mem_free( buf );
//  556   }
//  557   else
//  558     status = ZMemError;
//  559 
//  560   return ( status );
//  561 }
//  562 
//  563 /*********************************************************************
//  564  * @fn      zclGeneral_SendSceneRequest
//  565  *
//  566  * @brief   Send a Scene Request to a device.  You can also use the
//  567  *          appropriate macro.
//  568  *
//  569  * @param   srcEP - Sending Apps endpoint
//  570  * @param   dstAddr - where to send the request
//  571  * @param   cmd - one of the following:
//  572  *              COMMAND_SCENE_VIEW
//  573  *              COMMAND_SCENE_REMOVE
//  574  *              COMMAND_SCENE_REMOVE_ALL
//  575  *              COMMAND_SCENE_STORE
//  576  *              COMMAND_SCENE_RECALL
//  577  *              COMMAND_SCENE_GET_MEMBERSHIP
//  578  * @param   groupID - group ID
//  579  * @param   sceneID - scene ID (not applicable to COMMAND_SCENE_REMOVE_ALL and
//  580  *                    COMMAND_SCENE_GET_MEMBERSHIP)
//  581  * @return  ZStatus_t
//  582  */
//  583 ZStatus_t zclGeneral_SendSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  584                                        uint8 cmd, uint16 groupID, uint8 sceneID,
//  585                                        uint8 disableDefaultRsp, uint8 seqNum )
//  586 {
//  587   uint8 buf[3];
//  588   uint8 len = 2;
//  589 
//  590   buf[0] = LO_UINT16( groupID );
//  591   buf[1] = HI_UINT16( groupID );
//  592 
//  593   if ( cmd != COMMAND_SCENE_REMOVE_ALL && cmd != COMMAND_SCENE_GET_MEMBERSHIP )
//  594   {
//  595     buf[2] = sceneID;
//  596     len++;
//  597   }
//  598 
//  599   return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  600                             cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  601                             disableDefaultRsp, 0, seqNum, len, buf ) );
//  602 }
//  603 
//  604 /*********************************************************************
//  605  * @fn      zclGeneral_SendSceneResponse
//  606  *
//  607  * @brief   Send Group Response (not Group View Response)
//  608  *
//  609  * @param   srcEP - Sending application's endpoint
//  610  * @param   dstAddr - where you want the message to go
//  611  * @param   cmd - either COMMAND_SCENE_ADD_RSP, COMMAND_SCENE_REMOVE_RSP
//  612  *                COMMAND_SCENE_STORE_RSP, or COMMAND_SCENE_REMOVE_ALL_RSP
//  613  * @param   status - scene command status
//  614  * @param   groupID - what group
//  615  * @param   sceneID - what scene (not applicable to COMMAND_SCENE_REMOVE_ALL_RSP)
//  616  *
//  617  * @return  ZStatus_t
//  618  */
//  619 ZStatus_t zclGeneral_SendSceneResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  620                                   uint8 cmd, uint8 status, uint16 groupID,
//  621                                   uint8 sceneID, uint8 disableDefaultRsp, uint8 seqNum )
//  622 {
//  623   uint8 buf[4];
//  624   uint8 len = 1 + 2; // Status + Group ID
//  625 
//  626   buf[0] = status;
//  627   buf[1] = LO_UINT16( groupID );
//  628   buf[2] = HI_UINT16( groupID );
//  629 
//  630   if ( cmd != COMMAND_SCENE_REMOVE_ALL_RSP )
//  631   {
//  632     buf[3] = sceneID;
//  633     len++;
//  634   }
//  635 
//  636   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  637                           cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  638                           disableDefaultRsp, 0, seqNum, len, buf );
//  639 }
//  640 
//  641 /*********************************************************************
//  642  * @fn      zclGeneral_SendSceneViewResponse
//  643  *
//  644  * @brief   Call to send Scene Response Command
//  645  *
//  646  * @param   srcEP - Sending application's endpoint
//  647  * @param   dstAddr - where you want the message to go
//  648  * @param   status - scene command status
//  649  * @param   scene - scene info
//  650  *
//  651  * @return  ZStatus_t
//  652  */
//  653 ZStatus_t zclGeneral_SendSceneViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  654                                        uint8 status, zclGeneral_Scene_t *scene,
//  655                                        uint8 disableDefaultRsp, uint8 seqNum )
//  656 {
//  657   uint8 *buf;
//  658   uint8 *pBuf;
//  659   uint8 len = 1 + 2 + 1; // Status + Group ID + Scene ID
//  660   ZStatus_t stat;
//  661 
//  662   if ( status == ZCL_STATUS_SUCCESS )
//  663   {
//  664     len += 2; // Transition Time
//  665     len += scene->name[0] + 1; // string + 1 for length
//  666 
//  667     // Add something for the extension field length
//  668     len += scene->extLen;
//  669   }
//  670 
//  671   buf = osal_mem_alloc( len );
//  672   if ( buf )
//  673   {
//  674     pBuf = buf;
//  675     *pBuf++ = status;
//  676     *pBuf++ = LO_UINT16( scene->groupID );
//  677     *pBuf++ = HI_UINT16( scene->groupID );
//  678     *pBuf++ = scene->ID;
//  679     if ( status == ZCL_STATUS_SUCCESS )
//  680     {
//  681       *pBuf++ = LO_UINT16( scene->transTime );
//  682       *pBuf++ = HI_UINT16( scene->transTime );
//  683       *pBuf++ = scene->name[0]; // string length
//  684       if ( scene->name[0] != 0 )
//  685       {
//  686         osal_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
//  687         pBuf += scene->name[0]; // move pass name
//  688       }
//  689 
//  690       // Add the extension fields
//  691       if ( scene->extLen > 0 )
//  692         osal_memcpy( pBuf, scene->extField, scene->extLen );
//  693     }
//  694 
//  695     stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  696                             COMMAND_SCENE_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  697                             disableDefaultRsp, 0, seqNum, len, buf );
//  698     osal_mem_free( buf );
//  699   }
//  700   else
//  701     stat = ZMemError;
//  702 
//  703   return ( stat );
//  704 }
//  705 
//  706 /*********************************************************************
//  707  * @fn      zclGeneral_SendSceneGetMembershipResponse
//  708  *
//  709  * @brief   Call to send Scene Get Membership Response Command
//  710  *
//  711  * @param   srcEP - Sending application's endpoint
//  712  * @param   dstAddr - where you want the message to go
//  713  * @param   status - scene command status
//  714  * @param   capacity - remaining capacity of the scene table
//  715  * @param   sceneCnt - number of scenes in the scene list
//  716  * @param   sceneList - list of scene IDs
//  717  * @param   groupID - group ID that scene belongs to
//  718  * @param   seqNum - sequence number
//  719  *
//  720  * @return  ZStatus_t
//  721  */
//  722 ZStatus_t zclGeneral_SendSceneGetMembershipResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  723                        uint8 status, uint8 capacity, uint8 sceneCnt, uint8 *sceneList,
//  724                        uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
//  725 {
//  726   uint8 *buf;
//  727   uint8 *pBuf;
//  728   uint8 len = 1 + 1 + 2; // Status + Capacity + Group ID;
//  729   uint8 i;
//  730   ZStatus_t stat;
//  731 
//  732   if ( status == ZCL_STATUS_SUCCESS )
//  733   {
//  734     len++; // Scene Count
//  735     len += sceneCnt; // Scene List (Scene ID is a single octet)
//  736   }
//  737 
//  738   buf = osal_mem_alloc( len );
//  739   if ( buf )
//  740   {
//  741     pBuf = buf;
//  742     *pBuf++ = status;
//  743     *pBuf++ = capacity;
//  744     *pBuf++ = LO_UINT16( groupID );
//  745     *pBuf++ = HI_UINT16( groupID );
//  746     if ( status == ZCL_STATUS_SUCCESS )
//  747     {
//  748       *pBuf++ = sceneCnt;
//  749       for ( i = 0; i < sceneCnt; i++ )
//  750         *pBuf++ = sceneList[i];
//  751     }
//  752 
//  753     stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  754                             COMMAND_SCENE_GET_MEMBERSHIP_RSP, TRUE,
//  755                             ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
//  756     osal_mem_free( buf );
//  757   }
//  758   else
//  759     stat = ZMemError;
//  760 
//  761   return ( stat );
//  762 }
//  763 #endif // ZCL_SCENES
//  764 
//  765 #ifdef ZCL_LEVEL_CTRL
//  766 /*********************************************************************
//  767  * @fn      zclGeneral_SendLevelControlMoveToLevelRequest
//  768  *
//  769  * @brief   Call to send out a Level Control Request. You can also use
//  770  *          the appropriate macro.
//  771  *
//  772  * @param   srcEP - Sending application's endpoint
//  773  * @param   dstAddr - where you want the message to go
//  774  * @param   cmd - one of the following:
//  775  *              COMMAND_LEVEL_MOVE_TO_LEVEL or
//  776  *              COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF
//  777  * @param   level - what level to move to
//  778  * @param   transitionTime - how long to take to get to the level (in seconds)
//  779  *
//  780  * @return  ZStatus_t
//  781  */
//  782 ZStatus_t zclGeneral_SendLevelControlMoveToLevelRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  783                                                          uint8 cmd, uint8 level, uint16 transTime,
//  784                                                          uint8 disableDefaultRsp, uint8 seqNum )
//  785 {
//  786   uint8 buf[3];
//  787 
//  788   buf[0] = level;
//  789   buf[1] = LO_UINT16( transTime );
//  790   buf[2] = HI_UINT16( transTime );
//  791 
//  792   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
//  793                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  794                           disableDefaultRsp, 0, seqNum, 3, buf );
//  795 }
//  796 
//  797 /*********************************************************************
//  798  * @fn      zclGeneral_SendLevelControlMoveRequest
//  799  *
//  800  * @brief   Call to send out a Level Control Request. You can also use
//  801  *          the appropriate macro.
//  802  *
//  803  * @param   srcEP - Sending application's endpoint
//  804  * @param   dstAddr - where you want the message to go
//  805  * @param   cmd - one of the following:
//  806  *              COMMAND_LEVEL_MOVE or
//  807  *              COMMAND_LEVEL_MOVE_WITH_ON_OFF
//  808  * @param   moveMode - LEVEL_MOVE_UP or
//  809  *                     LEVEL_MOVE_DOWN
//  810  * @param   rate - number of steps to take per second
//  811  *
//  812  * @return  ZStatus_t
//  813  */
//  814 ZStatus_t zclGeneral_SendLevelControlMoveRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  815                                                   uint8 cmd, uint8 moveMode, uint8 rate,
//  816                                                   uint8 disableDefaultRsp, uint8 seqNum )
//  817 {
//  818   uint8 buf[2];
//  819 
//  820   buf[0] = moveMode;
//  821   buf[1] = rate;
//  822 
//  823   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
//  824                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  825                           disableDefaultRsp, 0, seqNum, 2, buf );
//  826 }
//  827 
//  828 /*********************************************************************
//  829  * @fn      zclGeneral_SendLevelControlStepRequest
//  830  *
//  831  * @brief   Call to send out a Level Control Request. You can also use
//  832  *          the appropriate macro.
//  833  *
//  834  * @param   srcEP - Sending application's endpoint
//  835  * @param   dstAddr - where you want the message to go
//  836  * @param   cmd - one of the following:
//  837  *              COMMAND_LEVEL_STEP
//  838  *              COMMAND_LEVEL_STEP_WITH_ON_OFF
//  839  * @param   stepMode - LEVEL_STEP_UP or
//  840  *                     LEVEL_STEP_DOWN
//  841  * @param   amount - number of levels to step
//  842  * @param   transitionTime - time, in 1/10ths of a second, to take to perform the step
//  843  *
//  844  * @return  ZStatus_t
//  845  */
//  846 ZStatus_t zclGeneral_SendLevelControlStepRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  847                          uint8 cmd, uint8 stepMode, uint8 stepSize, uint16 transTime,
//  848                          uint8 disableDefaultRsp, uint8 seqNum )
//  849 {
//  850   uint8 buf[4];
//  851 
//  852   buf[0] = stepMode;
//  853   buf[1] = stepSize;
//  854   buf[2] = LO_UINT16( transTime );
//  855   buf[3] = HI_UINT16( transTime );
//  856 
//  857   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
//  858                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  859                           disableDefaultRsp, 0, seqNum, 4, buf );
//  860 }
//  861 #endif // ZCL_LEVEL_CTRL
//  862 
//  863 #ifdef ZCL_ALARMS
//  864 /*********************************************************************
//  865  * @fn      zclGeneral_SendAlarmRequest
//  866  *
//  867  * @brief   Call to send out an Alarm Request Command
//  868  *
//  869  * @param   srcEP - Sending application's endpoint
//  870  * @param   dstAddr - where you want the message to go
//  871  * @param   cmd - either COMMAND_ALARMS_RESET or COMMAND_ALARMS_ALARM
//  872  * @param   alarmCode - code for the cause of the alarm
//  873  * @param   clusterID - cluster whose attribute generate the alarm
//  874  *
//  875  * @return  ZStatus_t
//  876  */
//  877 ZStatus_t zclGeneral_SendAlarmRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  878                                        uint8 cmd, uint8 alarmCode, uint16 clusterID,
//  879                                        uint8 disableDefaultRsp, uint8 seqNum )
//  880 {
//  881   uint8 buf[3];
//  882 
//  883   buf[0] = alarmCode;
//  884   buf[1] = LO_UINT16( clusterID );
//  885   buf[2] = HI_UINT16( clusterID );
//  886 
//  887   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
//  888                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  889                           disableDefaultRsp, 0, seqNum, 3, buf );
//  890 }
//  891 
//  892 /*********************************************************************
//  893  * @fn      zclGeneral_SendAlarmGetRespnose
//  894  *
//  895  * @brief   Call to send out an Alarm Get Response Command
//  896  *
//  897  * @param   srcEP - Sending application's endpoint
//  898  * @param   dstAddr - where you want the message to go
//  899  * @param   status - SUCCESS or NOT_FOUND
//  900  * @param   alarmCode - code for the cause of the alarm
//  901  * @param   clusterID - cluster whose attribute generate the alarm
//  902  * @param   timeStamp - time at which the alarm occured
//  903  *
//  904  * @return  ZStatus_t
//  905  */
//  906 ZStatus_t zclGeneral_SendAlarmGetRespnose( uint8 srcEP, afAddrType_t *dstAddr,
//  907                               uint8 status, uint8 alarmCode, uint16 clusterID,
//  908                               uint32 timeStamp, uint8 disableDefaultRsp, uint8 seqNum )
//  909 {
//  910   uint8 buf[8];
//  911   uint8 len = 1; // Status
//  912 
//  913   buf[0] = status;
//  914   if ( status == ZCL_STATUS_SUCCESS )
//  915   {
//  916     len += 1 + 2 + 4; // Alarm code + Cluster ID + Time stamp
//  917     buf[1] = alarmCode;
//  918     buf[2] = LO_UINT16( clusterID );
//  919     buf[3] = HI_UINT16( clusterID );
//  920     osal_buffer_uint32( &buf[4], timeStamp );
//  921   }
//  922 
//  923   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
//  924                           COMMAND_ALARMS_GET_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  925                           disableDefaultRsp, 0, seqNum, len, buf );
//  926 }
//  927 
//  928 #ifdef SE_UK_EXT
//  929 /*********************************************************************
//  930  * @fn      zclGeneral_SendAlarmGetEventLog
//  931  *
//  932  * @brief   Call to send out an Alarm Get Event Log Command
//  933  *
//  934  * @param   srcEP - Sending application's endpoint
//  935  * @param   dstAddr - where you want the message to go
//  936  * @param   pEventLog - pointer to Get Event Log Command
//  937  * @param   disableDefaultRsp - disable default response
//  938  * @param   seqNum - ZCL sequence number
//  939  *
//  940  * @return  ZStatus_t
//  941  */
//  942 ZStatus_t zclGeneral_SendAlarmGetEventLog( uint8 srcEP, afAddrType_t *dstAddr,
//  943                                            zclGetEventLog_t *pEventLog,
//  944                                            uint8 disableDefaultRsp, uint8 seqNum )
//  945 {
//  946   uint8 buf[10];
//  947 
//  948   buf[0] = pEventLog->logID;
//  949   osal_buffer_uint32( &buf[1], pEventLog->startTime );
//  950   osal_buffer_uint32( &buf[5], pEventLog->endTime );
//  951   buf[9] = pEventLog->numEvents;
//  952   
//  953   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
//  954                           COMMAND_ALARMS_GET_EVENT_LOG, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  955                           disableDefaultRsp, 0, seqNum, 10, buf );
//  956 }
//  957 
//  958 /*********************************************************************
//  959  * @fn      zclGeneral_SendAlarmPublishEventLog
//  960  *
//  961  * @brief   Call to send out an Alarm Publish Event Log Command
//  962  *
//  963  * @param   srcEP - Sending application's endpoint
//  964  * @param   dstAddr - where you want the message to go
//  965  * @param   pEventLog - pointer to Publish Event Log Command
//  966  * @param   disableDefaultRsp - disable default response
//  967  * @param   seqNum - ZCL sequence number
//  968  *
//  969  * @return  ZStatus_t
//  970  */
//  971 ZStatus_t zclGeneral_SendAlarmPublishEventLog( uint8 srcEP, afAddrType_t *dstAddr,
//  972                                                zclPublishEventLog_t *pEventLog,
//  973                                                uint8 disableDefaultRsp, uint8 seqNum )
//  974 {
//  975   uint8 *buf;
//  976   uint8 *pBuf;
//  977   uint8 bufLen;
//  978   
//  979   // Log ID + Command Index + Total Commands + (numSubLogs * ( Event ID + Event Time))
//  980   bufLen = 1 + 1 + 1 + (pEventLog->numSubLogs * (1 + 4));
//  981   
//  982   buf = osal_mem_alloc( bufLen );
//  983   if ( buf == NULL )
//  984   {
//  985     return (ZMemError);
//  986   }
//  987   
//  988   pBuf = buf;
//  989   *pBuf++ = pEventLog->logID;
//  990   *pBuf++ = pEventLog->cmdIndex;
//  991   *pBuf++ = pEventLog->totalCmds;
//  992   
//  993   for ( uint8 i = 0; i < pEventLog->numSubLogs; i++ )
//  994   {
//  995     zclEventLogPayload_t *pLogs = &(pEventLog->pLogs[i]);
//  996     
//  997     *pBuf++ = pLogs->eventId;
//  998     pBuf = osal_buffer_uint32( pBuf, pLogs->eventTime );
//  999   }
// 1000   
// 1001   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
// 1002                           COMMAND_ALARMS_PUBLISH_EVENT_LOG, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
// 1003                           disableDefaultRsp, 0, seqNum, bufLen, buf );
// 1004 }
// 1005 #endif // SE_UK_EXT
// 1006 #endif // ZCL_ALARMS
// 1007 
// 1008 #ifdef ZCL_LOCATION
// 1009 /*********************************************************************
// 1010  * @fn      zclGeneral_SendLocationSetAbsolute
// 1011  *
// 1012  * @brief   Call to send out a Set Absolute Location Command
// 1013  *
// 1014  * @param   srcEP - Sending application's endpoint
// 1015  * @param   dstAddr - where you want the message to go
// 1016  * @param   absLoc - absolute location info
// 1017  *
// 1018  * @return  ZStatus_t
// 1019  */
// 1020 ZStatus_t zclGeneral_SendLocationSetAbsolute( uint8 srcEP, afAddrType_t *dstAddr,
// 1021                                               zclLocationAbsolute_t *absLoc,
// 1022                                               uint8 disableDefaultRsp, uint8 seqNum )
// 1023 {
// 1024    uint8 buf[10]; // 5 fields (2 octects each)
// 1025 
// 1026    buf[0] = LO_UINT16( absLoc->coordinate1 );
// 1027    buf[1] = HI_UINT16( absLoc->coordinate1 );
// 1028    buf[2] = LO_UINT16( absLoc->coordinate2 );
// 1029    buf[3] = HI_UINT16( absLoc->coordinate2 );
// 1030    buf[4] = LO_UINT16( absLoc->coordinate3 );
// 1031    buf[5] = HI_UINT16( absLoc->coordinate3 );
// 1032    buf[6] = LO_UINT16( absLoc->power );
// 1033    buf[7] = HI_UINT16( absLoc->power );
// 1034    buf[8] = LO_UINT16( absLoc->pathLossExponent );
// 1035    buf[9] = HI_UINT16( absLoc->pathLossExponent );
// 1036 
// 1037    return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1038                            COMMAND_LOCATION_SET_ABSOLUTE, TRUE,
// 1039                            ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 10, buf );
// 1040 }
// 1041 
// 1042 /*********************************************************************
// 1043  * @fn      zclGeneral_SendLocationSetDevCfg
// 1044  *
// 1045  * @brief   Call to send out a Set Device Configuration Command
// 1046  *
// 1047  * @param   srcEP - Sending application's endpoint
// 1048  * @param   dstAddr - where you want the message to go
// 1049  * @param   devCfg - device configuration info
// 1050  *
// 1051  * @return  ZStatus_t
// 1052  */
// 1053 ZStatus_t zclGeneral_SendLocationSetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
// 1054                                             zclLocationDevCfg_t *devCfg,
// 1055                                             uint8 disableDefaultRsp, uint8 seqNum )
// 1056 {
// 1057    uint8 buf[9];  // 4 fields (2 octects each) + 1 field with 1 octect
// 1058 
// 1059    buf[0] = LO_UINT16( devCfg->power );
// 1060    buf[1] = HI_UINT16( devCfg->power );
// 1061    buf[2] = LO_UINT16( devCfg->pathLossExponent );
// 1062    buf[3] = HI_UINT16( devCfg->pathLossExponent );
// 1063    buf[4] = LO_UINT16( devCfg->calcPeriod );
// 1064    buf[5] = HI_UINT16( devCfg->calcPeriod );
// 1065    buf[6] = devCfg->numMeasurements;
// 1066    buf[7] = LO_UINT16( devCfg->reportPeriod );
// 1067    buf[8] = HI_UINT16( devCfg->reportPeriod );
// 1068 
// 1069    return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1070                            COMMAND_LOCATION_SET_DEV_CFG, TRUE,
// 1071                            ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 9, buf );
// 1072 }
// 1073 
// 1074 /*********************************************************************
// 1075  * @fn      zclGeneral_SendLocationGetDevCfg
// 1076  *
// 1077  * @brief   Call to send out a Get Device Configuration Command
// 1078  *
// 1079  * @param   srcEP - Sending application's endpoint
// 1080  * @param   dstAddr - where you want the message to go
// 1081  * @param   targetAddr - device for which location parameters are being requested
// 1082  *
// 1083  * @return  ZStatus_t
// 1084  */
// 1085 ZStatus_t zclGeneral_SendLocationGetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
// 1086                        uint8 *targetAddr, uint8 disableDefaultRsp, uint8 seqNum )
// 1087 {
// 1088   uint8 buf[8];
// 1089 
// 1090   osal_cpyExtAddr( buf, targetAddr );
// 1091 
// 1092   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1093                           COMMAND_LOCATION_GET_DEV_CFG, TRUE,
// 1094                           ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 8, buf );
// 1095 }
// 1096 
// 1097 /*********************************************************************
// 1098  * @fn      zclGeneral_SendLocationGetData
// 1099  *
// 1100  * @brief   Call to send out a Get Location Data Command
// 1101  *
// 1102  * @param   srcEP - Sending application's endpoint
// 1103  * @param   dstAddr - where you want the message to go
// 1104  * @param   locaData - location information and channel parameters that are requested.
// 1105  *
// 1106  * @return  ZStatus_t
// 1107  */
// 1108 ZStatus_t zclGeneral_SendLocationGetData( uint8 srcEP, afAddrType_t *dstAddr,
// 1109                                           zclLocationGetData_t *locData,
// 1110                                           uint8 disableDefaultRsp, uint8 seqNum )
// 1111 {
// 1112   uint8 buf[10]; // bitmap (1) + number responses (1) + IEEE Address (8)
// 1113   uint8 *pBuf = buf;
// 1114   uint8 len = 2; // bitmap + number responses
// 1115 
// 1116   *pBuf  = locData->absoluteOnly;
// 1117   *pBuf |= locData->recalculate << 1;
// 1118   *pBuf |= locData->brdcastIndicator << 2;
// 1119   *pBuf |= locData->brdcastResponse << 3;
// 1120   *pBuf |= locData->compactResponse << 4;
// 1121   pBuf++;  // move past the bitmap field
// 1122 
// 1123   *pBuf++ = locData->numResponses;
// 1124 
// 1125   if ( locData->brdcastIndicator == 0 )
// 1126   {
// 1127     osal_cpyExtAddr( pBuf, locData->targetAddr );
// 1128     len += 8; // ieee addr
// 1129   }
// 1130 
// 1131   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1132                           COMMAND_LOCATION_GET_DATA, TRUE,
// 1133                           ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, len, buf );
// 1134 }
// 1135 
// 1136 /*********************************************************************
// 1137  * @fn      zclGeneral_SendLocationDevCfgResponse
// 1138  *
// 1139  * @brief   Call to send out a Device Configuration Response Command
// 1140  *
// 1141  * @param   srcEP - Sending application's endpoint
// 1142  * @param   dstAddr - where you want the message to go
// 1143  * @param   devCfg - device's location parameters that are requested
// 1144  *
// 1145  * @return  ZStatus_t
// 1146  */
// 1147 ZStatus_t zclGeneral_SendLocationDevCfgResponse( uint8 srcEP, afAddrType_t *dstAddr,
// 1148                                                  zclLocationDevCfgRsp_t *devCfg,
// 1149                                                  uint8 disableDefaultRsp, uint8 seqNum )
// 1150 {
// 1151   uint8 buf[10]; // 4 fields (2 octects each) + 2 fields (1 octect each)
// 1152   uint8 len = 1; // Status
// 1153 
// 1154   buf[0] = devCfg->status;
// 1155   if ( devCfg->status == ZCL_STATUS_SUCCESS )
// 1156   {
// 1157     buf[1] = LO_UINT16( devCfg->data.power );
// 1158     buf[2] = HI_UINT16( devCfg->data.power );
// 1159     buf[3] = LO_UINT16( devCfg->data.pathLossExponent );
// 1160     buf[4] = HI_UINT16( devCfg->data.pathLossExponent );
// 1161     buf[5] = LO_UINT16( devCfg->data.calcPeriod );
// 1162     buf[6] = HI_UINT16( devCfg->data.calcPeriod );
// 1163     buf[7] = devCfg->data.numMeasurements;
// 1164     buf[8] = LO_UINT16( devCfg->data.reportPeriod );
// 1165     buf[9] = HI_UINT16( devCfg->data.reportPeriod );
// 1166     len += 9;
// 1167   }
// 1168 
// 1169   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1170                           COMMAND_LOCATION_DEV_CFG_RSP, TRUE,
// 1171                           ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
// 1172 }
// 1173 
// 1174 /*********************************************************************
// 1175  * @fn      zclGeneral_SendLocationData
// 1176  *
// 1177  * @brief   Call to send out location data
// 1178  *
// 1179  * @param   srcEP - Sending application's endpoint
// 1180  * @param   dstAddr - where you want the message to go
// 1181  * @param   status - indicates whether response to request was successful or not
// 1182  * @param   locData - location information and channel parameters being sent
// 1183  *
// 1184  * @return  ZStatus_t
// 1185  */
// 1186 ZStatus_t zclGeneral_SendLocationData( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
// 1187                                        uint8 status, zclLocationData_t *locData,
// 1188                                        uint8 disableDefaultRsp, uint8 seqNum )
// 1189 {
// 1190   uint8 buf[16];
// 1191   uint8 *pBuf = buf;
// 1192   uint8 len = 0;
// 1193 
// 1194   if ( cmd == COMMAND_LOCATION_DATA_RSP )
// 1195   {
// 1196     // Only response command includes a status field
// 1197     *pBuf++ = status;
// 1198     len++;
// 1199   }
// 1200 
// 1201   if ( cmd != COMMAND_LOCATION_DATA_RSP || status == ZCL_STATUS_SUCCESS )
// 1202   {
// 1203     // Notification or Response with successful status
// 1204     *pBuf++ = locData->type;
// 1205     *pBuf++ = LO_UINT16( locData->absLoc.coordinate1 );
// 1206     *pBuf++ = HI_UINT16( locData->absLoc.coordinate1 );
// 1207     *pBuf++ = LO_UINT16( locData->absLoc.coordinate2 );
// 1208     *pBuf++ = HI_UINT16( locData->absLoc.coordinate2 );
// 1209     len += 5;
// 1210 
// 1211     if ( locationType2D(locData->type) == 0 )
// 1212     {
// 1213       // 2D location doesn't have coordinate 3
// 1214       *pBuf++ = LO_UINT16( locData->absLoc.coordinate3 );
// 1215       *pBuf++ = HI_UINT16( locData->absLoc.coordinate3 );
// 1216       len += 2;
// 1217     }
// 1218 
// 1219     if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 1220     {
// 1221       // Compact notification doesn't include these fields
// 1222       *pBuf++ = LO_UINT16( locData->absLoc.power );
// 1223       *pBuf++ = HI_UINT16( locData->absLoc.power );
// 1224       *pBuf++ = LO_UINT16( locData->absLoc.pathLossExponent );
// 1225       *pBuf++ = HI_UINT16( locData->absLoc.pathLossExponent );
// 1226       len += 4;
// 1227     }
// 1228 
// 1229     if ( locationTypeAbsolute(locData->type) == 0 )
// 1230     {
// 1231       // Absolute location doesn't include these fields
// 1232       if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 1233       {
// 1234         // Compact notification doesn't include this field
// 1235         *pBuf++ = locData->calcLoc.locationMethod;
// 1236         len++;
// 1237       }
// 1238 
// 1239       *pBuf++ = locData->calcLoc.qualityMeasure;
// 1240       *pBuf++ = LO_UINT16( locData->calcLoc.locationAge );
// 1241       *pBuf++ = HI_UINT16( locData->calcLoc.locationAge );
// 1242       len += 3;
// 1243     }
// 1244   }
// 1245 
// 1246   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1247                           cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
// 1248                           disableDefaultRsp, 0, seqNum, len, buf );
// 1249 }
// 1250 #endif // ZCL_LOCATION
// 1251 
// 1252 /*********************************************************************
// 1253  * @fn      zclGeneral_FindCallbacks
// 1254  *
// 1255  * @brief   Find the callbacks for an endpoint
// 1256  *
// 1257  * @param   endpoint - endpoint to find the application callbacks for
// 1258  *
// 1259  * @return  pointer to the callbacks
// 1260  */
// 1261 static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint )
// 1262 {
// 1263   zclGenCBRec_t *pCBs;
// 1264 
// 1265   pCBs = zclGenCBs;
// 1266   while ( pCBs )
// 1267   {
// 1268     if ( pCBs->endpoint == endpoint )
// 1269       return ( pCBs->CBs );
// 1270     pCBs = pCBs->next;
// 1271   }
// 1272   return ( (zclGeneral_AppCallbacks_t *)NULL );
// 1273 }
// 1274 
// 1275 /*********************************************************************
// 1276  * @fn      zclGeneral_HdlIncoming
// 1277  *
// 1278  * @brief   Callback from ZCL to process incoming Commands specific
// 1279  *          to this cluster library or Profile commands for attributes
// 1280  *          that aren't in the attribute list
// 1281  *
// 1282  *
// 1283  * @param   pInMsg - pointer to the incoming message
// 1284  *
// 1285  * @return  ZStatus_t
// 1286  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1287 static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg )
zclGeneral_HdlIncoming:
        CFI Block cfiBlock12 Using cfiCommon0
        CFI Function zclGeneral_HdlIncoming
        CODE
// 1288 {
        FUNCALL zclGeneral_HdlIncoming, zclGeneral_HdlInSpecificCommands
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1289   ZStatus_t stat = ZSuccess;
// 1290 
// 1291 #if defined ( INTER_PAN )
// 1292   if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
// 1293     return ( stat ); // Cluster not supported thru Inter-PAN
// 1294 #endif
// 1295   if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        ANL     A,#0x3
        XRL     A,#0x1
        JNZ     ??zclGeneral_HdlIncoming_0
// 1296   {
// 1297     // Is this a manufacturer specific command?
// 1298     if ( pInMsg->hdr.fc.manuSpecific == 0 )
        MOV     A,R0
        ANL     A,#0x4
        JNZ     ??zclGeneral_HdlIncoming_0
// 1299     {
// 1300       stat = zclGeneral_HdlInSpecificCommands( pInMsg );
        ; Setup parameters for call to function zclGeneral_HdlInSpecificCommands
        LCALL   ??zclGeneral_HdlInSpecificCommands?relay
        SJMP    ??zclGeneral_HdlIncoming_1
// 1301     }
// 1302     else
// 1303     {
// 1304       // We don't support any manufacturer specific command.
// 1305       stat = ZFailure;
??zclGeneral_HdlIncoming_0:
        MOV     R1,#0x1
// 1306     }
// 1307   }
// 1308   else
// 1309   {
// 1310     // Handle all the normal (Read, Write...) commands -- should never get here
// 1311     stat = ZFailure;
// 1312   }
// 1313   return ( stat );
??zclGeneral_HdlIncoming_1:
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-4
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-3
        LJMP    ?BRET
        CFI EndBlock cfiBlock12
// 1314 }
// 1315 
// 1316 /*********************************************************************
// 1317  * @fn      zclGeneral_HdlInSpecificCommands
// 1318  *
// 1319  * @brief   Callback from ZCL to process incoming Commands specific
// 1320  *          to this cluster library
// 1321 
// 1322  * @param   pInMsg - pointer to the incoming message
// 1323  *
// 1324  * @return  ZStatus_t
// 1325  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1326 static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg )
zclGeneral_HdlInSpecificCommands:
        CFI Block cfiBlock13 Using cfiCommon0
        CFI Function zclGeneral_HdlInSpecificCommands
        CODE
// 1327 {
        FUNCALL zclGeneral_HdlInSpecificCommands, zclGeneral_ProcessInIdentity
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
// 1328   ZStatus_t stat;
// 1329   zclGeneral_AppCallbacks_t *pCBs;
// 1330   
// 1331   // make sure endpoint exists
// 1332   pCBs = zclGeneral_FindCallbacks( pInMsg->msg->endPoint );
        MOV     DPL,R2
        LCALL   ?Subroutine6 & 0xFFFF
??CrossCallReturnLabel_8:
        LCALL   ?Subroutine9 & 0xFFFF
??CrossCallReturnLabel_16:
        MOV     R4,A
        MOV     DPTR,#zclGenCBs
??zclGeneral_HdlInSpecificCommands_0:
        LCALL   ?Subroutine8 & 0xFFFF
??CrossCallReturnLabel_12:
        ORL     A,R1
        JZ      ??zclGeneral_HdlInSpecificCommands_1
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R4
        MOV     DPL,R0
        MOV     DPH,R1
        JNZ     ??zclGeneral_HdlInSpecificCommands_0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
// 1333   if ( pCBs == NULL )
        MOV     A,R4
        ORL     A,R5
        JZ      ??zclGeneral_HdlInSpecificCommands_1
// 1334     return ( ZFailure );
// 1335 
// 1336   switch ( pInMsg->msg->clusterId )
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
        MOV     R0,#?V0 + 0
        LCALL   ?US_SWITCH_SPARSE
`?<Jumptable for zclGeneral_HdlInSpecificComman_0`:
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        0
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        3
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        0
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclGeneral_HdlInSpecificCommands_2
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        3
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclGeneral_HdlInSpecificCommands_3
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        6
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclGeneral_HdlInSpecificCommands_4
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclGeneral_HdlInSpecificCommands_5
        CODE
// 1337   {
// 1338 #ifdef ZCL_BASIC
// 1339     case ZCL_CLUSTER_ID_GEN_BASIC:
// 1340       stat = zclGeneral_ProcessInBasic( pInMsg, pCBs );
??zclGeneral_HdlInSpecificCommands_2:
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x8
        JNZ     ??zclGeneral_HdlInSpecificCommands_6
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        JNZ     ??zclGeneral_HdlInSpecificCommands_5
        MOV     DPL,R4
        MOV     DPH,R5
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_10:
        MOV     A,DPL
        ORL     A,DPH
        JZ      ??zclGeneral_HdlInSpecificCommands_6
        ; Setup parameters for indirect call
        SJMP    ??zclGeneral_HdlInSpecificCommands_7
??zclGeneral_HdlInSpecificCommands_1:
        SJMP    ??zclGeneral_HdlInSpecificCommands_5
// 1341       break;
// 1342 #endif // ZCL_BASIC
// 1343 
// 1344 #ifdef ZCL_IDENTIFY
// 1345     case ZCL_CLUSTER_ID_GEN_IDENTIFY:
// 1346       stat = zclGeneral_ProcessInIdentity( pInMsg, pCBs );
??zclGeneral_HdlInSpecificCommands_3:
        ; Setup parameters for call to function zclGeneral_ProcessInIdentity
        LCALL   ??zclGeneral_ProcessInIdentity?relay
// 1347       break;
        SJMP    ??zclGeneral_HdlInSpecificCommands_8
// 1348 #endif // ZCL_IDENTIFY
// 1349 
// 1350 #ifdef ZCL_GROUPS
// 1351     case ZCL_CLUSTER_ID_GEN_GROUPS:
// 1352       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1353         stat = zclGeneral_ProcessInGroupsServer( pInMsg );
// 1354       else
// 1355         stat = zclGeneral_ProcessInGroupsClient( pInMsg, pCBs );
// 1356       break;
// 1357 #endif // ZCL_GROUPS
// 1358 
// 1359 #ifdef ZCL_SCENES
// 1360     case ZCL_CLUSTER_ID_GEN_SCENES:
// 1361       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1362         stat = zclGeneral_ProcessInScenesServer( pInMsg, pCBs );
// 1363       else
// 1364         stat = zclGeneral_ProcessInScenesClient( pInMsg, pCBs );
// 1365       break;
// 1366 #endif // ZCL_SCENES
// 1367 
// 1368 #ifdef ZCL_ON_OFF
// 1369     case ZCL_CLUSTER_ID_GEN_ON_OFF:
// 1370       stat = zclGeneral_ProcessInOnOff( pInMsg, pCBs );
??zclGeneral_HdlInSpecificCommands_4:
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x8
        JNZ     ??zclGeneral_HdlInSpecificCommands_6
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        LCALL   ?Subroutine4 & 0xFFFF
??CrossCallReturnLabel_4:
        JZ      ??zclGeneral_HdlInSpecificCommands_6
        ; Setup parameters for indirect call
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R4
        MOV     DPH,R5
??zclGeneral_HdlInSpecificCommands_7:
        LCALL   ?CALL_IND
??zclGeneral_HdlInSpecificCommands_6:
        MOV     R1,#0x0
// 1371       break;
        SJMP    ??zclGeneral_HdlInSpecificCommands_8
// 1372 #endif // ZCL_ON_OFF
// 1373 
// 1374 #ifdef ZCL_LEVEL_CTRL
// 1375     case ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL:
// 1376       stat = zclGeneral_ProcessInLevelControl( pInMsg, pCBs );
// 1377       break;
// 1378 #endif // ZCL_LEVEL_CTRL
// 1379 
// 1380 #ifdef ZCL_ALARMS
// 1381     case ZCL_CLUSTER_ID_GEN_ALARMS:
// 1382       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1383         stat = zclGeneral_ProcessInAlarmsServer( pInMsg, pCBs );
// 1384       else
// 1385         stat = zclGeneral_ProcessInAlarmsClient( pInMsg, pCBs );
// 1386       break;
// 1387 #endif // ZCL_ALARMS
// 1388 
// 1389 #ifdef ZCL_LOCATION
// 1390     case ZCL_CLUSTER_ID_GEN_LOCATION:
// 1391       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1392         stat = zclGeneral_ProcessInLocationServer( pInMsg, pCBs );
// 1393       else
// 1394         stat = zclGeneral_ProcessInLocationClient( pInMsg, pCBs );
// 1395       break;
// 1396 #endif // ZCL_LOCATION
// 1397 
// 1398     case ZCL_CLUSTER_ID_GEN_POWER_CFG:
// 1399     case ZCL_CLUSTER_ID_GEN_DEVICE_TEMP_CONFIG:
// 1400     case ZCL_CLUSTER_ID_GEN_ON_OFF_SWITCH_CONFIG:
// 1401     case ZCL_CLUSTER_ID_GEN_TIME:
// 1402     default:
// 1403       stat = ZFailure;
??zclGeneral_HdlInSpecificCommands_5:
        MOV     R1,#0x1
// 1404       break;
// 1405   }
// 1406 
// 1407   return ( stat );
??zclGeneral_HdlInSpecificCommands_8:
        LJMP    ??Subroutine10_0 & 0xFFFF
        CFI EndBlock cfiBlock13
// 1408 }
// 1409 
// 1410 #ifdef ZCL_BASIC
// 1411 /*********************************************************************
// 1412  * @fn      zclGeneral_ProcessInBasic
// 1413  *
// 1414  * @brief   Process in the received Basic Command.
// 1415  *
// 1416  * @param   pInMsg - pointer to the incoming message
// 1417  *
// 1418  * @return  ZStatus_t
// 1419  */
// 1420 static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg,
// 1421                                             zclGeneral_AppCallbacks_t *pCBs )
// 1422 {
// 1423   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1424   {
// 1425     if ( pInMsg->hdr.commandID > COMMAND_BASIC_RESET_FACT_DEFAULT )
// 1426       return ( ZFailure );   // Error ignore the command
// 1427 
// 1428     if ( pCBs->pfnBasicReset )
// 1429       pCBs->pfnBasicReset();
// 1430   }
// 1431   // no Client command
// 1432 
// 1433   return ( ZSuccess );
// 1434 }
// 1435 #endif // ZCL_BASIC
// 1436 
// 1437 #ifdef ZCL_IDENTIFY
// 1438 /*********************************************************************
// 1439  * @fn      zclGeneral_ProcessInIdentity
// 1440  *
// 1441  * @brief   Process in the received Identity Command.
// 1442  *
// 1443  * @param   pInMsg - pointer to the incoming message
// 1444  *
// 1445  * @return  ZStatus_t
// 1446  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1447 static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg,
zclGeneral_ProcessInIdentity:
        CFI Block cfiBlock14 Using cfiCommon0
        CFI Function zclGeneral_ProcessInIdentity
        CODE
// 1448                                                zclGeneral_AppCallbacks_t *pCBs )
// 1449 {
        FUNCALL zclGeneral_ProcessInIdentity, zclFindAttrRec
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclGeneral_ProcessInIdentity, zclReadAttrData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclGeneral_ProcessInIdentity, zclGeneral_SendIdentifyQueryResponse
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 14
        MOV     A,#-0xe
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 26)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
// 1450   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPL,?V0 + 0
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x8
        JZ      $+5
        LJMP    ??zclGeneral_ProcessInIdentity_0 & 0xFFFF
// 1451   {
// 1452     if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY )
        MOV     A,R2
        CLR     C
        SUBB    A,#0x2
        JC      ??zclGeneral_ProcessInIdentity_1
// 1453       return ( ZFailure );   // Error ignore the command
??zclGeneral_ProcessInIdentity_2:
        MOV     R1,#0x1
        LJMP    ??zclGeneral_ProcessInIdentity_3 & 0xFFFF
// 1454 
// 1455     if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY )
??zclGeneral_ProcessInIdentity_1:
        MOV     A,R2
        JNZ     ??zclGeneral_ProcessInIdentity_4
// 1456     {
// 1457       if ( pCBs->pfnIdentify )
        MOV     DPL,R4
        MOV     DPH,R5
        LJMP    ??zclGeneral_ProcessInIdentity_5 & 0xFFFF
// 1458       {
// 1459         zclIdentify_t cmd;
// 1460 
// 1461         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 1462         cmd.identifyTime = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
// 1463 
// 1464         pCBs->pfnIdentify( &cmd );
// 1465       }
// 1466     }
// 1467     else
// 1468     {
// 1469       zclAttrRec_t attrRec;
// 1470       uint16 identifyTime = 0;
??zclGeneral_ProcessInIdentity_4:
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
// 1471 
// 1472       // Retrieve Identify Time
// 1473       if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, ATTRID_IDENTIFY_TIME, &attrRec ) )
        MOV     DPL,?V0 + 0
        LCALL   ?Subroutine6 & 0xFFFF
??CrossCallReturnLabel_9:
        ; Setup parameters for call to function zclFindAttrRec
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 2,DPL
        MOV     ?V0 + 3,DPH
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 28)
        MOV     R4,#0x0
        MOV     R5,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        LCALL   ?Subroutine5 & 0xFFFF
??CrossCallReturnLabel_6:
        LCALL   ??zclFindAttrRec?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 26)
        MOV     A,R1
        JZ      ??zclGeneral_ProcessInIdentity_6
// 1474         zclReadAttrData( (uint8 *)&identifyTime, &attrRec, NULL );
        ; Setup parameters for call to function zclReadAttrData
        CLR     A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??zclReadAttrData?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 26)
// 1475 
// 1476       // Is device identifying itself?
// 1477       if ( identifyTime > 0 )
??zclGeneral_ProcessInIdentity_6:
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine8 & 0xFFFF
??CrossCallReturnLabel_13:
        ORL     A,R1
        JZ      ??zclGeneral_ProcessInIdentity_7
// 1478       {
// 1479         zclGeneral_SendIdentifyQueryResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1480                                               identifyTime, true, pInMsg->hdr.transSeqNum );
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
        ; Setup parameters for call to function zclGeneral_SendIdentifyQueryResponse
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 27)
        MOV     ?V0 + 0,#0x1
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
        CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R6
        ADD     A,#0x6
        MOV     R2,A
        MOV     A,R7
        ADDC    A,#0x0
        LCALL   ?Subroutine5 & 0xFFFF
// 1481       }
??CrossCallReturnLabel_7:
        LCALL   ??zclGeneral_SendIdentifyQueryResponse?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 26)
// 1482 
// 1483       return ( ZCL_STATUS_CMD_HAS_RSP );
??zclGeneral_ProcessInIdentity_7:
        MOV     R1,#-0x1
        SJMP    ??zclGeneral_ProcessInIdentity_3
// 1484     }
// 1485   }
// 1486   else // Client Command
// 1487   {
// 1488     if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY_RSP )
??zclGeneral_ProcessInIdentity_0:
        MOV     A,R2
        JZ      $+5
        LJMP    ??zclGeneral_ProcessInIdentity_2 & 0xFFFF
// 1489       return ( ZFailure );   // Error ignore the command
// 1490 
// 1491     if ( pCBs->pfnIdentifyQueryRsp )
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
??zclGeneral_ProcessInIdentity_5:
        LCALL   ?Subroutine4 & 0xFFFF
??CrossCallReturnLabel_5:
        JZ      ??zclGeneral_ProcessInIdentity_8
// 1492     {
// 1493       zclIdentifyQueryRsp_t rsp;
// 1494 
// 1495       rsp.srcAddr = &(pInMsg->msg->srcAddr);
        MOV     DPL,?V0 + 0
        MOV     DPH,R3
        MOVX    A,@DPTR
        ADD     A,#0x6
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1496       rsp.timeout = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
        MOV     DPL,?V0 + 0
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        LCALL   ?Subroutine7 & 0xFFFF
??CrossCallReturnLabel_11:
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R2
        MOV     R0,A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1497 
// 1498       pCBs->pfnIdentifyQueryRsp( &rsp );
        ; Setup parameters for indirect call
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        MOV     DPL,R4
        MOV     DPH,R5
        LCALL   ?CALL_IND
// 1499     }
// 1500   }
// 1501 
// 1502   return ( ZSuccess );
??zclGeneral_ProcessInIdentity_8:
        MOV     R1,#0x0
??zclGeneral_ProcessInIdentity_3:
        MOV     A,#0xe
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 12)
        LJMP    ?Subroutine0 & 0xFFFF
        CFI EndBlock cfiBlock14
// 1503 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine7:
        CFI Block cfiCond15 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_10
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond16 Using cfiCommon0
        CFI (cfiCond16) NoFunction
        CFI (cfiCond16) Conditional ??CrossCallReturnLabel_11
        CFI (cfiCond16) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond16) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond16) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond16) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond16) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond16) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond16) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond16) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond16) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond16) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond16) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond16) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond16) CFA_SP SP+0
        CFI (cfiCond16) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiPicker17 Using cfiCommon1
        CFI (cfiPicker17) NoFunction
        CFI (cfiPicker17) Picker
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        RET
        CFI EndBlock cfiCond15
        CFI EndBlock cfiCond16
        CFI EndBlock cfiPicker17

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine6:
        CFI Block cfiCond18 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_8
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond19 Using cfiCommon0
        CFI (cfiCond19) NoFunction
        CFI (cfiCond19) Conditional ??CrossCallReturnLabel_9
        CFI (cfiCond19) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond19) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond19) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond19) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond19) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond19) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond19) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond19) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond19) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond19) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond19) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond19) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond19) CFA_SP SP+0
        CFI (cfiCond19) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiPicker20 Using cfiCommon1
        CFI (cfiPicker20) NoFunction
        CFI (cfiPicker20) Picker
        MOV     DPH,R3
        LCALL   ?Subroutine8 & 0xFFFF
??CrossCallReturnLabel_15:
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
        RET
        CFI EndBlock cfiCond18
        CFI EndBlock cfiCond19
        CFI EndBlock cfiPicker20

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine8:
        CFI Block cfiCond21 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_12
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond22 Using cfiCommon0
        CFI (cfiCond22) NoFunction
        CFI (cfiCond22) Conditional ??CrossCallReturnLabel_13
        CFI (cfiCond22) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond22) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond22) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond22) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond22) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond22) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond22) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond22) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond22) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond22) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond22) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond22) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond22) CFA_SP SP+0
        CFI (cfiCond22) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiCond23 Using cfiCommon0
        CFI (cfiCond23) NoFunction
        CFI (cfiCond23) Conditional ??CrossCallReturnLabel_15, ??CrossCallReturnLabel_8
        CFI (cfiCond23) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond23) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond23) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond23) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond23) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond23) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond23) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond23) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond23) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond23) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond23) CFA_SP SP+0
        CFI (cfiCond23) CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond24 Using cfiCommon0
        CFI (cfiCond24) NoFunction
        CFI (cfiCond24) Conditional ??CrossCallReturnLabel_15, ??CrossCallReturnLabel_9
        CFI (cfiCond24) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond24) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond24) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond24) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond24) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond24) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond24) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond24) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond24) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond24) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond24) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond24) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond24) CFA_SP SP+0
        CFI (cfiCond24) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiCond25 Using cfiCommon0
        CFI (cfiCond25) NoFunction
        CFI (cfiCond25) Conditional ??CrossCallReturnLabel_14, ??CrossCallReturnLabel_4
        CFI (cfiCond25) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond25) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond25) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond25) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond25) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond25) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond25) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond25) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond25) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond25) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond25) CFA_SP SP+0
        CFI (cfiCond25) CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond26 Using cfiCommon0
        CFI (cfiCond26) NoFunction
        CFI (cfiCond26) Conditional ??CrossCallReturnLabel_14, ??CrossCallReturnLabel_5
        CFI (cfiCond26) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond26) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond26) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond26) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond26) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond26) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond26) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond26) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond26) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond26) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond26) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond26) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond26) CFA_SP SP+0
        CFI (cfiCond26) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiPicker27 Using cfiCommon1
        CFI (cfiPicker27) NoFunction
        CFI (cfiPicker27) Picker
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        RET
        CFI EndBlock cfiCond21
        CFI EndBlock cfiCond22
        CFI EndBlock cfiCond23
        CFI EndBlock cfiCond24
        CFI EndBlock cfiCond25
        CFI EndBlock cfiCond26
        CFI EndBlock cfiPicker27

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine5:
        CFI Block cfiCond28 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_6
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 28)
        CFI Block cfiCond29 Using cfiCommon0
        CFI (cfiCond29) NoFunction
        CFI (cfiCond29) Conditional ??CrossCallReturnLabel_7
        CFI (cfiCond29) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond29) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond29) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond29) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond29) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond29) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond29) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond29) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond29) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond29) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond29) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond29) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond29) CFA_SP SP+0
        CFI (cfiCond29) CFA_XSP16 add(XSP16, 28)
        CFI Block cfiPicker30 Using cfiCommon1
        CFI (cfiPicker30) NoFunction
        CFI (cfiPicker30) Picker
        MOV     R3,A
        LCALL   ?Subroutine9 & 0xFFFF
??CrossCallReturnLabel_17:
        MOV     R1,A
        RET
        CFI EndBlock cfiCond28
        CFI EndBlock cfiCond29
        CFI EndBlock cfiPicker30

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine9:
        CFI Block cfiCond31 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_16
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond32 Using cfiCommon0
        CFI (cfiCond32) NoFunction
        CFI (cfiCond32) Conditional ??CrossCallReturnLabel_17, ??CrossCallReturnLabel_6
        CFI (cfiCond32) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond32) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond32) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond32) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond32) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond32) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond32) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond32) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond32) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond32) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond32) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond32) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond32) CFA_SP SP+0
        CFI (cfiCond32) CFA_XSP16 add(XSP16, 28)
        CFI Block cfiCond33 Using cfiCommon0
        CFI (cfiCond33) NoFunction
        CFI (cfiCond33) Conditional ??CrossCallReturnLabel_17, ??CrossCallReturnLabel_7
        CFI (cfiCond33) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond33) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond33) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond33) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond33) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond33) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond33) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond33) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond33) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond33) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond33) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond33) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond33) CFA_SP SP+0
        CFI (cfiCond33) CFA_XSP16 add(XSP16, 28)
        CFI Block cfiPicker34 Using cfiCommon1
        CFI (cfiPicker34) NoFunction
        CFI (cfiPicker34) Picker
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        RET
        CFI EndBlock cfiCond31
        CFI EndBlock cfiCond32
        CFI EndBlock cfiCond33
        CFI EndBlock cfiPicker34

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine4:
        CFI Block cfiCond35 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_4
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond36 Using cfiCommon0
        CFI (cfiCond36) NoFunction
        CFI (cfiCond36) Conditional ??CrossCallReturnLabel_5
        CFI (cfiCond36) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond36) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond36) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond36) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond36) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond36) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond36) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond36) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond36) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond36) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond36) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond36) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond36) CFA_SP SP+0
        CFI (cfiCond36) CFA_XSP16 add(XSP16, 26)
        CFI Block cfiPicker37 Using cfiCommon1
        CFI (cfiPicker37) NoFunction
        CFI (cfiPicker37) Picker
        INC     DPTR
        INC     DPTR
        LCALL   ?Subroutine8 & 0xFFFF
??CrossCallReturnLabel_14:
        MOV     R4,A
        MOV     A,R1
        MOV     R5,A
        MOV     A,R4
        ORL     A,R5
        RET
        CFI EndBlock cfiCond35
        CFI EndBlock cfiCond36
        CFI EndBlock cfiPicker37

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_RegisterCmdCallbacks?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_RegisterCmdCallbacks

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_SendIdentify?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_SendIdentify

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_SendIdentifyQueryResponse?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_SendIdentifyQueryResponse

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_HdlIncoming?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_HdlIncoming

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_HdlInSpecificCommands?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_HdlInSpecificCommands

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGeneral_ProcessInIdentity?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    zclGeneral_ProcessInIdentity

        END
// 1504 #endif // ZCL_IDENTIFY
// 1505 
// 1506 #ifdef ZCL_GROUPS
// 1507 
// 1508 /*********************************************************************
// 1509  * @fn      zclGeneral_AddGroup
// 1510  *
// 1511  * @brief   Add a Group.
// 1512  *
// 1513  * @param   endPoint - application endpoint
// 1514  * @param   group - group to be added
// 1515  * @param   pData - pointer to the group info
// 1516  *
// 1517  * @return  ZStatus_t
// 1518  */
// 1519 static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData )
// 1520 {
// 1521   zclAttrRec_t attrRec;
// 1522   uint8 nameLen;
// 1523   uint8 nameSupport = FALSE;
// 1524 
// 1525   pData += 2;   // Move past group ID
// 1526   nameLen = *pData++;
// 1527 
// 1528   // Retrieve Name Support attribute
// 1529   if ( zclFindAttrRec( endPoint, ZCL_CLUSTER_ID_GEN_GROUPS, ATTRID_GROUP_NAME_SUPPORT, &attrRec ) )
// 1530      zclReadAttrData( &nameSupport, &attrRec, NULL );
// 1531 
// 1532   if ( nameSupport )
// 1533   {
// 1534     if ( nameLen > (APS_GROUP_NAME_LEN-1) )
// 1535        nameLen = (APS_GROUP_NAME_LEN-1);
// 1536     group->name[0] = nameLen;
// 1537     osal_memcpy( &(group->name[1]), pData, nameLen );
// 1538   }
// 1539 
// 1540   return ( aps_AddGroup( endPoint, group ) );
// 1541 }
// 1542 
// 1543 /*********************************************************************
// 1544  * @fn      zclGeneral_ProcessInGroupsServer
// 1545  *
// 1546  * @brief   Process in the received Groups Command.
// 1547  *
// 1548  * @param   pInMsg - pointer to the incoming message
// 1549  *
// 1550  * @return  ZStatus_t
// 1551  */
// 1552 static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg )
// 1553 {
// 1554   zclAttrRec_t attrRec;
// 1555   aps_Group_t group;
// 1556   aps_Group_t *pGroup;
// 1557   uint8 *pData;
// 1558   uint8 status;
// 1559   uint8 grpCnt;
// 1560   uint8 grpRspCnt = 0;
// 1561   uint16 *grpList;
// 1562   uint16 identifyTime = 0;
// 1563   uint8 i;
// 1564   ZStatus_t stat = ZSuccess;
// 1565 
// 1566   osal_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
// 1567 
// 1568   pData = pInMsg->pData;
// 1569   group.ID = BUILD_UINT16( pData[0], pData[1] );
// 1570   switch ( pInMsg->hdr.commandID )
// 1571   {
// 1572     case COMMAND_GROUP_ADD:
// 1573       status = zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
// 1574       if ( status != ZSuccess )
// 1575       {
// 1576         if ( status == ZApsDuplicateEntry )
// 1577           status = ZCL_STATUS_DUPLICATE_EXISTS;
// 1578         else
// 1579           status = ZCL_STATUS_INSUFFICIENT_SPACE;
// 1580       }
// 1581 
// 1582       zclGeneral_SendGroupAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1583                                        status, group.ID, true, pInMsg->hdr.transSeqNum );
// 1584       stat = ZCL_STATUS_CMD_HAS_RSP;
// 1585       break;
// 1586 
// 1587     case COMMAND_GROUP_VIEW:
// 1588       pGroup = aps_FindGroup( pInMsg->msg->endPoint, group.ID );
// 1589       if ( pGroup )
// 1590       {
// 1591         status = ZCL_STATUS_SUCCESS;
// 1592       }
// 1593       else
// 1594       {
// 1595         // Group not found
// 1596         status = ZCL_STATUS_NOT_FOUND;
// 1597         pGroup = &group;
// 1598       }
// 1599       zclGeneral_SendGroupViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1600                                         status, pGroup, true, pInMsg->hdr.transSeqNum );
// 1601       stat = ZCL_STATUS_CMD_HAS_RSP;
// 1602       break;
// 1603 
// 1604     case COMMAND_GROUP_GET_MEMBERSHIP:
// 1605       grpCnt = *pData++;
// 1606 
// 1607       // Allocate space for the group list
// 1608       grpList = osal_mem_alloc( sizeof( uint16 ) * APS_MAX_GROUPS );
// 1609       if ( grpList != NULL )
// 1610       {
// 1611         if ( grpCnt == 0 )
// 1612         {
// 1613           // Find out all the groups of which the endpoint is a member.
// 1614           grpRspCnt = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, grpList );
// 1615         }
// 1616         else
// 1617         {
// 1618           // Find out the groups (in the list) of which the endpoint is a member.
// 1619           for ( i = 0; i < grpCnt; i++ )
// 1620           {
// 1621             group.ID = BUILD_UINT16( pData[0], pData[1] );
// 1622             pData += 2;
// 1623 
// 1624             if ( aps_FindGroup( pInMsg->msg->endPoint, group.ID ) )
// 1625               grpList[grpRspCnt++] = group.ID;
// 1626           }
// 1627         }
// 1628 
// 1629         if ( grpCnt == 0 ||  grpRspCnt != 0 )
// 1630         {
// 1631           zclGeneral_SendGroupGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1632                                                      aps_GroupsRemaingCapacity(), grpRspCnt,
// 1633                                                      grpList, true, pInMsg->hdr.transSeqNum );
// 1634         }
// 1635 
// 1636         osal_mem_free( grpList );
// 1637       }
// 1638       else
// 1639       {
// 1640         // Couldn't allocate space for the group list -- send a Default Response command back.
// 1641         zclDefaultRspCmd_t defaultRspCmd;
// 1642 
// 1643         defaultRspCmd.commandID = pInMsg->hdr.commandID;
// 1644         defaultRspCmd.statusCode = ZCL_STATUS_INSUFFICIENT_SPACE;
// 1645         zcl_SendDefaultRspCmd( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 1646                                pInMsg->msg->clusterId, &defaultRspCmd,
// 1647                                ZCL_FRAME_SERVER_CLIENT_DIR, true, 0, pInMsg->hdr.transSeqNum );
// 1648       }
// 1649 
// 1650       stat = ZCL_STATUS_CMD_HAS_RSP;
// 1651       break;
// 1652 
// 1653     case COMMAND_GROUP_REMOVE:
// 1654       if ( aps_RemoveGroup( pInMsg->msg->endPoint, group.ID ) )
// 1655         status = ZCL_STATUS_SUCCESS;
// 1656       else
// 1657         status = ZCL_STATUS_NOT_FOUND;
// 1658       zclGeneral_SendGroupRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1659                                           status, group.ID, true, pInMsg->hdr.transSeqNum );
// 1660       stat = ZCL_STATUS_CMD_HAS_RSP;
// 1661       break;
// 1662 
// 1663     case COMMAND_GROUP_REMOVE_ALL:
// 1664       aps_RemoveAllGroup( pInMsg->msg->endPoint );
// 1665       break;
// 1666 
// 1667     case COMMAND_GROUP_ADD_IF_IDENTIFYING:
// 1668       // Retrieve Identify Time
// 1669       if ( zclFindAttrRec( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY, ATTRID_IDENTIFY_TIME, &attrRec ) )
// 1670         zclReadAttrData( (uint8 *)&identifyTime, &attrRec, NULL );
// 1671 
// 1672       // Is device identifying itself?
// 1673       if ( identifyTime > 0 )
// 1674         zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
// 1675       break;
// 1676 
// 1677     default:
// 1678       stat = ZFailure;
// 1679       break;
// 1680   }
// 1681 
// 1682   return ( stat );
// 1683 }
// 1684 
// 1685 /*********************************************************************
// 1686  * @fn      zclGeneral_ProcessInGroupsClient
// 1687  *
// 1688  * @brief   Process in the received Groups Command.
// 1689  *
// 1690  * @param   pInMsg - pointer to the incoming message
// 1691  *
// 1692  * @return  ZStatus_t
// 1693  */
// 1694 static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg,
// 1695                                                    zclGeneral_AppCallbacks_t *pCBs )
// 1696 {
// 1697   aps_Group_t group;
// 1698   uint8 *pData = pInMsg->pData;
// 1699   uint8 grpCnt;
// 1700   uint8 nameLen;
// 1701   zclGroupRsp_t rsp;
// 1702   uint8 i;
// 1703   ZStatus_t stat = ZSuccess;
// 1704 
// 1705   osal_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
// 1706   osal_memset( (uint8*)&rsp, 0, sizeof( zclGroupRsp_t ) );
// 1707 
// 1708   switch ( pInMsg->hdr.commandID )
// 1709   {
// 1710     case COMMAND_GROUP_ADD_RSP:
// 1711     case COMMAND_GROUP_VIEW_RSP:
// 1712     case COMMAND_GROUP_REMOVE_RSP:
// 1713       rsp.status = *pData++;
// 1714       group.ID = BUILD_UINT16( pData[0], pData[1] );
// 1715 
// 1716       if ( rsp.status == ZCL_STATUS_SUCCESS && pInMsg->hdr.commandID == COMMAND_GROUP_VIEW_RSP )
// 1717       {
// 1718         pData += 2;   // Move past ID
// 1719         nameLen = *pData++;
// 1720         if ( nameLen > (APS_GROUP_NAME_LEN-1) )
// 1721           nameLen = (APS_GROUP_NAME_LEN-1);
// 1722         group.name[0] = nameLen;
// 1723         osal_memcpy( &(group.name[1]), pData, nameLen );
// 1724         rsp.grpName = group.name;
// 1725       }
// 1726 
// 1727       if ( pCBs->pfnGroupRsp )
// 1728       {
// 1729         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 1730         rsp.cmdID = pInMsg->hdr.commandID;
// 1731         rsp.grpCnt = 1;
// 1732         rsp.grpList = &group.ID;
// 1733         rsp.capacity = 0;
// 1734 
// 1735         pCBs->pfnGroupRsp( &rsp );
// 1736       }
// 1737       break;
// 1738 
// 1739     case COMMAND_GROUP_GET_MEMBERSHIP_RSP:
// 1740       {
// 1741         uint16 *grpList = NULL;
// 1742         rsp.capacity = *pData++;
// 1743         grpCnt = *pData++;
// 1744 
// 1745         if ( grpCnt > 0 )
// 1746         {
// 1747           // Allocate space for the group list
// 1748           grpList = osal_mem_alloc( sizeof( uint16 ) * grpCnt );
// 1749           if ( grpList != NULL )
// 1750           {
// 1751             rsp.grpCnt = grpCnt;
// 1752             for ( i = 0; i < grpCnt; i++ )
// 1753             {
// 1754               grpList[i] = BUILD_UINT16( pData[0], pData[1] );
// 1755               pData += 2;
// 1756             }
// 1757           }
// 1758         }
// 1759 
// 1760         if ( pCBs->pfnGroupRsp )
// 1761         {
// 1762           rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 1763           rsp.cmdID = pInMsg->hdr.commandID;
// 1764           rsp.grpList = grpList;
// 1765 
// 1766           pCBs->pfnGroupRsp( &rsp );
// 1767         }
// 1768 
// 1769         if ( grpList != NULL )
// 1770         {
// 1771           osal_mem_free( grpList );
// 1772         }
// 1773       }
// 1774       break;
// 1775 
// 1776     default:
// 1777       stat = ZFailure;
// 1778       break;
// 1779   }
// 1780 
// 1781   return ( stat );
// 1782 }
// 1783 #endif // ZCL_GROUPS
// 1784 
// 1785 #ifdef ZCL_SCENES
// 1786 /*********************************************************************
// 1787  * @fn      zclGeneral_AddScene
// 1788  *
// 1789  * @brief   Add a scene for an endpoint
// 1790  *
// 1791  * @param   endpoint -
// 1792  * @param   scene - new scene item
// 1793  *
// 1794  * @return  ZStatus_t
// 1795  */
// 1796 ZStatus_t zclGeneral_AddScene( uint8 endpoint, zclGeneral_Scene_t *scene )
// 1797 {
// 1798   zclGenSceneItem_t *pNewItem;
// 1799   zclGenSceneItem_t *pLoop;
// 1800 
// 1801   // Fill in the new profile list
// 1802   pNewItem = osal_mem_alloc( sizeof( zclGenSceneItem_t ) );
// 1803   if ( pNewItem == NULL )
// 1804     return ( ZMemError );
// 1805 
// 1806   // Fill in the plugin record.
// 1807   pNewItem->next = (zclGenSceneItem_t *)NULL;
// 1808   pNewItem->endpoint = endpoint;
// 1809   osal_memcpy( (uint8*)&(pNewItem->scene), (uint8*)scene, sizeof ( zclGeneral_Scene_t ));
// 1810 
// 1811   // Find spot in list
// 1812   if (  zclGenSceneTable == NULL )
// 1813   {
// 1814     zclGenSceneTable = pNewItem;
// 1815   }
// 1816   else
// 1817   {
// 1818     // Look for end of list
// 1819     pLoop = zclGenSceneTable;
// 1820     while ( pLoop->next != NULL )
// 1821       pLoop = pLoop->next;
// 1822 
// 1823     // Put new item at end of list
// 1824     pLoop->next = pNewItem;
// 1825   }
// 1826 
// 1827   // Update NV
// 1828   zclGeneral_ScenesWriteNV();
// 1829 
// 1830   return ( ZSuccess );
// 1831 }
// 1832 
// 1833 /*********************************************************************
// 1834  * @fn      zclGeneral_FindScene
// 1835  *
// 1836  * @brief   Find a scene with endpoint and sceneID
// 1837  *
// 1838  * @param   endpoint -
// 1839  * @param   groupID - what group the scene belongs to
// 1840  * @param   sceneID - ID to look for scene
// 1841  *
// 1842  * @return  a pointer to the scene information, NULL if not found
// 1843  */
// 1844 zclGeneral_Scene_t *zclGeneral_FindScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
// 1845 {
// 1846   zclGenSceneItem_t *pLoop;
// 1847 
// 1848   // Look for end of list
// 1849   pLoop = zclGenSceneTable;
// 1850   while ( pLoop )
// 1851   {
// 1852     if ( (pLoop->endpoint == endpoint || endpoint == 0xFF)
// 1853         && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
// 1854     {
// 1855       return ( &(pLoop->scene) );
// 1856     }
// 1857     pLoop = pLoop->next;
// 1858   }
// 1859 
// 1860   return ( (zclGeneral_Scene_t *)NULL );
// 1861 }
// 1862 
// 1863 /*********************************************************************
// 1864  * @fn      aps_FindAllScensForGroup
// 1865  *
// 1866  * @brief   Find all the scenes with groupID
// 1867  *
// 1868  * @param   endpoint - endpoint to look for
// 1869  * @param   sceneList - List to hold scene IDs (should hold APS_MAX_SCENES entries)
// 1870  *
// 1871  * @return  number of scenes copied to sceneList
// 1872  */
// 1873 uint8 zclGeneral_FindAllScenesForGroup( uint8 endpoint, uint16 groupID, uint8 *sceneList )
// 1874 {
// 1875   zclGenSceneItem_t *pLoop;
// 1876   uint8 cnt = 0;
// 1877 
// 1878   // Look for end of list
// 1879   pLoop = zclGenSceneTable;
// 1880   while ( pLoop )
// 1881   {
// 1882     if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
// 1883       sceneList[cnt++] = pLoop->scene.ID;
// 1884     pLoop = pLoop->next;
// 1885   }
// 1886   return ( cnt );
// 1887 }
// 1888 
// 1889 /*********************************************************************
// 1890  * @fn      zclGeneral_RemoveScene
// 1891  *
// 1892  * @brief   Remove a scene with endpoint and sceneID
// 1893  *
// 1894  * @param   endpoint -
// 1895  * @param   groupID - what group the scene belongs to
// 1896  * @param   sceneID - ID to look for scene
// 1897  *
// 1898  * @return  TRUE if removed, FALSE if not found
// 1899  */
// 1900 uint8 zclGeneral_RemoveScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
// 1901 {
// 1902   zclGenSceneItem_t *pLoop;
// 1903   zclGenSceneItem_t *pPrev;
// 1904 
// 1905   // Look for end of list
// 1906   pLoop = zclGenSceneTable;
// 1907   pPrev = NULL;
// 1908   while ( pLoop )
// 1909   {
// 1910     if ( pLoop->endpoint == endpoint
// 1911         && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
// 1912     {
// 1913       if ( pPrev == NULL )
// 1914         zclGenSceneTable = pLoop->next;
// 1915       else
// 1916         pPrev->next = pLoop->next;
// 1917 
// 1918       // Free the memory
// 1919       osal_mem_free( pLoop );
// 1920 
// 1921       // Update NV
// 1922       zclGeneral_ScenesWriteNV();
// 1923 
// 1924       return ( TRUE );
// 1925     }
// 1926     pPrev = pLoop;
// 1927     pLoop = pLoop->next;
// 1928   }
// 1929 
// 1930   return ( FALSE );
// 1931 }
// 1932 
// 1933 /*********************************************************************
// 1934  * @fn      zclGeneral_RemoveAllScenes
// 1935  *
// 1936  * @brief   Remove all scenes with endpoint and group Id
// 1937  *
// 1938  * @param   endpoint -
// 1939  * @param   groupID - ID to look for group
// 1940  *
// 1941  * @return  none
// 1942  */
// 1943 void zclGeneral_RemoveAllScenes( uint8 endpoint, uint16 groupID )
// 1944 {
// 1945   zclGenSceneItem_t *pLoop;
// 1946   zclGenSceneItem_t *pPrev;
// 1947   zclGenSceneItem_t *pNext;
// 1948 
// 1949   // Look for end of list
// 1950   pLoop = zclGenSceneTable;
// 1951   pPrev = NULL;
// 1952   while ( pLoop )
// 1953   {
// 1954     if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
// 1955     {
// 1956       if ( pPrev == NULL )
// 1957         zclGenSceneTable = pLoop->next;
// 1958       else
// 1959         pPrev->next = pLoop->next;
// 1960       pNext = pLoop->next;
// 1961 
// 1962       // Free the memory
// 1963       osal_mem_free( pLoop );
// 1964       pLoop = pNext;
// 1965     }
// 1966     else
// 1967     {
// 1968       pPrev = pLoop;
// 1969       pLoop = pLoop->next;
// 1970     }
// 1971   }
// 1972 
// 1973   // Update NV
// 1974   zclGeneral_ScenesWriteNV();
// 1975 }
// 1976 
// 1977 /*********************************************************************
// 1978  * @fn      zclGeneral_CountScenes
// 1979  *
// 1980  * @brief   Count the number of scenes for an endpoint
// 1981  *
// 1982  * @param   endpoint -
// 1983  *
// 1984  * @return  number of scenes assigned to an endpoint
// 1985  */
// 1986 uint8 zclGeneral_CountScenes( uint8 endpoint )
// 1987 {
// 1988   zclGenSceneItem_t *pLoop;
// 1989   uint8 cnt = 0;
// 1990 
// 1991   // Look for end of list
// 1992   pLoop = zclGenSceneTable;
// 1993   while ( pLoop )
// 1994   {
// 1995     if ( pLoop->endpoint == endpoint  )
// 1996       cnt++;
// 1997     pLoop = pLoop->next;
// 1998   }
// 1999   return ( cnt );
// 2000 }
// 2001 
// 2002 /*********************************************************************
// 2003  * @fn      zclGeneral_CountAllScenes
// 2004  *
// 2005  * @brief   Count the total number of scenes
// 2006  *
// 2007  * @param   none
// 2008  *
// 2009  * @return  number of scenes
// 2010  */
// 2011 uint8 zclGeneral_CountAllScenes( void )
// 2012 {
// 2013   zclGenSceneItem_t *pLoop;
// 2014   uint8 cnt = 0;
// 2015 
// 2016   // Look for end of list
// 2017   pLoop = zclGenSceneTable;
// 2018   while ( pLoop )
// 2019   {
// 2020     cnt++;
// 2021     pLoop = pLoop->next;
// 2022   }
// 2023   return ( cnt );
// 2024 }
// 2025 
// 2026 /*********************************************************************
// 2027  * @fn      zclGeneral_ReadSceneCountCB
// 2028  *
// 2029  * @brief   Read the number of scenes currently in the device's
// 2030  *          scene table (i.e., the Scene Count attribute).
// 2031  *
// 2032  *          Note: This function gets called only when the pointer
// 2033  *                'dataPtr' to the Scene Count attribute value is
// 2034  *                NULL in the attribute database registered with
// 2035  *                the ZCL.
// 2036  *
// 2037  * @param   clusterId - cluster that attribute belongs to
// 2038  * @param   attrId - attribute to be read
// 2039  * @param   oper - ZCL_OPER_LEN, ZCL_OPER_READ
// 2040  * @param   pValue - pointer to attribute value
// 2041  * @param   pLen - pointer to length of attribute value read
// 2042  *
// 2043  * @return  status
// 2044  */
// 2045 ZStatus_t zclGeneral_ReadSceneCountCB( uint16 clusterId, uint16 attrId,
// 2046                                        uint8 oper, uint8 *pValue, uint16 *pLen )
// 2047 {
// 2048   ZStatus_t status = ZCL_STATUS_SUCCESS;
// 2049 
// 2050   // This callback function should only be called for the Scene Count attribute
// 2051   switch ( oper )
// 2052   {
// 2053     case ZCL_OPER_LEN:
// 2054       *pLen = 1; // uint8
// 2055       break;
// 2056 
// 2057     case ZCL_OPER_READ:
// 2058       *pValue = zclGeneral_CountAllScenes();
// 2059 
// 2060       if ( pLen != NULL )
// 2061       {
// 2062         *pLen = 1;
// 2063       }
// 2064       break;
// 2065 
// 2066     default:
// 2067       status = ZCL_STATUS_SOFTWARE_FAILURE; // should never get here!
// 2068       break;
// 2069   }
// 2070 
// 2071   return ( status );
// 2072 }
// 2073 
// 2074 /*********************************************************************
// 2075  * @fn      zclGeneral_ProcessInScenesServer
// 2076  *
// 2077  * @brief   Process in the received Scenes Command.
// 2078  *
// 2079  * @param   pInMsg - pointer to the incoming message
// 2080  *
// 2081  * @return  ZStatus_t
// 2082  */
// 2083 static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg,
// 2084                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2085 {
// 2086   zclAttrRec_t attrRec;
// 2087   zclGeneral_Scene_t scene;
// 2088   zclGeneral_Scene_t *pScene;
// 2089   uint8 *pData = pInMsg->pData;
// 2090   uint8 nameLen;
// 2091   uint8 status;
// 2092   uint8 sceneCnt = 0;
// 2093   uint8 *sceneList = NULL;
// 2094   uint8 sendRsp = FALSE;
// 2095   uint8 nameSupport = FALSE;
// 2096   ZStatus_t stat = ZSuccess;
// 2097 
// 2098   osal_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
// 2099 
// 2100   scene.groupID = BUILD_UINT16( pData[0], pData[1] );
// 2101   pData += 2;   // Move past group ID
// 2102   scene.ID = *pData++;
// 2103 
// 2104   switch ( pInMsg->hdr.commandID )
// 2105   {
// 2106     case COMMAND_SCENE_ADD:
// 2107       // Parse the rest of the incoming message
// 2108       scene.transTime = BUILD_UINT16( pData[0], pData[1] );
// 2109       pData += 2;
// 2110       nameLen= *pData++; // Name length
// 2111 
// 2112       // Retrieve Name Support attribute
// 2113       if ( zclFindAttrRec( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_SCENES, ATTRID_SCENES_NAME_SUPPORT, &attrRec ) )
// 2114       {
// 2115         zclReadAttrData( &nameSupport, &attrRec, NULL );
// 2116       }
// 2117 
// 2118       if ( nameSupport )
// 2119       {
// 2120         if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
// 2121         {
// 2122           // truncate to maximum size
// 2123           scene.name[0] = ZCL_GEN_SCENE_NAME_LEN-1;
// 2124         }
// 2125         else
// 2126         {
// 2127           scene.name[0] = nameLen;
// 2128         }
// 2129         osal_memcpy( &(scene.name[1]), pData, scene.name[0] );
// 2130       }
// 2131 
// 2132       pData += nameLen; // move past name, use original length
// 2133 
// 2134       scene.extLen = pInMsg->pDataLen - ( (uint16)( pData - pInMsg->pData ) );
// 2135       if ( scene.extLen > 0 )
// 2136       {
// 2137         // Copy the extention field(s)
// 2138         if ( scene.extLen > ZCL_GEN_SCENE_EXT_LEN )
// 2139         {
// 2140           scene.extLen = ZCL_GEN_SCENE_EXT_LEN;
// 2141         }
// 2142         osal_memcpy( scene.extField, pData, scene.extLen );
// 2143       }
// 2144 
// 2145       if ( scene.groupID == 0x0000 ||
// 2146            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 2147       {
// 2148         // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
// 2149         // does and the corresponding Group exits
// 2150         pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 2151         if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
// 2152         {
// 2153           status = ZCL_STATUS_SUCCESS;
// 2154           if ( pScene != NULL )
// 2155           {
// 2156             // The Scene already exists so update it
// 2157             pScene->transTime = scene.transTime;
// 2158             osal_memcpy( pScene->name, scene.name, ZCL_GEN_SCENE_NAME_LEN );
// 2159 
// 2160             // Use the new extention field(s)
// 2161             osal_memcpy( pScene->extField, scene.extField, scene.extLen );
// 2162             pScene->extLen = scene.extLen;
// 2163 
// 2164             // Update NV
// 2165             zclGeneral_ScenesWriteNV();
// 2166           }
// 2167           else
// 2168           {
// 2169             // The Scene doesn't exist so add it
// 2170             zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
// 2171           }
// 2172         }
// 2173         else
// 2174         {
// 2175           status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
// 2176         }
// 2177       }
// 2178       else
// 2179       {
// 2180         status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
// 2181       }
// 2182 
// 2183       zclGeneral_SendSceneAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2184                                        status, scene.groupID, scene.ID,
// 2185                                        true, pInMsg->hdr.transSeqNum );
// 2186       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2187       break;
// 2188 
// 2189     case COMMAND_SCENE_VIEW:
// 2190       pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 2191       if ( pScene != NULL )
// 2192       {
// 2193         status = ZCL_STATUS_SUCCESS;
// 2194       }
// 2195       else
// 2196       {
// 2197         // Scene not found
// 2198         if ( scene.groupID != 0x0000 &&
// 2199              aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
// 2200         {
// 2201           status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
// 2202         }
// 2203         else
// 2204         {
// 2205           status = ZCL_STATUS_NOT_FOUND;
// 2206         }
// 2207         pScene = &scene;
// 2208       }
// 2209       zclGeneral_SendSceneViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2210                                         status, pScene, true, pInMsg->hdr.transSeqNum );
// 2211       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2212       break;
// 2213 
// 2214     case COMMAND_SCENE_REMOVE:
// 2215       if ( zclGeneral_RemoveScene( pInMsg->msg->endPoint, scene.groupID, scene.ID ) )
// 2216       {
// 2217         status = ZCL_STATUS_SUCCESS;
// 2218       }
// 2219       else
// 2220       {
// 2221         // Scene not found
// 2222         if ( aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
// 2223         {
// 2224           // The Group is not in the Group Table
// 2225           status = ZCL_STATUS_INVALID_FIELD;
// 2226         }
// 2227         else
// 2228         {
// 2229           status = ZCL_STATUS_NOT_FOUND;
// 2230         }
// 2231       }
// 2232 
// 2233       if ( UNICAST_MSG( pInMsg->msg ) )
// 2234       {
// 2235         // Addressed to this device (not to a group) - send a response back
// 2236         zclGeneral_SendSceneRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2237                                             status, scene.groupID,
// 2238                                             scene.ID, true, pInMsg->hdr.transSeqNum );
// 2239       }
// 2240       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2241       break;
// 2242 
// 2243     case COMMAND_SCENE_REMOVE_ALL:
// 2244       if ( scene.groupID == 0x0000 ||
// 2245            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 2246       {
// 2247         zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, scene.groupID );
// 2248         status = ZCL_STATUS_SUCCESS;
// 2249       }
// 2250       else
// 2251       {
// 2252         status = ZCL_STATUS_INVALID_FIELD;
// 2253       }
// 2254 
// 2255       if ( UNICAST_MSG( pInMsg->msg ) )
// 2256       {
// 2257         // Addressed to this device (not to a group) - send a response back
// 2258         zclGeneral_SendSceneRemoveAllResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2259                                                status, scene.groupID, true, pInMsg->hdr.transSeqNum );
// 2260       }
// 2261       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2262       break;
// 2263 
// 2264     case COMMAND_SCENE_STORE:
// 2265       if ( scene.groupID == 0x0000 ||
// 2266            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 2267       {
// 2268         // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
// 2269         // does and the corresponding Group exits
// 2270         pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 2271         if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
// 2272         {
// 2273           uint8 sceneChanged = FALSE;
// 2274 
// 2275           status = ZCL_STATUS_SUCCESS;
// 2276           if ( pScene == NULL )
// 2277           {
// 2278             // Haven't been added yet
// 2279             pScene = &scene;
// 2280           }
// 2281 
// 2282           if ( pCBs->pfnSceneStoreReq )
// 2283           {
// 2284             zclSceneReq_t req;
// 2285 
// 2286             req.srcAddr = &(pInMsg->msg->srcAddr);
// 2287             req.scene = pScene;
// 2288 
// 2289             // Get the latest Scene info
// 2290             if ( pCBs->pfnSceneStoreReq( &req ) )
// 2291             {
// 2292               sceneChanged = TRUE;
// 2293             }
// 2294           }
// 2295 
// 2296           if ( pScene == &scene )
// 2297           {
// 2298             // The Scene doesn't exist so add it
// 2299             zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
// 2300           }
// 2301           else if ( sceneChanged )
// 2302           {
// 2303             // The Scene already exists so update only NV
// 2304             zclGeneral_ScenesWriteNV();
// 2305           }
// 2306         }
// 2307         else
// 2308         {
// 2309           status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
// 2310         }
// 2311       }
// 2312       else
// 2313       {
// 2314         status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
// 2315       }
// 2316 
// 2317       if ( UNICAST_MSG( pInMsg->msg ) )
// 2318       {
// 2319         // Addressed to this device (not to a group) - send a response back
// 2320         zclGeneral_SendSceneStoreResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2321                                            status, scene.groupID, scene.ID,
// 2322                                            true, pInMsg->hdr.transSeqNum );
// 2323       }
// 2324       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2325       break;
// 2326 
// 2327     case COMMAND_SCENE_RECALL:
// 2328       pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 2329       if ( pScene && pCBs->pfnSceneRecallReq )
// 2330       {
// 2331         zclSceneReq_t req;
// 2332 
// 2333         req.srcAddr = &(pInMsg->msg->srcAddr);
// 2334         req.scene = pScene;
// 2335 
// 2336         pCBs->pfnSceneRecallReq( &req );
// 2337       }
// 2338       // No response
// 2339       break;
// 2340 
// 2341     case COMMAND_SCENE_GET_MEMBERSHIP:
// 2342       // Find all the Scenes corresponding to the Group ID
// 2343       if ( scene.groupID == 0x0000 ||
// 2344            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 2345       {
// 2346         // Allocate space for the scene list
// 2347         sceneList = osal_mem_alloc( ZCL_GEN_MAX_SCENES );
// 2348         if ( sceneList != NULL )
// 2349         {
// 2350           sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint,
// 2351                                                        scene.groupID, sceneList );
// 2352           status = ZCL_STATUS_SUCCESS;
// 2353           if ( UNICAST_MSG( pInMsg->msg ) )
// 2354           {
// 2355             // Addressed only to this device - send a response back
// 2356             sendRsp = TRUE;
// 2357           }
// 2358           else
// 2359           {
// 2360             // Addressed to the Group - ONLY send a response if an entry within the
// 2361             // Scene Table corresponds to the Group ID
// 2362             if ( sceneCnt != 0 )
// 2363             {
// 2364               sendRsp = TRUE;
// 2365             }
// 2366           }
// 2367         }
// 2368         else
// 2369         {
// 2370           // Couldn't allocate space for the scene list!
// 2371           status = ZCL_STATUS_INSUFFICIENT_SPACE;
// 2372           sendRsp = TRUE;
// 2373         }
// 2374       }
// 2375       else
// 2376       {
// 2377         // The Group is not in the Group Table - send a response back
// 2378         status = ZCL_STATUS_INVALID_FIELD;
// 2379         sendRsp = TRUE;
// 2380       }
// 2381 
// 2382       if ( sendRsp )
// 2383       {
// 2384         zclGeneral_SendSceneGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2385                                     status, zclGeneral_ScenesRemaingCapacity(), sceneCnt, sceneList,
// 2386                                     scene.groupID, true, pInMsg->hdr.transSeqNum );
// 2387       }
// 2388 
// 2389       if ( sceneList != NULL )
// 2390       {
// 2391         osal_mem_free( sceneList );
// 2392       }
// 2393 
// 2394       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2395       break;
// 2396 
// 2397     default:
// 2398       stat = ZFailure;
// 2399     break;
// 2400   }
// 2401 
// 2402   return ( stat );
// 2403 }
// 2404 
// 2405 /*********************************************************************
// 2406  * @fn      zclGeneral_ProcessInScenesClient
// 2407  *
// 2408  * @brief   Process in the received Scenes Command.
// 2409  *
// 2410  * @param   pInMsg - pointer to the incoming message
// 2411  *
// 2412  * @return  ZStatus_t
// 2413  */
// 2414 static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg,
// 2415                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2416 {
// 2417   zclGeneral_Scene_t scene;
// 2418   uint8 *pData = pInMsg->pData;
// 2419   uint8 nameLen;
// 2420   zclSceneRsp_t rsp;
// 2421   uint8 i;
// 2422   ZStatus_t stat = ZSuccess;
// 2423 
// 2424   osal_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
// 2425   osal_memset( (uint8*)&rsp, 0, sizeof( zclSceneRsp_t ) );
// 2426 
// 2427   // Get the status field first
// 2428   rsp.status = *pData++;
// 2429 
// 2430   if ( pInMsg->hdr.commandID == COMMAND_SCENE_GET_MEMBERSHIP_RSP )
// 2431   {
// 2432     rsp.capacity = *pData++;
// 2433   }
// 2434 
// 2435   scene.groupID = BUILD_UINT16( pData[0], pData[1] );
// 2436   pData += 2;   // Move past group ID
// 2437 
// 2438   switch ( pInMsg->hdr.commandID )
// 2439   {
// 2440     case COMMAND_SCENE_VIEW_RSP:
// 2441       // Parse the rest of the incoming message
// 2442       scene.ID = *pData++; // Not applicable to Remove All Response command
// 2443       scene.transTime = BUILD_UINT16( pData[0], pData[1] );
// 2444       pData += 2;
// 2445       nameLen = *pData++; // Name length
// 2446       if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
// 2447       {
// 2448         // truncate to maximum size
// 2449         scene.name[0] = ZCL_GEN_SCENE_NAME_LEN-1;
// 2450       }
// 2451       else
// 2452       {
// 2453         scene.name[0] = nameLen;
// 2454       }
// 2455       osal_memcpy( &(scene.name[1]), pData, scene.name[0] );
// 2456 
// 2457       pData += nameLen; // move past name, use original length
// 2458 
// 2459       //*** Do something with the extension field(s)
// 2460 
// 2461       // Fall through to callback - break is left off intentionally
// 2462 
// 2463     case COMMAND_SCENE_ADD_RSP:
// 2464     case COMMAND_SCENE_REMOVE_RSP:
// 2465     case COMMAND_SCENE_REMOVE_ALL_RSP:
// 2466     case COMMAND_SCENE_STORE_RSP:
// 2467       if ( pCBs->pfnSceneRsp )
// 2468       {
// 2469         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 2470         rsp.cmdID = pInMsg->hdr.commandID;
// 2471         rsp.scene = &scene;
// 2472 
// 2473         pCBs->pfnSceneRsp( &rsp );
// 2474       }
// 2475       break;
// 2476 
// 2477     case COMMAND_SCENE_GET_MEMBERSHIP_RSP:
// 2478       {
// 2479         uint8 *sceneList = NULL;
// 2480 
// 2481         if ( rsp.status == ZCL_STATUS_SUCCESS )
// 2482         {
// 2483           uint8 sceneCnt = *pData++;
// 2484 
// 2485           if ( sceneCnt > 0 )
// 2486           {
// 2487             // Allocate space for the scene list
// 2488             sceneList = osal_mem_alloc( sceneCnt );
// 2489             if ( sceneList != NULL )
// 2490             {
// 2491               rsp.sceneCnt = sceneCnt;
// 2492               for ( i = 0; i < sceneCnt; i++ )
// 2493                 sceneList[i] = *pData++;
// 2494             }
// 2495           }
// 2496         }
// 2497 
// 2498         if ( pCBs->pfnSceneRsp )
// 2499         {
// 2500           rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 2501           rsp.cmdID = pInMsg->hdr.commandID;
// 2502           rsp.sceneList = sceneList;
// 2503           rsp.scene = &scene;
// 2504 
// 2505           pCBs->pfnSceneRsp( &rsp);
// 2506         }
// 2507 
// 2508         if ( sceneList != NULL )
// 2509         {
// 2510           osal_mem_free( sceneList );
// 2511         }
// 2512       }
// 2513       break;
// 2514 
// 2515     default:
// 2516       stat = ZFailure;
// 2517       break;
// 2518   }
// 2519 
// 2520   return ( stat );
// 2521 }
// 2522 #endif // ZCL_SCENES
// 2523 
// 2524 #ifdef ZCL_ON_OFF
// 2525 /*********************************************************************
// 2526  * @fn      zclGeneral_ProcessInCmdOnOff
// 2527  *
// 2528  * @brief   Process in the received On/Off Command.
// 2529  *
// 2530  * @param   pInMsg - pointer to the incoming message
// 2531  *
// 2532  * @return  ZStatus_t
// 2533  */
// 2534 static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg,
// 2535                                             zclGeneral_AppCallbacks_t *pCBs )
// 2536 {
// 2537   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 2538   {
// 2539     /*if ( pInMsg->hdr.commandID > COMMAND_TOGGLE )
// 2540       return ( ZFailure );   // Error ignore the command
// 2541 */
// 2542     if ( pCBs->pfnOnOff )
// 2543       pCBs->pfnOnOff( pInMsg->hdr.commandID );
// 2544   }
// 2545   // no Client command
// 2546 
// 2547   return ( ZSuccess );
// 2548 }
// 2549 #endif // ZCL_ON_OFF
// 2550 
// 2551 #ifdef ZCL_LEVEL_CTRL
// 2552 /*********************************************************************
// 2553  * @fn      zclGeneral_ProcessInLevelControl
// 2554  *
// 2555  * @brief   Process in the received Level Control Command.
// 2556  *
// 2557  * @param   pInMsg - pointer to the incoming message
// 2558  *
// 2559  * @return  ZStatus_t
// 2560  */
// 2561 static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg,
// 2562                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2563 {
// 2564   uint8 withOnOff = FALSE;
// 2565   ZStatus_t stat = ZSuccess;
// 2566 
// 2567   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 2568   {
// 2569     switch ( pInMsg->hdr.commandID )
// 2570     {
// 2571       case COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF:
// 2572         withOnOff = TRUE;
// 2573         // fall through
// 2574       case COMMAND_LEVEL_MOVE_TO_LEVEL:
// 2575         if ( pCBs->pfnLevelControlMoveToLevel )
// 2576         {
// 2577           zclLCMoveToLevel_t cmd;
// 2578 
// 2579           cmd.level = pInMsg->pData[0];
// 2580           cmd.transitionTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
// 2581           cmd.withOnOff = withOnOff;
// 2582 
// 2583           pCBs->pfnLevelControlMoveToLevel( &cmd );
// 2584         }
// 2585         break;
// 2586 
// 2587       case COMMAND_LEVEL_MOVE_WITH_ON_OFF:
// 2588         withOnOff = TRUE;
// 2589         // fall through
// 2590       case COMMAND_LEVEL_MOVE:
// 2591         if ( pCBs->pfnLevelControlMove )
// 2592         {
// 2593           zclLCMove_t cmd;
// 2594 
// 2595           cmd.moveMode = pInMsg->pData[0];
// 2596           cmd.rate = pInMsg->pData[1];
// 2597           cmd.withOnOff = withOnOff;
// 2598 
// 2599           pCBs->pfnLevelControlMove( &cmd );
// 2600         }
// 2601         break;
// 2602 
// 2603       case COMMAND_LEVEL_STEP_WITH_ON_OFF:
// 2604         withOnOff = TRUE;
// 2605         // fall through
// 2606       case COMMAND_LEVEL_STEP:
// 2607         if ( pCBs->pfnLevelControlStep )
// 2608         {
// 2609           zclLCStep_t cmd;
// 2610 
// 2611           cmd.stepMode = pInMsg->pData[0];
// 2612           cmd.amount =  pInMsg->pData[1];
// 2613           cmd.transitionTime = BUILD_UINT16( pInMsg->pData[2], pInMsg->pData[3] );
// 2614           cmd.withOnOff = withOnOff;
// 2615 
// 2616           pCBs->pfnLevelControlStep( &cmd );
// 2617         }
// 2618         break;
// 2619 
// 2620       case COMMAND_LEVEL_STOP:
// 2621       case COMMAND_LEVEL_STOP_WITH_ON_OFF:
// 2622         // Both Stop commands are identical
// 2623         if ( pCBs->pfnLevelControlStop )
// 2624         {
// 2625           pCBs->pfnLevelControlStop();
// 2626         }
// 2627         break;
// 2628 
// 2629       default:
// 2630         stat = ZFailure;
// 2631         break;
// 2632     }
// 2633   }
// 2634   // no Client command
// 2635 
// 2636   return ( stat );
// 2637 }
// 2638 #endif // ZCL_LEVEL_CTRL
// 2639 
// 2640 #ifdef ZCL_ALARMS
// 2641 /*********************************************************************
// 2642  * @fn      zclGeneral_AddAlarm
// 2643  *
// 2644  * @brief   Add an alarm for a cluster
// 2645  *
// 2646  * @param   endpoint -
// 2647  * @param   alarm - new alarm item
// 2648  *
// 2649  * @return  ZStatus_t
// 2650  */
// 2651 ZStatus_t zclGeneral_AddAlarm( uint8 endpoint, zclGeneral_Alarm_t *alarm )
// 2652 {
// 2653   zclGenAlarmItem_t *pNewItem;
// 2654   zclGenAlarmItem_t *pLoop;
// 2655 
// 2656   // Fill in the new profile list
// 2657   pNewItem = osal_mem_alloc( sizeof( zclGenAlarmItem_t ) );
// 2658   if ( pNewItem == NULL )
// 2659     return ( ZMemError );
// 2660 
// 2661   // Fill in the plugin record.
// 2662   pNewItem->next = (zclGenAlarmItem_t *)NULL;
// 2663   pNewItem->endpoint =  endpoint;
// 2664   osal_memcpy( (uint8*)(&pNewItem->alarm), (uint8*)alarm, sizeof ( zclGeneral_Alarm_t ) );
// 2665 
// 2666   // Find spot in list
// 2667   if (  zclGenAlarmTable == NULL )
// 2668   {
// 2669     zclGenAlarmTable = pNewItem;
// 2670   }
// 2671   else
// 2672   {
// 2673     // Look for end of list
// 2674     pLoop = zclGenAlarmTable;
// 2675     while ( pLoop->next != NULL )
// 2676       pLoop = pLoop->next;
// 2677 
// 2678     // Put new item at end of list
// 2679     pLoop->next = pNewItem;
// 2680   }
// 2681 
// 2682   return ( ZSuccess );
// 2683 }
// 2684 
// 2685 /*********************************************************************
// 2686  * @fn      zclGeneral_FindAlarm
// 2687  *
// 2688  * @brief   Find an alarm with alarmCode and clusterID
// 2689  *
// 2690  * @param   endpoint -
// 2691  * @param   groupID - what group the scene belongs to
// 2692  * @param   sceneID - ID to look for scene
// 2693  *
// 2694  * @return  a pointer to the alarm information, NULL if not found
// 2695  */
// 2696 zclGeneral_Alarm_t *zclGeneral_FindAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
// 2697 {
// 2698   zclGenAlarmItem_t *pLoop;
// 2699 
// 2700   // Look for the alarm
// 2701   pLoop = zclGenAlarmTable;
// 2702   while ( pLoop )
// 2703   {
// 2704     if ( pLoop->endpoint == endpoint &&
// 2705          pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
// 2706     {
// 2707       return ( &(pLoop->alarm) );
// 2708     }
// 2709     pLoop = pLoop->next;
// 2710   }
// 2711 
// 2712   return ( (zclGeneral_Alarm_t *)NULL );
// 2713 }
// 2714 
// 2715 /*********************************************************************
// 2716  * @fn      zclGeneral_FindEarliestAlarm
// 2717  *
// 2718  * @brief   Find an alarm with the earliest timestamp
// 2719  *
// 2720  * @param   endpoint -
// 2721  *
// 2722  * @return  a pointer to the alarm information, NULL if not found
// 2723  */
// 2724 zclGeneral_Alarm_t *zclGeneral_FindEarliestAlarm( uint8 endpoint )
// 2725 {
// 2726   zclGenAlarmItem_t *pLoop;
// 2727   zclGenAlarmItem_t earliestAlarm;
// 2728   zclGenAlarmItem_t *pEarliestAlarm = &earliestAlarm;
// 2729 
// 2730   pEarliestAlarm->alarm.timeStamp = 0xFFFFFFFF;
// 2731 
// 2732   // Look for alarm with earliest time
// 2733   pLoop = zclGenAlarmTable;
// 2734   while ( pLoop )
// 2735   {
// 2736     if ( pLoop->endpoint == endpoint &&
// 2737          pLoop->alarm.timeStamp < pEarliestAlarm->alarm.timeStamp )
// 2738     {
// 2739       pEarliestAlarm = pLoop;
// 2740     }
// 2741     pLoop = pLoop->next;
// 2742   }
// 2743 
// 2744   if ( pEarliestAlarm->alarm.timeStamp != 0xFFFFFFFF )
// 2745     return ( &(pEarliestAlarm->alarm) );
// 2746 
// 2747   // No alarm
// 2748   return ( (zclGeneral_Alarm_t *)NULL );
// 2749 }
// 2750 
// 2751 /*********************************************************************
// 2752  * @fn      zclGeneral_ResetAlarm
// 2753  *
// 2754  * @brief   Remove a scene with endpoint and sceneID
// 2755  *
// 2756  * @param   endpoint -
// 2757  * @param   alarmCode -
// 2758  * @param   clusterID -
// 2759  *
// 2760  * @return  TRUE if removed, FALSE if not found
// 2761  */
// 2762 void zclGeneral_ResetAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
// 2763 {
// 2764   zclGenAlarmItem_t *pLoop;
// 2765   zclGenAlarmItem_t *pPrev;
// 2766 
// 2767   // Look for end of list
// 2768   pLoop = zclGenAlarmTable;
// 2769   pPrev = NULL;
// 2770   while ( pLoop )
// 2771   {
// 2772     if ( pLoop->endpoint == endpoint &&
// 2773          pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
// 2774     {
// 2775       if ( pPrev == NULL )
// 2776         zclGenAlarmTable = pLoop->next;
// 2777       else
// 2778         pPrev->next = pLoop->next;
// 2779 
// 2780       // Free the memory
// 2781       osal_mem_free( pLoop );
// 2782 
// 2783       // Notify the Application so that if the alarm condition still active then
// 2784       // a new notification will be generated, and a new alarm record will be
// 2785       // added to the alarm log
// 2786       // zclGeneral_NotifyReset( alarmCode, clusterID ); // callback function?
// 2787       return;
// 2788     }
// 2789     pPrev = pLoop;
// 2790     pLoop = pLoop->next;
// 2791   }
// 2792 }
// 2793 
// 2794 /*********************************************************************
// 2795  * @fn      zclGeneral_ResetAllAlarms
// 2796  *
// 2797  * @brief   Remove all alarms with endpoint
// 2798  *
// 2799  * @param   endpoint -
// 2800  * @param   notifyApp -
// 2801  *
// 2802  * @return  none
// 2803  */
// 2804 void zclGeneral_ResetAllAlarms( uint8 endpoint, uint8 notifyApp )
// 2805 {
// 2806   zclGenAlarmItem_t *pLoop;
// 2807   zclGenAlarmItem_t *pPrev;
// 2808   zclGenAlarmItem_t *pNext;
// 2809 
// 2810   // Look for end of list
// 2811   pLoop = zclGenAlarmTable;
// 2812   pPrev = NULL;
// 2813   while ( pLoop )
// 2814   {
// 2815     if (  pLoop->endpoint == endpoint )
// 2816     {
// 2817       if ( pPrev == NULL )
// 2818         zclGenAlarmTable = pLoop->next;
// 2819       else
// 2820         pPrev->next = pLoop->next;
// 2821 
// 2822       pNext = pLoop->next;
// 2823 
// 2824       // Free the memory
// 2825       osal_mem_free( pLoop );
// 2826 
// 2827       pLoop = pNext;
// 2828     }
// 2829     else
// 2830     {
// 2831       pPrev = pLoop;
// 2832       pLoop = pLoop->next;
// 2833     }
// 2834   }
// 2835 
// 2836   if ( notifyApp )
// 2837   {
// 2838     // Notify the Application so that if any alarm conditions still active then
// 2839     // a new notification will be generated, and a new alarm record will be
// 2840     // added to the alarm log
// 2841     // zclGeneral_NotifyResetAll(); // callback function?
// 2842   }
// 2843 }
// 2844 
// 2845 /*********************************************************************
// 2846  * @fn      zclGeneral_ProcessInAlarmsServer
// 2847  *
// 2848  * @brief   Process in the received Alarms Command.
// 2849  *
// 2850  * @param   pInMsg - pointer to the incoming message
// 2851  *
// 2852  * @return  ZStatus_t
// 2853  */
// 2854 static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg,
// 2855                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2856 {
// 2857   zclGeneral_Alarm_t *pAlarm;
// 2858   uint8 *pData = pInMsg->pData;
// 2859   ZStatus_t stat = ZSuccess;
// 2860 
// 2861   switch ( pInMsg->hdr.commandID )
// 2862   {
// 2863     case COMMAND_ALARMS_RESET:
// 2864       zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pData[0],
// 2865                              BUILD_UINT16( pData[1], pData[2] ) );
// 2866       break;
// 2867 
// 2868     case COMMAND_ALARMS_RESET_ALL:
// 2869       zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, TRUE );
// 2870       break;
// 2871 
// 2872     case COMMAND_ALARMS_GET:
// 2873       pAlarm = zclGeneral_FindEarliestAlarm( pInMsg->msg->endPoint );
// 2874       if ( pAlarm )
// 2875       {
// 2876         // Send a response back
// 2877         zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2878                                          ZCL_STATUS_SUCCESS, pAlarm->code,
// 2879                                          pAlarm->clusterID, pAlarm->timeStamp,
// 2880                                          true, pInMsg->hdr.transSeqNum );
// 2881         // Remove the entry from the Alarm table
// 2882         zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pAlarm->code, pAlarm->clusterID );
// 2883       }
// 2884       else
// 2885       {
// 2886         // Send a response back
// 2887         zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2888                                          ZCL_STATUS_NOT_FOUND, 0, 0, 0,
// 2889                                          true, pInMsg->hdr.transSeqNum );
// 2890       }
// 2891       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2892       break;
// 2893 
// 2894     case COMMAND_ALARMS_RESET_LOG:
// 2895       zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, FALSE );
// 2896       break;
// 2897 
// 2898 #ifdef SE_UK_EXT
// 2899     case COMMAND_ALARMS_PUBLISH_EVENT_LOG:
// 2900       if ( pCBs->pfnPublishEventLog )
// 2901       {
// 2902         zclPublishEventLog_t eventLog;
// 2903         
// 2904         eventLog.logID = *pData++;
// 2905         eventLog.cmdIndex = *pData++;
// 2906         eventLog.totalCmds = *pData++;
// 2907           
// 2908         // First try to find out number of Sub Log Payloads
// 2909         eventLog.numSubLogs = (pInMsg->pDataLen-3)/(1+4); // event ID + event time
// 2910         if ( eventLog.numSubLogs > 0 )
// 2911         {
// 2912           // Try to alloc space for Log Payload
// 2913           eventLog.pLogs = (zclEventLogPayload_t *)osal_mem_alloc( sizeof( zclEventLogPayload_t ) *
// 2914                                                                    eventLog.numSubLogs );
// 2915           if ( eventLog.pLogs != NULL )
// 2916           {
// 2917             // Copy Log Payload
// 2918             for ( uint8 i = 0; i < eventLog.numSubLogs; i++ )
// 2919             {
// 2920               eventLog.pLogs[i].eventId = *pData++;
// 2921               eventLog.pLogs[i].eventTime = osal_build_uint32( pData, 4 );
// 2922               pData += 4;
// 2923             }
// 2924           }
// 2925           else
// 2926           {
// 2927             stat = ZCL_STATUS_SOFTWARE_FAILURE;
// 2928           }
// 2929         }
// 2930         else
// 2931         {
// 2932           eventLog.pLogs = NULL;
// 2933         }
// 2934         
// 2935         if ( stat == ZSuccess )
// 2936         { 
// 2937           pCBs->pfnPublishEventLog( &(pInMsg->msg->srcAddr), &eventLog );
// 2938         }
// 2939         
// 2940         if ( eventLog.pLogs != NULL )
// 2941         {
// 2942           osal_mem_free( eventLog.pLogs );
// 2943         }
// 2944       }
// 2945       break;
// 2946 #endif // SE_UK_EXT
// 2947       
// 2948     default:
// 2949       stat = ZFailure;
// 2950       break;
// 2951   }
// 2952 
// 2953   return ( stat );
// 2954 }
// 2955 
// 2956 /*********************************************************************
// 2957  * @fn      zclGeneral_ProcessInAlarmsClient
// 2958  *
// 2959  * @brief   Process in the received Alarms Command.
// 2960  *
// 2961  * @param   pInMsg - pointer to the incoming message
// 2962  *
// 2963  * @return  ZStatus_t
// 2964  */
// 2965 static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg,
// 2966                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2967 {
// 2968   uint8 *pData = pInMsg->pData;
// 2969   zclAlarm_t alarm;
// 2970   ZStatus_t stat = ZSuccess;
// 2971 
// 2972   osal_memset( (uint8*)&alarm, 0, sizeof( zclAlarm_t ) );
// 2973 
// 2974   switch ( pInMsg->hdr.commandID )
// 2975   {
// 2976     case COMMAND_ALARMS_ALARM:
// 2977       if ( pCBs->pfnAlarm )
// 2978       {
// 2979         alarm.srcAddr = &(pInMsg->msg->srcAddr);
// 2980         alarm.cmdID = pInMsg->hdr.commandID;
// 2981         alarm.status = *pData++;
// 2982         alarm.alarmCode = *pData++;
// 2983         alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
// 2984         pData += 2;
// 2985         alarm.timeStamp = osal_build_uint32( pData, 4 );
// 2986 
// 2987         pCBs->pfnAlarm( &alarm );
// 2988       }
// 2989       break;
// 2990 
// 2991     case COMMAND_ALARMS_GET_RSP:
// 2992       if ( pCBs->pfnAlarm )
// 2993       {
// 2994         alarm.srcAddr = &(pInMsg->msg->srcAddr);
// 2995         alarm.cmdID = pInMsg->hdr.commandID;
// 2996         alarm.alarmCode = *pData++;
// 2997         alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
// 2998 
// 2999         pCBs->pfnAlarm( &alarm );
// 3000       }
// 3001       break;
// 3002 
// 3003 #ifdef SE_UK_EXT
// 3004     case COMMAND_ALARMS_GET_EVENT_LOG:
// 3005       if ( pCBs->pfnGetEventLog )
// 3006       {
// 3007         zclGetEventLog_t eventLog;
// 3008         
// 3009         eventLog.logID = *pData++;
// 3010         eventLog.startTime = osal_build_uint32( pData, 4 );
// 3011         pData += 4;
// 3012         eventLog.endTime = osal_build_uint32( pData, 4 );
// 3013         pData += 4;
// 3014         eventLog.numEvents = *pData;
// 3015   
// 3016         pCBs->pfnGetEventLog( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 3017                               &eventLog, pInMsg->hdr.transSeqNum );
// 3018       }
// 3019       break;
// 3020 #endif // SE_UK_EXT
// 3021       
// 3022     default:
// 3023       stat = ZFailure;
// 3024       break;
// 3025   }
// 3026 
// 3027   return ( stat );
// 3028 }
// 3029 #endif // ZCL_ALARMS
// 3030 
// 3031 #ifdef ZCL_LOCATION
// 3032 /*********************************************************************
// 3033  * @fn      zclGeneral_ProcessInLocationServer
// 3034  *
// 3035  * @brief   Process in the received Location Command.
// 3036  *
// 3037  * @param   pInMsg - pointer to the incoming message
// 3038  *
// 3039  * @return  ZStatus_t
// 3040  */
// 3041 static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg,
// 3042                                                      zclGeneral_AppCallbacks_t *pCBs )
// 3043 {
// 3044   uint8 *pData = pInMsg->pData;
// 3045   zclLocation_t cmd;
// 3046   ZStatus_t stat = ZSuccess;
// 3047 
// 3048   osal_memset( (uint8*)&cmd, 0, sizeof( zclLocation_t ) );
// 3049 
// 3050   switch ( pInMsg->hdr.commandID )
// 3051   {
// 3052     case COMMAND_LOCATION_SET_ABSOLUTE:
// 3053       cmd.un.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
// 3054       pData += 2;
// 3055       cmd.un.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
// 3056       pData += 2;
// 3057       cmd.un.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
// 3058       pData += 2;
// 3059       cmd.un.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
// 3060       pData += 2;
// 3061       cmd.un.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 3062 
// 3063       if ( pCBs->pfnLocation )
// 3064       {
// 3065         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 3066         cmd.cmdID = pInMsg->hdr.commandID;
// 3067 
// 3068         // Update the absolute location info
// 3069         pCBs->pfnLocation( &cmd );
// 3070       }
// 3071       break;
// 3072 
// 3073     case COMMAND_LOCATION_SET_DEV_CFG:
// 3074       cmd.un.devCfg.power = BUILD_UINT16( pData[0], pData[1] );
// 3075       pData += 2;
// 3076       cmd.un.devCfg.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 3077       pData += 2;
// 3078       cmd.un.devCfg.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
// 3079       pData += 2;
// 3080       cmd.un.devCfg.numMeasurements = *pData++;
// 3081       cmd.un.devCfg.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
// 3082 
// 3083       if ( pCBs->pfnLocation )
// 3084       {
// 3085         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 3086         cmd.cmdID = pInMsg->hdr.commandID;
// 3087 
// 3088         // Update the device configuration info
// 3089         pCBs->pfnLocation( &cmd );
// 3090       }
// 3091       break;
// 3092 
// 3093     case COMMAND_LOCATION_GET_DEV_CFG:
// 3094       cmd.un.ieeeAddr = pData;
// 3095 
// 3096       if ( pCBs->pfnLocation )
// 3097       {
// 3098         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 3099         cmd.cmdID = pInMsg->hdr.commandID;
// 3100         cmd.seqNum = pInMsg->hdr.transSeqNum;
// 3101 
// 3102         // Retreive the Device Configuration
// 3103         pCBs->pfnLocation( &cmd );
// 3104       }
// 3105       stat = ZCL_STATUS_CMD_HAS_RSP;
// 3106       break;
// 3107 
// 3108     case COMMAND_LOCATION_GET_DATA:
// 3109       cmd.un.loc.bitmap.locByte = *pData++;
// 3110       cmd.un.loc.numResponses = *pData++;
// 3111 
// 3112       if ( cmd.un.loc.brdcastResponse == 0 ) // command is sent as a unicast
// 3113         osal_cpyExtAddr( cmd.un.loc.targetAddr, pData );
// 3114 
// 3115       if ( pCBs->pfnLocation )
// 3116       {
// 3117         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 3118         cmd.cmdID = pInMsg->hdr.commandID;
// 3119         cmd.seqNum = pInMsg->hdr.transSeqNum;
// 3120 
// 3121         // Retreive the Location Data
// 3122         pCBs->pfnLocation( &cmd );
// 3123       }
// 3124       stat = ZCL_STATUS_CMD_HAS_RSP;
// 3125       break;
// 3126 
// 3127     default:
// 3128       stat = ZFailure;
// 3129       break;
// 3130   }
// 3131 
// 3132   return ( stat );
// 3133 }
// 3134 
// 3135 /*********************************************************************
// 3136  * @fn      zclGeneral_ProcessInLocationDataRsp
// 3137  *
// 3138  * @brief   Process in the received Location Command.
// 3139  *
// 3140  * @param   pInMsg - pointer to the incoming message
// 3141  *
// 3142  * @return  ZStatus_t
// 3143  */
// 3144 static void zclGeneral_ProcessInLocationDataRsp( zclIncoming_t *pInMsg,
// 3145                                                  zclGeneral_AppCallbacks_t *pCBs )
// 3146 {
// 3147   uint8 *pData = pInMsg->pData;
// 3148   zclLocationRsp_t rsp;
// 3149 
// 3150   osal_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
// 3151 
// 3152   if ( pCBs->pfnLocationRsp )
// 3153   {
// 3154     if ( pInMsg->hdr.commandID == COMMAND_LOCATION_DATA_RSP )
// 3155       rsp.un.loc.status = *pData++;
// 3156 
// 3157     if ( pInMsg->hdr.commandID != COMMAND_LOCATION_DATA_RSP ||
// 3158          rsp.un.loc.status == ZCL_STATUS_SUCCESS )
// 3159     {
// 3160       rsp.un.loc.data.type = *pData++;
// 3161       rsp.un.loc.data.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
// 3162       pData += 2;
// 3163       rsp.un.loc.data.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
// 3164       pData += 2;
// 3165 
// 3166       if ( locationType2D( rsp.un.loc.data.type ) == 0 )
// 3167       {
// 3168         rsp.un.loc.data.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
// 3169         pData += 2;
// 3170       }
// 3171 
// 3172       if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 3173       {
// 3174         rsp.un.loc.data.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
// 3175         pData += 2;
// 3176         rsp.un.loc.data.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 3177         pData += 2;
// 3178       }
// 3179 
// 3180       if ( locationTypeAbsolute( rsp.un.loc.data.type ) == 0 )
// 3181       {
// 3182         if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 3183           rsp.un.loc.data.calcLoc.locationMethod = *pData++;
// 3184 
// 3185         rsp.un.loc.data.calcLoc.qualityMeasure = *pData++;
// 3186         rsp.un.loc.data.calcLoc.locationAge = BUILD_UINT16( pData[0], pData[1] );
// 3187       }
// 3188     }
// 3189 
// 3190     rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 3191     rsp.cmdID = pInMsg->hdr.commandID;
// 3192 
// 3193     // Notify the Application
// 3194     pCBs->pfnLocationRsp( &rsp );
// 3195   }
// 3196 }
// 3197 
// 3198 /*********************************************************************
// 3199  * @fn      zclGeneral_ProcessInLocationClient
// 3200  *
// 3201  * @brief   Process in the received Location Command.
// 3202  *
// 3203  * @param   pInMsg - pointer to the incoming message
// 3204  *
// 3205  * @return  ZStatus_t
// 3206  */
// 3207 static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg,
// 3208                                                      zclGeneral_AppCallbacks_t *pCBs )
// 3209 {
// 3210   uint8 *pData = pInMsg->pData;
// 3211   zclLocationRsp_t rsp;
// 3212   ZStatus_t stat = ZSuccess;
// 3213 
// 3214   osal_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
// 3215 
// 3216   switch ( pInMsg->hdr.commandID )
// 3217   {
// 3218     case COMMAND_LOCATION_DEV_CFG_RSP:
// 3219       if ( pCBs->pfnLocationRsp )
// 3220       {
// 3221         rsp.un.devCfg.status = *pData++;
// 3222         if ( rsp.un.devCfg.status == ZCL_STATUS_SUCCESS )
// 3223         {
// 3224           rsp.un.devCfg.data.power = BUILD_UINT16( pData[0], pData[1] );
// 3225           pData += 2;
// 3226           rsp.un.devCfg.data.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 3227           pData += 2;
// 3228           rsp.un.devCfg.data.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
// 3229           pData += 2;
// 3230           rsp.un.devCfg.data.numMeasurements = *pData++;
// 3231           rsp.un.devCfg.data.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
// 3232 
// 3233           rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 3234           rsp.cmdID = pInMsg->hdr.commandID;
// 3235 
// 3236           // Notify the Application
// 3237           pCBs->pfnLocationRsp( &rsp );
// 3238         }
// 3239       }
// 3240       break;
// 3241 
// 3242     case COMMAND_LOCATION_DATA_RSP:
// 3243     case COMMAND_LOCATION_DATA_NOTIF:
// 3244     case COMMAND_LOCATION_COMPACT_DATA_NOTIF:
// 3245       zclGeneral_ProcessInLocationDataRsp( pInMsg, pCBs );
// 3246       break;
// 3247 
// 3248     case COMMAND_LOCATION_RSSI_PING:
// 3249       if ( pCBs->pfnLocationRsp )
// 3250       {
// 3251         rsp.un.locationType = *pData;
// 3252 
// 3253         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 3254         rsp.cmdID = pInMsg->hdr.commandID;
// 3255 
// 3256         // Notify the Application
// 3257         pCBs->pfnLocationRsp( &rsp );
// 3258       }
// 3259       break;
// 3260 
// 3261     default:
// 3262       stat = ZFailure;
// 3263       break;
// 3264   }
// 3265 
// 3266   return ( stat );
// 3267 }
// 3268 #endif // ZCL_LOCATION
// 3269 
// 3270 #ifdef ZCL_SCENES
// 3271 /*********************************************************************
// 3272  * @fn      zclGeneral_ScenesInitNV
// 3273  *
// 3274  * @brief   Initialize the NV Scene Table Items
// 3275  *
// 3276  * @param   none
// 3277  *
// 3278  * @return  number of scenes
// 3279  */
// 3280 static uint8 zclGeneral_ScenesInitNV( void )
// 3281 {
// 3282   uint8  status;
// 3283   uint16 size;
// 3284 
// 3285   size = (uint16)((sizeof ( nvGenScenesHdr_t ))
// 3286                   + ( sizeof( zclGenSceneNVItem_t ) * ZCL_GEN_MAX_SCENES ));
// 3287 
// 3288   status = osal_nv_item_init( ZCD_NV_SCENE_TABLE, size, NULL );
// 3289 
// 3290   if ( status != ZSUCCESS )
// 3291   {
// 3292     zclGeneral_ScenesSetDefaultNV();
// 3293   }
// 3294 
// 3295   return status;
// 3296 }
// 3297 
// 3298 /*********************************************************************
// 3299  * @fn          zclGeneral_ScenesSetDefaultNV
// 3300  *
// 3301  * @brief       Write the defaults to NV
// 3302  *
// 3303  * @param       none
// 3304  *
// 3305  * @return      none
// 3306  */
// 3307 static void zclGeneral_ScenesSetDefaultNV( void )
// 3308 {
// 3309   nvGenScenesHdr_t hdr;
// 3310 
// 3311   // Initialize the header
// 3312   hdr.numRecs = 0;
// 3313 
// 3314   // Save off the header
// 3315   osal_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
// 3316 }
// 3317 
// 3318 /*********************************************************************
// 3319  * @fn          zclGeneral_ScenesWriteNV
// 3320  *
// 3321  * @brief       Save the Scene Table in NV
// 3322  *
// 3323  * @param       none
// 3324  *
// 3325  * @return      none
// 3326  */
// 3327 static void zclGeneral_ScenesWriteNV( void )
// 3328 {
// 3329   nvGenScenesHdr_t hdr;
// 3330   zclGenSceneItem_t *pLoop;
// 3331   zclGenSceneNVItem_t item;
// 3332 
// 3333   hdr.numRecs = 0;
// 3334 
// 3335   // Look for end of list
// 3336   pLoop = zclGenSceneTable;
// 3337   while ( pLoop )
// 3338   {
// 3339     // Build the record
// 3340     item.endpoint = pLoop->endpoint;
// 3341     osal_memcpy( &(item.scene), &(pLoop->scene), sizeof ( zclGeneral_Scene_t ) );
// 3342 
// 3343     // Save the record to NV
// 3344     osal_nv_write( ZCD_NV_SCENE_TABLE,
// 3345             (uint16)((sizeof( nvGenScenesHdr_t )) + (hdr.numRecs * sizeof ( zclGenSceneNVItem_t ))),
// 3346                     sizeof ( zclGenSceneNVItem_t ), &item );
// 3347 
// 3348     hdr.numRecs++;
// 3349 
// 3350     pLoop = pLoop->next;
// 3351   }
// 3352 
// 3353   // Save off the header
// 3354   osal_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
// 3355 }
// 3356 
// 3357 /*********************************************************************
// 3358  * @fn          zclGeneral_ScenesRestoreFromNV
// 3359  *
// 3360  * @brief       Restore the Scene table from NV
// 3361  *
// 3362  * @param       none
// 3363  *
// 3364  * @return      Number of entries restored
// 3365  */
// 3366 static uint16 zclGeneral_ScenesRestoreFromNV( void )
// 3367 {
// 3368   uint16 x;
// 3369   nvGenScenesHdr_t hdr;
// 3370 
// 3371   zclGenSceneNVItem_t item;
// 3372   uint16 numAdded = 0;
// 3373 
// 3374   if ( osal_nv_read( ZCD_NV_SCENE_TABLE, 0, sizeof(nvGenScenesHdr_t), &hdr ) == ZSuccess )
// 3375   {
// 3376     // Read in the device list
// 3377     for ( x = 0; x < hdr.numRecs; x++ )
// 3378     {
// 3379       if ( osal_nv_read( ZCD_NV_SCENE_TABLE,
// 3380                 (uint16)(sizeof(nvGenScenesHdr_t) + (x * sizeof ( zclGenSceneNVItem_t ))),
// 3381                                   sizeof ( zclGenSceneNVItem_t ), &item ) == ZSUCCESS )
// 3382       {
// 3383         // Add the scene
// 3384         if ( zclGeneral_AddScene( item.endpoint, &(item.scene) ) == ZSuccess )
// 3385         {
// 3386           numAdded++;
// 3387         }
// 3388       }
// 3389     }
// 3390   }
// 3391 
// 3392   return ( numAdded );
// 3393 }
// 3394 #endif // ZCL_SCENES
// 3395 
// 3396 /***************************************************************************
// 3397 ****************************************************************************/
// 
// 1 009 bytes in segment BANKED_CODE
//    36 bytes in segment BANK_RELAYS
//     3 bytes in segment XDATA_Z
// 
// 1 045 bytes of CODE  memory
//     3 bytes of XDATA memory
//
//Errors: none
//Warnings: none
