###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         08/Aug/2017  09:25:02 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\work space\Smart Product\Two YHY\Door\v1.03.0   #
#                          Green\ZStack-CC2530-2.5.1a\COMPONENTS\stack\zcl\zc #
#                          l_general.c                                        #
#    Command line       =  -f "D:\work space\Smart Product\Two                #
#                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proje #
#                          cts\zstack\HomeAutomation\SmartDoor\CC2530DB\..\To #
#                          ols\CC2530DB\f8wEndev.cfg" (-DCPU32MHZ             #
#                          -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3         #
#                          -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3              #
#                          -DHAL_KEY=FALSE -DHAL_LED=FALSE -DHAL_LCD=FALSE    #
#                          -DHAL_ADC=FALSE -DNV_RESTORE -DNV_INIT             #
#                          -DPOWER_SAVING -DTC_LINKKEY_JOIN) -f "D:\work      #
#                          space\Smart Product\Two YHY\Door\v1.03.0           #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\..\Tools\CC2530DB\f8wCo #
#                          nfig.cfg" (-DZIGBEEPRO -DSECURE=1                  #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x06108800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4                        #
#                          -DDEFAULT_KEY={0x58,0x69,0x6E,0x67,0x48,0x75,0x6F, #
#                          0x59,0x75,0x61,0x6E,0x53,0x6D,0x61,0x72,0x74}      #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=0           #
#                          -DQUEUED_POLL_RATE=0 -DRESPONSE_POLL_RATE=0        #
#                          -DREJOIN_POLL_RATE=440) -f "D:\work space\Smart    #
#                          Product\Two YHY\Door\v1.03.0                       #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\..\Tools\CC2530DB\f8wZC #
#                          L.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_REPORT        #
#                          -DZCL_BASIC -DZCL_IDENTIFY -DZCL_ON_OFF            #
#                          -DZCL_KEY_ESTABLISH -DZCL_KEY_ESTABLISHMENT_KEY_GE #
#                          NERATE_TIMEOUT=4 -DZCL_KEY_ESTABLISHMENT_MAC_GENER #
#                          ATE_TIMEOUT=10 -DZCL_KEY_ESTABLISHMENT_EKEY_GENERA #
#                          TE_TIMEOUT=10 -DZCL_LOAD_CONTROL                   #
#                          -DZCL_SIMPLE_METERING -DZCL_PRICING -DZCL_MESSAGE  #
#                          -DZCL_TUNNELING -DZCL_TOU) -DZCL_DEVICE_MGMT       #
#                          "D:\work space\Smart Product\Two YHY\Door\v1.03.0  #
#                           Green\ZStack-CC2530-2.5.1a\COMPONENTS\stack\zcl\z #
#                          cl_general.c" -lC "D:\work space\Smart             #
#                          Product\Two YHY\Door\v1.03.0                       #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\EndDeviceEB\List\" -lA  #
#                          "D:\work space\Smart Product\Two YHY\Door\v1.03.0  #
#                           Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu #
#                          tomation\SmartDoor\CC2530DB\EndDeviceEB\List\"     #
#                          --diag_suppress Pe001,Pa010 -o "D:\work            #
#                          space\Smart Product\Two YHY\Door\v1.03.0           #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\EndDeviceEB\Obj\" -e    #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I "D:\work space\Smart Product\Two                #
#                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proje #
#                          cts\zstack\HomeAutomation\SmartDoor\CC2530DB\" -I  #
#                          "D:\work space\Smart Product\Two YHY\Door\v1.03.0  #
#                           Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu #
#                          tomation\SmartDoor\CC2530DB\..\Source\" -I         #
#                          "D:\work space\Smart Product\Two YHY\Door\v1.03.0  #
#                           Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu #
#                          tomation\SmartDoor\CC2530DB\..\..\Source\" -I      #
#                          "D:\work space\Smart Product\Two YHY\Door\v1.03.0  #
#                           Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu #
#                          tomation\SmartDoor\CC2530DB\..\..\..\ZMain\TI2530D #
#                          B\" -I "D:\work space\Smart Product\Two            #
#                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proje #
#                          cts\zstack\HomeAutomation\SmartDoor\CC2530DB\..\.. #
#                          \..\..\..\Components\hal\include\" -I "D:\work     #
#                          space\Smart Product\Two YHY\Door\v1.03.0           #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\..\..\..\..\..\Componen #
#                          ts\hal\target\CC2530EB\" -I "D:\work space\Smart   #
#                          Product\Two YHY\Door\v1.03.0                       #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\..\..\..\..\..\Componen #
#                          ts\mac\include\" -I "D:\work space\Smart           #
#                          Product\Two YHY\Door\v1.03.0                       #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\..\..\..\..\..\Componen #
#                          ts\mac\high_level\" -I "D:\work space\Smart        #
#                          Product\Two YHY\Door\v1.03.0                       #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\..\..\..\..\..\Componen #
#                          ts\mac\low_level\srf04\" -I "D:\work space\Smart   #
#                          Product\Two YHY\Door\v1.03.0                       #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\..\..\..\..\..\Componen #
#                          ts\mac\low_level\srf04\single_chip\" -I "D:\work   #
#                          space\Smart Product\Two YHY\Door\v1.03.0           #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\..\..\..\..\..\Componen #
#                          ts\mt\" -I "D:\work space\Smart Product\Two        #
#                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proje #
#                          cts\zstack\HomeAutomation\SmartDoor\CC2530DB\..\.. #
#                          \..\..\..\Components\osal\include\" -I "D:\work    #
#                          space\Smart Product\Two YHY\Door\v1.03.0           #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\..\..\..\..\..\Componen #
#                          ts\services\saddr\" -I "D:\work space\Smart        #
#                          Product\Two YHY\Door\v1.03.0                       #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\..\..\..\..\..\Componen #
#                          ts\services\sdata\" -I "D:\work space\Smart        #
#                          Product\Two YHY\Door\v1.03.0                       #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\..\..\..\..\..\Componen #
#                          ts\stack\af\" -I "D:\work space\Smart Product\Two  #
#                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proje #
#                          cts\zstack\HomeAutomation\SmartDoor\CC2530DB\..\.. #
#                          \..\..\..\Components\stack\nwk\" -I "D:\work       #
#                          space\Smart Product\Two YHY\Door\v1.03.0           #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\..\..\..\..\..\Componen #
#                          ts\stack\sapi\" -I "D:\work space\Smart            #
#                          Product\Two YHY\Door\v1.03.0                       #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\..\..\..\..\..\Componen #
#                          ts\stack\sec\" -I "D:\work space\Smart             #
#                          Product\Two YHY\Door\v1.03.0                       #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\..\..\..\..\..\Componen #
#                          ts\stack\sys\" -I "D:\work space\Smart             #
#                          Product\Two YHY\Door\v1.03.0                       #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\..\..\..\..\..\Componen #
#                          ts\stack\zcl\" -I "D:\work space\Smart             #
#                          Product\Two YHY\Door\v1.03.0                       #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\..\..\..\..\..\Componen #
#                          ts\stack\zdo\" -I "D:\work space\Smart             #
#                          Product\Two YHY\Door\v1.03.0                       #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\..\..\..\..\..\Componen #
#                          ts\zmac\" -I "D:\work space\Smart Product\Two      #
#                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proje #
#                          cts\zstack\HomeAutomation\SmartDoor\CC2530DB\..\.. #
#                          \..\..\..\Components\zmac\f8w\" -Oh                #
#                          --require_prototypes                               #
#    List file          =  D:\work space\Smart Product\Two YHY\Door\v1.03.0   #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\EndDeviceEB\List\zcl_ge #
#                          neral.lst                                          #
#    Object file        =  D:\work space\Smart Product\Two YHY\Door\v1.03.0   #
#                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAut #
#                          omation\SmartDoor\CC2530DB\EndDeviceEB\Obj\zcl_gen #
#                          eral.r51                                           #
#                                                                             #
#                                                                             #
###############################################################################

D:\work space\Smart Product\Two YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\COMPONENTS\stack\zcl\zcl_general.c
      1          /**************************************************************************************************
      2            Filename:       zcl_general.c
      3            Revised:        $Date: 2011-12-14 16:30:16 -0800 (Wed, 14 Dec 2011) $
      4            Revision:       $Revision: 28678 $
      5          
      6            Description:    Zigbee Cluster Library - General.  This application receives all
      7                            ZCL messages and initially parses them before passing to application.
      8          
      9          
     10            Copyright 2006-2011 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License").  You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product.  Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42           * INCLUDES
     43           */
     44          #include "ZComDef.h"
     45          #include "OSAL.h"
     46          #include "OSAL_Nv.h"
     47          #include "zcl.h"
     48          #include "zcl_general.h"
     49          #include "ZDApp.h"
     50          
     51          #if defined ( INTER_PAN )
     52            #include "stub_aps.h"
     53          #endif
     54          
     55          /*********************************************************************
     56           * MACROS
     57           */
     58          #define locationTypeAbsolute( a )          ( (a) & LOCATION_TYPE_ABSOLUTE )
     59          #define locationType2D( a )                ( (a) & LOCATION_TYPE_2_D )
     60          #define locationTypeCoordinateSystem( a )  ( (a) & LOCATION_TYPE_COORDINATE_SYSTEM )
     61          
     62          #ifdef ZCL_SCENES
     63          #define zclGeneral_ScenesRemaingCapacity() ( ZCL_GEN_MAX_SCENES - zclGeneral_CountAllScenes() )
     64          #endif // ZCL_SCENES
     65          
     66          /*********************************************************************
     67           * CONSTANTS
     68           */
     69          
     70          /*********************************************************************
     71           * TYPEDEFS
     72           */
     73          typedef struct zclGenCBRec
     74          {
     75            struct zclGenCBRec        *next;
     76            uint8                     endpoint; // Used to link it into the endpoint descriptor
     77            zclGeneral_AppCallbacks_t *CBs;     // Pointer to Callback function
     78          } zclGenCBRec_t;
     79          
     80          typedef struct zclGenSceneItem
     81          {
     82            struct zclGenSceneItem    *next;
     83            uint8                     endpoint; // Used to link it into the endpoint descriptor
     84            zclGeneral_Scene_t        scene;    // Scene info
     85          } zclGenSceneItem_t;
     86          
     87          typedef struct zclGenAlarmItem
     88          {
     89            struct zclGenAlarmItem    *next;
     90            uint8                     endpoint; // Used to link it into the endpoint descriptor
     91            zclGeneral_Alarm_t        alarm;    // Alarm info
     92          } zclGenAlarmItem_t;
     93          
     94          // Scene NV types
     95          typedef struct
     96          {
     97            uint16                    numRecs;
     98          } nvGenScenesHdr_t;
     99          
    100          typedef struct zclGenSceneNVItem
    101          {
    102            uint8                     endpoint;
    103            zclGeneral_Scene_t        scene;
    104          } zclGenSceneNVItem_t;
    105          
    106          /*********************************************************************
    107           * GLOBAL VARIABLES
    108           */
    109          
    110          /*********************************************************************
    111           * GLOBAL FUNCTIONS
    112           */
    113          
    114          /*********************************************************************
    115           * LOCAL VARIABLES
    116           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    117          static zclGenCBRec_t *zclGenCBs = (zclGenCBRec_t *)NULL;
   \                     zclGenCBs:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    118          static uint8 zclGenPluginRegisted = FALSE;
   \                     zclGenPluginRegisted:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    119          #ifdef ZCL_SCENES
    120          static zclGenSceneItem_t *zclGenSceneTable = (zclGenSceneItem_t *)NULL;
    121          #endif // ZCL_SCENES
    122          #ifdef ZCL_ALARMS
    123          static zclGenAlarmItem_t *zclGenAlarmTable = (zclGenAlarmItem_t *)NULL;
    124          #endif // ZCL_ALARMS
    125          
    126          /*********************************************************************
    127           * LOCAL FUNCTIONS
    128           */
    129          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg );
    130          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg );
    131          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint );
    132          
    133          // Device Configuration and Installation clusters
    134          #ifdef ZCL_BASIC
    135          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    136          #endif // ZCL_BASIC
    137          
    138          #ifdef ZCL_IDENTIFY
    139          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    140          #endif // ZCL_IDENTIFY
    141          
    142          // Groups and Scenes clusters
    143          #ifdef ZCL_GROUPS
    144          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg );
    145          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    146          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData );
    147          #endif // ZCL_GROUPS
    148          
    149          #ifdef ZCL_SCENES
    150          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    151          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    152          #endif // ZCL_SCENES
    153          
    154          // On/Off and Level Control Configuration clusters
    155          #ifdef ZCL_ON_OFF
    156          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    157          #endif // ZCL_ONOFF
    158          
    159          #ifdef ZCL_LEVEL_CTRL
    160          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    161          #endif // ZCL_LEVEL_CTRL
    162          
    163          // Alarms cluster
    164          #ifdef ZCL_ALARMS
    165          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    166          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    167          #endif // ZCL_ALARMS
    168          
    169          // Location cluster
    170          #ifdef ZCL_LOCATION
    171          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    172          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    173          #endif // ZCL_LOCATION
    174          
    175          #ifdef ZCL_SCENES
    176          static uint8 zclGeneral_ScenesInitNV( void );
    177          static void zclGeneral_ScenesSetDefaultNV( void );
    178          static void zclGeneral_ScenesWriteNV( void );
    179          static uint16 zclGeneral_ScenesRestoreFromNV( void );
    180          #endif // ZCL_SCENES
    181          
    182          /*********************************************************************
    183           * @fn      zclGeneral_RegisterCmdCallbacks
    184           *
    185           * @brief   Register an applications command callbacks
    186           *
    187           * @param   endpoint - application's endpoint
    188           * @param   callbacks - pointer to the callback record.
    189           *
    190           * @return  ZMemError if not able to allocate
    191           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    192          ZStatus_t zclGeneral_RegisterCmdCallbacks( uint8 endpoint, zclGeneral_AppCallbacks_t *callbacks )
   \                     zclGeneral_RegisterCmdCallbacks:
    193          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
    194            zclGenCBRec_t *pNewItem;
    195            zclGenCBRec_t *pLoop;
    196          
    197            // Register as a ZCL Plugin
    198            if ( zclGenPluginRegisted == FALSE )
   \   00000B   90....       MOV     DPTR,#zclGenPluginRegisted
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   7021         JNZ     ??zclGeneral_RegisterCmdCallbacks_0
    199            {
    200              zcl_registerPlugin( ZCL_CLUSTER_ID_GEN_BASIC,
    201                                  ZCL_CLUSTER_ID_GEN_MULTISTATE_VALUE_BASIC,
    202                                  zclGeneral_HdlIncoming );
   \   000011                ; Setup parameters for call to function zcl_registerPlugin
   \   000011   75....       MOV     ?V0 + 2,#??zclGeneral_HdlIncoming?relay & 0xff
   \   000014   75....       MOV     ?V0 + 3,#(??zclGeneral_HdlIncoming?relay >> 8) & 0xff
   \   000017   78..         MOV     R0,#?V0 + 2
   \   000019   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001C   7C14         MOV     R4,#0x14
   \   00001E   7D00         MOV     R5,#0x0
   \   000020   7A00         MOV     R2,#0x0
   \   000022   7B00         MOV     R3,#0x0
   \   000024   12....       LCALL   ??zcl_registerPlugin?relay
   \   000027   7402         MOV     A,#0x2
   \   000029   12....       LCALL   ?DEALLOC_XSTACK8
    203          
    204          #ifdef ZCL_SCENES
    205              // Initialize NV items
    206              zclGeneral_ScenesInitNV();
    207          
    208              // Restore the Scene table
    209              zclGeneral_ScenesRestoreFromNV();
    210          #endif // ZCL_SCENES
    211          
    212              zclGenPluginRegisted = TRUE;
   \   00002C   90....       MOV     DPTR,#zclGenPluginRegisted
   \   00002F   7401         MOV     A,#0x1
   \   000031   F0           MOVX    @DPTR,A
    213            }
    214          
    215            // Fill in the new profile list
    216            pNewItem = osal_mem_alloc( sizeof( zclGenCBRec_t ) );
   \                     ??zclGeneral_RegisterCmdCallbacks_0:
   \   000032                ; Setup parameters for call to function osal_mem_alloc
   \   000032   7A05         MOV     R2,#0x5
   \   000034   7B00         MOV     R3,#0x0
   \   000036   12....       LCALL   ??osal_mem_alloc?relay
   \   000039   8A..         MOV     ?V0 + 2,R2
   \   00003B   8B..         MOV     ?V0 + 3,R3
   \   00003D   A8..         MOV     R0,?V0 + 2
   \   00003F   A9..         MOV     R1,?V0 + 3
    217            if ( pNewItem == NULL )
   \   000041   E8           MOV     A,R0
   \   000042   49           ORL     A,R1
   \   000043   7004         JNZ     ??zclGeneral_RegisterCmdCallbacks_1
    218              return (ZMemError);
   \   000045   7910         MOV     R1,#0x10
   \   000047   804E         SJMP    ??zclGeneral_RegisterCmdCallbacks_2
    219          
    220            pNewItem->next = (zclGenCBRec_t *)NULL;
   \                     ??zclGeneral_RegisterCmdCallbacks_1:
   \   000049   8882         MOV     DPL,R0
   \   00004B   8983         MOV     DPH,R1
   \   00004D   E4           CLR     A
   \   00004E   F0           MOVX    @DPTR,A
   \   00004F   A3           INC     DPTR
   \   000050   F0           MOVX    @DPTR,A
    221            pNewItem->endpoint = endpoint;
   \   000051   8882         MOV     DPL,R0
   \   000053   8983         MOV     DPH,R1
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   E5..         MOV     A,?V0 + 0
   \   000059   F0           MOVX    @DPTR,A
    222            pNewItem->CBs = callbacks;
   \   00005A   8882         MOV     DPL,R0
   \   00005C   8983         MOV     DPH,R1
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   EE           MOV     A,R6
   \   000062   F0           MOVX    @DPTR,A
   \   000063   A3           INC     DPTR
   \   000064   EF           MOV     A,R7
   \   000065   F0           MOVX    @DPTR,A
    223          
    224            // Find spot in list
    225            if (  zclGenCBs == NULL )
   \   000066   90....       MOV     DPTR,#zclGenCBs
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   FA           MOV     R2,A
   \   00006B   A3           INC     DPTR
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   FB           MOV     R3,A
   \   00006E   EA           MOV     A,R2
   \   00006F   4B           ORL     A,R3
   \   000070   90....       MOV     DPTR,#zclGenCBs
   \   000073   601B         JZ      ??zclGeneral_RegisterCmdCallbacks_3
    226            {
    227              zclGenCBs = pNewItem;
    228            }
    229            else
    230            {
    231              // Look for end of list
    232              pLoop = zclGenCBs;
   \   000075   E0           MOVX    A,@DPTR
   \   000076   FC           MOV     R4,A
   \   000077   A3           INC     DPTR
   \   000078   E0           MOVX    A,@DPTR
   \   000079   8003         SJMP    ??zclGeneral_RegisterCmdCallbacks_4
    233              while ( pLoop->next != NULL )
    234                pLoop = pLoop->next;
   \                     ??zclGeneral_RegisterCmdCallbacks_5:
   \   00007B   EA           MOV     A,R2
   \   00007C   FC           MOV     R4,A
   \   00007D   EB           MOV     A,R3
   \                     ??zclGeneral_RegisterCmdCallbacks_4:
   \   00007E   FD           MOV     R5,A
   \   00007F   8C82         MOV     DPL,R4
   \   000081   8D83         MOV     DPH,R5
   \   000083   E0           MOVX    A,@DPTR
   \   000084   FA           MOV     R2,A
   \   000085   A3           INC     DPTR
   \   000086   E0           MOVX    A,@DPTR
   \   000087   FB           MOV     R3,A
   \   000088   EA           MOV     A,R2
   \   000089   4B           ORL     A,R3
   \   00008A   70EF         JNZ     ??zclGeneral_RegisterCmdCallbacks_5
    235          
    236              // Put new item at end of list
    237              pLoop->next = pNewItem;
   \   00008C   8C82         MOV     DPL,R4
   \   00008E   8D83         MOV     DPH,R5
   \                     ??zclGeneral_RegisterCmdCallbacks_3:
   \   000090   E8           MOV     A,R0
   \   000091   F0           MOVX    @DPTR,A
   \   000092   A3           INC     DPTR
   \   000093   E9           MOV     A,R1
   \   000094   F0           MOVX    @DPTR,A
    238            }
    239          
    240            return ( ZSuccess );
   \   000095   7900         MOV     R1,#0x0
   \                     ??zclGeneral_RegisterCmdCallbacks_2:
   \   000097                REQUIRE ?Subroutine0
   \   000097                ; // Fall through to label ?Subroutine0
    241          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    242          
    243          #ifdef ZCL_IDENTIFY
    244          /*********************************************************************
    245           * @fn      zclGeneral_SendIdentify
    246           *
    247           * @brief   Call to send out an Identify Command
    248           *
    249           * @param   srcEP - Sending application's endpoint
    250           * @param   dstAddr - where you want the message to go
    251           * @param   identifyTime - how long the device will continue to identify itself (in seconds)
    252           * @param   seqNum - identification number for the transaction
    253           *
    254           * @return  ZStatus_t
    255           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    256          ZStatus_t zclGeneral_SendIdentify( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentify:
    257                                uint16 identifyTime, uint8 disableDefaultRsp, uint8 seqNum )
    258          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   740C         MOV     A,#0xc
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F9           MOV     R1,A
   \   000013   740D         MOV     A,#0xd
   \   000015   12....       LCALL   ?XSTACK_DISP0_8
   \   000018   12....       LCALL   ?Subroutine3 & 0xFFFF
    259            uint8 buf[2];
    260          
    261            buf[0] = LO_UINT16( identifyTime );
    262            buf[1] = HI_UINT16( identifyTime );
   \                     ??CrossCallReturnLabel_2:
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   12....       LCALL   ?Subroutine2 & 0xFFFF
    263          
    264            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    265                                    COMMAND_IDENTIFY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    266                                    disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_0:
   \   000021   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000024   75..02       MOV     ?V0 + 0,#0x2
   \   000027   75..00       MOV     ?V0 + 1,#0x0
   \   00002A   78..         MOV     R0,#?V0 + 0
   \   00002C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002F   EF           MOV     A,R7
   \   000030   F5..         MOV     ?V0 + 0,A
   \   000032   78..         MOV     R0,#?V0 + 0
   \   000034   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000037   E4           CLR     A
   \   000038   F5..         MOV     ?V0 + 0,A
   \   00003A   78..         MOV     R0,#?V0 + 0
   \   00003C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003F   E9           MOV     A,R1
   \   000040   F5..         MOV     ?V0 + 0,A
   \   000042   78..         MOV     R0,#?V0 + 0
   \   000044   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000047   75..00       MOV     ?V0 + 0,#0x0
   \   00004A   78..         MOV     R0,#?V0 + 0
   \   00004C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00004F   75..01       MOV     ?V0 + 0,#0x1
   \   000052                REQUIRE ?Subroutine1
   \   000052                ; // Fall through to label ?Subroutine1

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   78..         MOV     R0,#?V0 + 0
   \   000002   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000005   75..00       MOV     ?V0 + 0,#0x0
   \   000008   78..         MOV     R0,#?V0 + 0
   \   00000A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00000D   7C03         MOV     R4,#0x3
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   EE           MOV     A,R6
   \   000012   F9           MOV     R1,A
   \   000013   12....       LCALL   ??zcl_SendCommand?relay
   \   000016   740B         MOV     A,#0xb
   \   000018   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001B   7402         MOV     A,#0x2
   \   00001D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000020                REQUIRE ??Subroutine10_0
   \   000020                ; // Fall through to label ??Subroutine10_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine10_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FF           MOV     R7,A
   \   000002   EC           MOV     A,R4
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   7401         MOV     A,#0x1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   ED           MOV     A,R5
   \   000001   F0           MOVX    @DPTR,A
   \   000002                ; Setup parameters for call to function zcl_SendCommand
   \   000002                ; Setup parameters for call to function zcl_SendCommand
   \   000002   85..82       MOV     DPL,?XSP + 0
   \   000005   85..83       MOV     DPH,?XSP + 1
   \   000008   8582..       MOV     ?V0 + 0,DPL
   \   00000B   8583..       MOV     ?V0 + 1,DPH
   \   00000E   78..         MOV     R0,#?V0 + 0
   \   000010   22           RET
    267          }
    268          
    269          /*********************************************************************
    270           * @fn      zclGeneral_SendIdentifyQueryResponse
    271           *
    272           * @brief   Call to send out an Identify Query Response Command
    273           *
    274           * @param   srcEP - Sending application's endpoint
    275           * @param   dstAddr - where you want the message to go
    276           * @param   timeout - how long the device will continue to identify itself (in seconds)
    277           * @param   seqNum - identification number for the transaction
    278           *
    279           * @return  ZStatus_t
    280           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    281          ZStatus_t zclGeneral_SendIdentifyQueryResponse( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyQueryResponse:
    282                                      uint16 timeout, uint8 disableDefaultRsp, uint8 seqNum )
    283          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   740C         MOV     A,#0xc
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F9           MOV     R1,A
   \   000013   740D         MOV     A,#0xd
   \   000015   12....       LCALL   ?XSTACK_DISP0_8
   \   000018   12....       LCALL   ?Subroutine3 & 0xFFFF
    284            uint8 buf[2];
    285          
    286            buf[0] = LO_UINT16( timeout );
    287            buf[1] = HI_UINT16( timeout );
   \                     ??CrossCallReturnLabel_3:
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   12....       LCALL   ?Subroutine2 & 0xFFFF
    288          
    289            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    290                                    COMMAND_IDENTIFY_QUERY_RSP, TRUE,
    291                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_1:
   \   000021   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000024   75..02       MOV     ?V0 + 0,#0x2
   \   000027   75..00       MOV     ?V0 + 1,#0x0
   \   00002A   78..         MOV     R0,#?V0 + 0
   \   00002C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002F   EF           MOV     A,R7
   \   000030   F5..         MOV     ?V0 + 0,A
   \   000032   78..         MOV     R0,#?V0 + 0
   \   000034   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000037   E4           CLR     A
   \   000038   F5..         MOV     ?V0 + 0,A
   \   00003A   78..         MOV     R0,#?V0 + 0
   \   00003C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003F   E9           MOV     A,R1
   \   000040   F5..         MOV     ?V0 + 0,A
   \   000042   78..         MOV     R0,#?V0 + 0
   \   000044   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000047   75..01       MOV     ?V0 + 0,#0x1
   \   00004A   78..         MOV     R0,#?V0 + 0
   \   00004C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00004F   80..         SJMP    ?Subroutine1
    292          }
    293          #endif // ZCL_IDENTIFY
    294          
    295          #ifdef ZCL_GROUPS
    296          /*********************************************************************
    297           * @fn      zclGeneral_SendGroupRequest
    298           *
    299           * @brief   Send a Group Request to a device.  You can also use the
    300           *          appropriate macro.
    301           *
    302           * @param   srcEP - Sending Apps endpoint
    303           * @param   dstAddr - where to send the request
    304           * @param   cmd - one of the following:
    305           *              COMMAND_GROUP_VIEW
    306           *              COMMAND_GROUP_REMOVE
    307           * @param   groupID -
    308           *
    309           * @return  ZStatus_t
    310           */
    311          ZStatus_t zclGeneral_SendGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
    312                               uint8 cmd, uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    313          {
    314            uint8 buf[2];
    315          
    316            buf[0] = LO_UINT16( groupID );
    317            buf[1] = HI_UINT16( groupID );
    318          
    319            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    320                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    321                                      disableDefaultRsp, 0, seqNum, 2, buf ) );
    322          }
    323          
    324          /*********************************************************************
    325           * @fn      zclGeneral_SendAddGroupRequest
    326           *
    327           * @brief   Send the Add Group Request to a device
    328           *
    329           * @param   srcEP - Sending Apps endpoint
    330           * @param   dstAddr - where to send the request
    331           * @param   cmd - one of the following:
    332           *                COMMAND_GROUP_ADD
    333           *                COMMAND_GROUP_ADD_IF_IDENTIFYING
    334           * @param   groupID - pointer to the group structure
    335           * @param   groupName - pointer to Group Name.  This is a Zigbee
    336           *          string data type, so the first byte is the length of the
    337           *          name (in bytes), then the name.
    338           *
    339           * @return  ZStatus_t
    340           */
    341          ZStatus_t zclGeneral_SendAddGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
    342                                                    uint8 cmd, uint16 groupID, uint8 *groupName,
    343                                                    uint8 disableDefaultRsp, uint8 seqNum )
    344          {
    345            uint8 *buf;
    346            uint8 *pBuf;
    347            uint8 len;
    348            ZStatus_t status;
    349          
    350            len = 2;    // Group ID
    351            len += groupName[0] + 1;  // String + 1 for length
    352          
    353            buf = osal_mem_alloc( len );
    354            if ( buf )
    355            {
    356              pBuf = buf;
    357              *pBuf++ = LO_UINT16( groupID );
    358              *pBuf++ = HI_UINT16( groupID );
    359              *pBuf++ = groupName[0]; // string length
    360              osal_memcpy( pBuf, &(groupName[1]), groupName[0] );
    361          
    362              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    363                                        cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    364                                        disableDefaultRsp, 0, seqNum, len, buf );
    365              osal_mem_free( buf );
    366            }
    367            else
    368              status = ZMemError;
    369          
    370            return ( status );
    371          }
    372          
    373          /*********************************************************************
    374           * @fn      zclGeneral_SendGroupGetMembershipRequest
    375           *
    376           * @brief   Send a Get Group Membership (Resposne) Command to a device
    377           *
    378           * @param   srcEP - Sending Apps endpoint
    379           * @param   dstAddr - where to send the request
    380           * @param   cmd - one of the following:
    381           *                COMMAND_GROUP_GET_MEMBERSHIP
    382           *                COMMAND_GROUP_GET_MEMBERSHIP_RSP
    383           * @param   groupID - pointer to the group structure
    384           * @param   groupName - pointer to Group Name.  This is a Zigbee
    385           *          string data type, so the first byte is the length of the
    386           *          name (in bytes), then the name.
    387           *
    388           * @return  ZStatus_t
    389           */
    390          ZStatus_t zclGeneral_SendGroupGetMembershipRequest( uint8 srcEP, afAddrType_t *dstAddr,
    391                                        uint8 cmd, uint8 rspCmd, uint8 direction, uint8 capacity,
    392                                        uint8 grpCnt, uint16 *grpList, uint8 disableDefaultRsp, uint8 seqNum )
    393          {
    394            uint8 *buf;
    395            uint8 *pBuf;
    396            uint8 len = 0;
    397            uint8 i;
    398            ZStatus_t status;
    399          
    400            if ( rspCmd )
    401              len++;  // Capacity
    402          
    403            len++;  // Group Count
    404            len += sizeof ( uint16 ) * grpCnt;  // Group List
    405          
    406            buf = osal_mem_alloc( len );
    407            if ( buf )
    408            {
    409              pBuf = buf;
    410              if ( rspCmd )
    411                *pBuf++ = capacity;
    412          
    413              *pBuf++ = grpCnt;
    414              for ( i = 0; i < grpCnt; i++ )
    415              {
    416                *pBuf++ = LO_UINT16( grpList[i] );
    417                *pBuf++ = HI_UINT16( grpList[i] );
    418              }
    419          
    420              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    421                                        cmd, TRUE, direction,
    422                                        disableDefaultRsp, 0, seqNum, len, buf );
    423              osal_mem_free( buf );
    424            }
    425            else
    426              status = ZMemError;
    427          
    428            return ( status );
    429          }
    430          
    431          /*********************************************************************
    432           * @fn      zclGeneral_SendGroupResponse
    433           *
    434           * @brief   Send Group Response (not Group View Response)
    435           *
    436           * @param   srcEP - Sending application's endpoint
    437           * @param   dstAddr - where you want the message to go
    438           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    439           * @param   status - group command status
    440           * @param   groupID - what group
    441           *
    442           * @return  ZStatus_t
    443           */
    444          ZStatus_t zclGeneral_SendGroupResponse( uint8 srcEP, afAddrType_t *dstAddr,
    445                                                  uint8 cmd, uint8 status, uint16 groupID,
    446                                                  uint8 disableDefaultRsp, uint8 seqNum )
    447          {
    448            uint8 buf[3];
    449          
    450            buf[0] = status;
    451            buf[1] = LO_UINT16( groupID );
    452            buf[2] = HI_UINT16( groupID );
    453          
    454            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    455                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    456                                    disableDefaultRsp, 0, seqNum, 3, buf );
    457          }
    458          
    459          /*********************************************************************
    460           * @fn      zclGeneral_SendGroupViewResponse
    461           *
    462           * @brief   Call to send Group Response Command
    463           *
    464           * @param   srcEP - Sending application's endpoint
    465           * @param   dstAddr - where you want the message to go
    466           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    467           * @param   status - group command status
    468           * @param   grp - group info
    469           *
    470           * @return  ZStatus_t
    471           */
    472          ZStatus_t zclGeneral_SendGroupViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
    473                           uint8 status, aps_Group_t *grp, uint8 disableDefaultRsp, uint8 seqNum )
    474          {
    475            uint8 *buf;
    476            uint8 len;
    477            ZStatus_t stat;
    478          
    479            len = 1 + 2; // Status + Group ID
    480          
    481            if ( status == ZCL_STATUS_SUCCESS )
    482              len += grp->name[0] + 1;  // String + 1 for length
    483          
    484            buf = osal_mem_alloc( len );
    485            if ( buf )
    486            {
    487              buf[0] = status;
    488              buf[1] = LO_UINT16( grp->ID );
    489              buf[2] = HI_UINT16( grp->ID );
    490          
    491              if ( status == ZCL_STATUS_SUCCESS )
    492              {
    493                buf[3] = grp->name[0]; // string length
    494                osal_memcpy( &buf[4], (&grp->name[1]), grp->name[0] );
    495              }
    496          
    497              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    498                                      COMMAND_GROUP_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    499                                      disableDefaultRsp, 0, seqNum, len, buf );
    500              osal_mem_free( buf );
    501            }
    502            else
    503              stat = ZMemError;
    504          
    505            return ( stat );
    506          }
    507          #endif // ZCL_GROUPS
    508          
    509          #ifdef ZCL_SCENES
    510          /*********************************************************************
    511           * @fn      zclGeneral_SendAddScene
    512           *
    513           * @brief   Send the Add Scene Request to a device
    514           *
    515           * @param   srcEP - Sending Apps endpoint
    516           * @param   dstAddr - where to send the request
    517           * @param   scene - pointer to the scene structure
    518           *
    519           * @return  ZStatus_t
    520           */
    521          ZStatus_t zclGeneral_SendAddScene( uint8 srcEP, afAddrType_t *dstAddr,
    522                                zclGeneral_Scene_t *scene, uint8 disableDefaultRsp, uint8 seqNum )
    523          {
    524            uint8 *buf;
    525            uint8 *pBuf;
    526            uint8 len;
    527            ZStatus_t status;
    528          
    529            len = 2 + 1 + 2;    // Group ID + Scene ID + transition time
    530            len += scene->name[0] + 1; // String + 1 for length
    531          
    532            // Add something for the extension field length
    533            len += scene->extLen;
    534          
    535            buf = osal_mem_alloc( len );
    536            if ( buf )
    537            {
    538              pBuf = buf;
    539              *pBuf++ = LO_UINT16( scene->groupID );
    540              *pBuf++ = HI_UINT16( scene->groupID );
    541              *pBuf++ = scene->ID;
    542              *pBuf++ = LO_UINT16( scene->transTime );
    543              *pBuf++ = HI_UINT16( scene->transTime );
    544              *pBuf++ = scene->name[0]; // string length
    545              osal_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    546              pBuf += scene->name[0]; // move pass name
    547          
    548              // Add the extension fields
    549              if ( scene->extLen > 0 )
    550                osal_memcpy( pBuf, scene->extField, scene->extLen );
    551          
    552              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    553                                        COMMAND_SCENE_ADD, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    554                                        disableDefaultRsp, 0, seqNum, len, buf );
    555              osal_mem_free( buf );
    556            }
    557            else
    558              status = ZMemError;
    559          
    560            return ( status );
    561          }
    562          
    563          /*********************************************************************
    564           * @fn      zclGeneral_SendSceneRequest
    565           *
    566           * @brief   Send a Scene Request to a device.  You can also use the
    567           *          appropriate macro.
    568           *
    569           * @param   srcEP - Sending Apps endpoint
    570           * @param   dstAddr - where to send the request
    571           * @param   cmd - one of the following:
    572           *              COMMAND_SCENE_VIEW
    573           *              COMMAND_SCENE_REMOVE
    574           *              COMMAND_SCENE_REMOVE_ALL
    575           *              COMMAND_SCENE_STORE
    576           *              COMMAND_SCENE_RECALL
    577           *              COMMAND_SCENE_GET_MEMBERSHIP
    578           * @param   groupID - group ID
    579           * @param   sceneID - scene ID (not applicable to COMMAND_SCENE_REMOVE_ALL and
    580           *                    COMMAND_SCENE_GET_MEMBERSHIP)
    581           * @return  ZStatus_t
    582           */
    583          ZStatus_t zclGeneral_SendSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
    584                                                 uint8 cmd, uint16 groupID, uint8 sceneID,
    585                                                 uint8 disableDefaultRsp, uint8 seqNum )
    586          {
    587            uint8 buf[3];
    588            uint8 len = 2;
    589          
    590            buf[0] = LO_UINT16( groupID );
    591            buf[1] = HI_UINT16( groupID );
    592          
    593            if ( cmd != COMMAND_SCENE_REMOVE_ALL && cmd != COMMAND_SCENE_GET_MEMBERSHIP )
    594            {
    595              buf[2] = sceneID;
    596              len++;
    597            }
    598          
    599            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    600                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    601                                      disableDefaultRsp, 0, seqNum, len, buf ) );
    602          }
    603          
    604          /*********************************************************************
    605           * @fn      zclGeneral_SendSceneResponse
    606           *
    607           * @brief   Send Group Response (not Group View Response)
    608           *
    609           * @param   srcEP - Sending application's endpoint
    610           * @param   dstAddr - where you want the message to go
    611           * @param   cmd - either COMMAND_SCENE_ADD_RSP, COMMAND_SCENE_REMOVE_RSP
    612           *                COMMAND_SCENE_STORE_RSP, or COMMAND_SCENE_REMOVE_ALL_RSP
    613           * @param   status - scene command status
    614           * @param   groupID - what group
    615           * @param   sceneID - what scene (not applicable to COMMAND_SCENE_REMOVE_ALL_RSP)
    616           *
    617           * @return  ZStatus_t
    618           */
    619          ZStatus_t zclGeneral_SendSceneResponse( uint8 srcEP, afAddrType_t *dstAddr,
    620                                            uint8 cmd, uint8 status, uint16 groupID,
    621                                            uint8 sceneID, uint8 disableDefaultRsp, uint8 seqNum )
    622          {
    623            uint8 buf[4];
    624            uint8 len = 1 + 2; // Status + Group ID
    625          
    626            buf[0] = status;
    627            buf[1] = LO_UINT16( groupID );
    628            buf[2] = HI_UINT16( groupID );
    629          
    630            if ( cmd != COMMAND_SCENE_REMOVE_ALL_RSP )
    631            {
    632              buf[3] = sceneID;
    633              len++;
    634            }
    635          
    636            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    637                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    638                                    disableDefaultRsp, 0, seqNum, len, buf );
    639          }
    640          
    641          /*********************************************************************
    642           * @fn      zclGeneral_SendSceneViewResponse
    643           *
    644           * @brief   Call to send Scene Response Command
    645           *
    646           * @param   srcEP - Sending application's endpoint
    647           * @param   dstAddr - where you want the message to go
    648           * @param   status - scene command status
    649           * @param   scene - scene info
    650           *
    651           * @return  ZStatus_t
    652           */
    653          ZStatus_t zclGeneral_SendSceneViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
    654                                                 uint8 status, zclGeneral_Scene_t *scene,
    655                                                 uint8 disableDefaultRsp, uint8 seqNum )
    656          {
    657            uint8 *buf;
    658            uint8 *pBuf;
    659            uint8 len = 1 + 2 + 1; // Status + Group ID + Scene ID
    660            ZStatus_t stat;
    661          
    662            if ( status == ZCL_STATUS_SUCCESS )
    663            {
    664              len += 2; // Transition Time
    665              len += scene->name[0] + 1; // string + 1 for length
    666          
    667              // Add something for the extension field length
    668              len += scene->extLen;
    669            }
    670          
    671            buf = osal_mem_alloc( len );
    672            if ( buf )
    673            {
    674              pBuf = buf;
    675              *pBuf++ = status;
    676              *pBuf++ = LO_UINT16( scene->groupID );
    677              *pBuf++ = HI_UINT16( scene->groupID );
    678              *pBuf++ = scene->ID;
    679              if ( status == ZCL_STATUS_SUCCESS )
    680              {
    681                *pBuf++ = LO_UINT16( scene->transTime );
    682                *pBuf++ = HI_UINT16( scene->transTime );
    683                *pBuf++ = scene->name[0]; // string length
    684                if ( scene->name[0] != 0 )
    685                {
    686                  osal_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    687                  pBuf += scene->name[0]; // move pass name
    688                }
    689          
    690                // Add the extension fields
    691                if ( scene->extLen > 0 )
    692                  osal_memcpy( pBuf, scene->extField, scene->extLen );
    693              }
    694          
    695              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    696                                      COMMAND_SCENE_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    697                                      disableDefaultRsp, 0, seqNum, len, buf );
    698              osal_mem_free( buf );
    699            }
    700            else
    701              stat = ZMemError;
    702          
    703            return ( stat );
    704          }
    705          
    706          /*********************************************************************
    707           * @fn      zclGeneral_SendSceneGetMembershipResponse
    708           *
    709           * @brief   Call to send Scene Get Membership Response Command
    710           *
    711           * @param   srcEP - Sending application's endpoint
    712           * @param   dstAddr - where you want the message to go
    713           * @param   status - scene command status
    714           * @param   capacity - remaining capacity of the scene table
    715           * @param   sceneCnt - number of scenes in the scene list
    716           * @param   sceneList - list of scene IDs
    717           * @param   groupID - group ID that scene belongs to
    718           * @param   seqNum - sequence number
    719           *
    720           * @return  ZStatus_t
    721           */
    722          ZStatus_t zclGeneral_SendSceneGetMembershipResponse( uint8 srcEP, afAddrType_t *dstAddr,
    723                                 uint8 status, uint8 capacity, uint8 sceneCnt, uint8 *sceneList,
    724                                 uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    725          {
    726            uint8 *buf;
    727            uint8 *pBuf;
    728            uint8 len = 1 + 1 + 2; // Status + Capacity + Group ID;
    729            uint8 i;
    730            ZStatus_t stat;
    731          
    732            if ( status == ZCL_STATUS_SUCCESS )
    733            {
    734              len++; // Scene Count
    735              len += sceneCnt; // Scene List (Scene ID is a single octet)
    736            }
    737          
    738            buf = osal_mem_alloc( len );
    739            if ( buf )
    740            {
    741              pBuf = buf;
    742              *pBuf++ = status;
    743              *pBuf++ = capacity;
    744              *pBuf++ = LO_UINT16( groupID );
    745              *pBuf++ = HI_UINT16( groupID );
    746              if ( status == ZCL_STATUS_SUCCESS )
    747              {
    748                *pBuf++ = sceneCnt;
    749                for ( i = 0; i < sceneCnt; i++ )
    750                  *pBuf++ = sceneList[i];
    751              }
    752          
    753              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    754                                      COMMAND_SCENE_GET_MEMBERSHIP_RSP, TRUE,
    755                                      ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
    756              osal_mem_free( buf );
    757            }
    758            else
    759              stat = ZMemError;
    760          
    761            return ( stat );
    762          }
    763          #endif // ZCL_SCENES
    764          
    765          #ifdef ZCL_LEVEL_CTRL
    766          /*********************************************************************
    767           * @fn      zclGeneral_SendLevelControlMoveToLevelRequest
    768           *
    769           * @brief   Call to send out a Level Control Request. You can also use
    770           *          the appropriate macro.
    771           *
    772           * @param   srcEP - Sending application's endpoint
    773           * @param   dstAddr - where you want the message to go
    774           * @param   cmd - one of the following:
    775           *              COMMAND_LEVEL_MOVE_TO_LEVEL or
    776           *              COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF
    777           * @param   level - what level to move to
    778           * @param   transitionTime - how long to take to get to the level (in seconds)
    779           *
    780           * @return  ZStatus_t
    781           */
    782          ZStatus_t zclGeneral_SendLevelControlMoveToLevelRequest( uint8 srcEP, afAddrType_t *dstAddr,
    783                                                                   uint8 cmd, uint8 level, uint16 transTime,
    784                                                                   uint8 disableDefaultRsp, uint8 seqNum )
    785          {
    786            uint8 buf[3];
    787          
    788            buf[0] = level;
    789            buf[1] = LO_UINT16( transTime );
    790            buf[2] = HI_UINT16( transTime );
    791          
    792            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
    793                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    794                                    disableDefaultRsp, 0, seqNum, 3, buf );
    795          }
    796          
    797          /*********************************************************************
    798           * @fn      zclGeneral_SendLevelControlMoveRequest
    799           *
    800           * @brief   Call to send out a Level Control Request. You can also use
    801           *          the appropriate macro.
    802           *
    803           * @param   srcEP - Sending application's endpoint
    804           * @param   dstAddr - where you want the message to go
    805           * @param   cmd - one of the following:
    806           *              COMMAND_LEVEL_MOVE or
    807           *              COMMAND_LEVEL_MOVE_WITH_ON_OFF
    808           * @param   moveMode - LEVEL_MOVE_UP or
    809           *                     LEVEL_MOVE_DOWN
    810           * @param   rate - number of steps to take per second
    811           *
    812           * @return  ZStatus_t
    813           */
    814          ZStatus_t zclGeneral_SendLevelControlMoveRequest( uint8 srcEP, afAddrType_t *dstAddr,
    815                                                            uint8 cmd, uint8 moveMode, uint8 rate,
    816                                                            uint8 disableDefaultRsp, uint8 seqNum )
    817          {
    818            uint8 buf[2];
    819          
    820            buf[0] = moveMode;
    821            buf[1] = rate;
    822          
    823            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
    824                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    825                                    disableDefaultRsp, 0, seqNum, 2, buf );
    826          }
    827          
    828          /*********************************************************************
    829           * @fn      zclGeneral_SendLevelControlStepRequest
    830           *
    831           * @brief   Call to send out a Level Control Request. You can also use
    832           *          the appropriate macro.
    833           *
    834           * @param   srcEP - Sending application's endpoint
    835           * @param   dstAddr - where you want the message to go
    836           * @param   cmd - one of the following:
    837           *              COMMAND_LEVEL_STEP
    838           *              COMMAND_LEVEL_STEP_WITH_ON_OFF
    839           * @param   stepMode - LEVEL_STEP_UP or
    840           *                     LEVEL_STEP_DOWN
    841           * @param   amount - number of levels to step
    842           * @param   transitionTime - time, in 1/10ths of a second, to take to perform the step
    843           *
    844           * @return  ZStatus_t
    845           */
    846          ZStatus_t zclGeneral_SendLevelControlStepRequest( uint8 srcEP, afAddrType_t *dstAddr,
    847                                   uint8 cmd, uint8 stepMode, uint8 stepSize, uint16 transTime,
    848                                   uint8 disableDefaultRsp, uint8 seqNum )
    849          {
    850            uint8 buf[4];
    851          
    852            buf[0] = stepMode;
    853            buf[1] = stepSize;
    854            buf[2] = LO_UINT16( transTime );
    855            buf[3] = HI_UINT16( transTime );
    856          
    857            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
    858                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    859                                    disableDefaultRsp, 0, seqNum, 4, buf );
    860          }
    861          #endif // ZCL_LEVEL_CTRL
    862          
    863          #ifdef ZCL_ALARMS
    864          /*********************************************************************
    865           * @fn      zclGeneral_SendAlarmRequest
    866           *
    867           * @brief   Call to send out an Alarm Request Command
    868           *
    869           * @param   srcEP - Sending application's endpoint
    870           * @param   dstAddr - where you want the message to go
    871           * @param   cmd - either COMMAND_ALARMS_RESET or COMMAND_ALARMS_ALARM
    872           * @param   alarmCode - code for the cause of the alarm
    873           * @param   clusterID - cluster whose attribute generate the alarm
    874           *
    875           * @return  ZStatus_t
    876           */
    877          ZStatus_t zclGeneral_SendAlarmRequest( uint8 srcEP, afAddrType_t *dstAddr,
    878                                                 uint8 cmd, uint8 alarmCode, uint16 clusterID,
    879                                                 uint8 disableDefaultRsp, uint8 seqNum )
    880          {
    881            uint8 buf[3];
    882          
    883            buf[0] = alarmCode;
    884            buf[1] = LO_UINT16( clusterID );
    885            buf[2] = HI_UINT16( clusterID );
    886          
    887            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
    888                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    889                                    disableDefaultRsp, 0, seqNum, 3, buf );
    890          }
    891          
    892          /*********************************************************************
    893           * @fn      zclGeneral_SendAlarmGetRespnose
    894           *
    895           * @brief   Call to send out an Alarm Get Response Command
    896           *
    897           * @param   srcEP - Sending application's endpoint
    898           * @param   dstAddr - where you want the message to go
    899           * @param   status - SUCCESS or NOT_FOUND
    900           * @param   alarmCode - code for the cause of the alarm
    901           * @param   clusterID - cluster whose attribute generate the alarm
    902           * @param   timeStamp - time at which the alarm occured
    903           *
    904           * @return  ZStatus_t
    905           */
    906          ZStatus_t zclGeneral_SendAlarmGetRespnose( uint8 srcEP, afAddrType_t *dstAddr,
    907                                        uint8 status, uint8 alarmCode, uint16 clusterID,
    908                                        uint32 timeStamp, uint8 disableDefaultRsp, uint8 seqNum )
    909          {
    910            uint8 buf[8];
    911            uint8 len = 1; // Status
    912          
    913            buf[0] = status;
    914            if ( status == ZCL_STATUS_SUCCESS )
    915            {
    916              len += 1 + 2 + 4; // Alarm code + Cluster ID + Time stamp
    917              buf[1] = alarmCode;
    918              buf[2] = LO_UINT16( clusterID );
    919              buf[3] = HI_UINT16( clusterID );
    920              osal_buffer_uint32( &buf[4], timeStamp );
    921            }
    922          
    923            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
    924                                    COMMAND_ALARMS_GET_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    925                                    disableDefaultRsp, 0, seqNum, len, buf );
    926          }
    927          
    928          #ifdef SE_UK_EXT
    929          /*********************************************************************
    930           * @fn      zclGeneral_SendAlarmGetEventLog
    931           *
    932           * @brief   Call to send out an Alarm Get Event Log Command
    933           *
    934           * @param   srcEP - Sending application's endpoint
    935           * @param   dstAddr - where you want the message to go
    936           * @param   pEventLog - pointer to Get Event Log Command
    937           * @param   disableDefaultRsp - disable default response
    938           * @param   seqNum - ZCL sequence number
    939           *
    940           * @return  ZStatus_t
    941           */
    942          ZStatus_t zclGeneral_SendAlarmGetEventLog( uint8 srcEP, afAddrType_t *dstAddr,
    943                                                     zclGetEventLog_t *pEventLog,
    944                                                     uint8 disableDefaultRsp, uint8 seqNum )
    945          {
    946            uint8 buf[10];
    947          
    948            buf[0] = pEventLog->logID;
    949            osal_buffer_uint32( &buf[1], pEventLog->startTime );
    950            osal_buffer_uint32( &buf[5], pEventLog->endTime );
    951            buf[9] = pEventLog->numEvents;
    952            
    953            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
    954                                    COMMAND_ALARMS_GET_EVENT_LOG, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    955                                    disableDefaultRsp, 0, seqNum, 10, buf );
    956          }
    957          
    958          /*********************************************************************
    959           * @fn      zclGeneral_SendAlarmPublishEventLog
    960           *
    961           * @brief   Call to send out an Alarm Publish Event Log Command
    962           *
    963           * @param   srcEP - Sending application's endpoint
    964           * @param   dstAddr - where you want the message to go
    965           * @param   pEventLog - pointer to Publish Event Log Command
    966           * @param   disableDefaultRsp - disable default response
    967           * @param   seqNum - ZCL sequence number
    968           *
    969           * @return  ZStatus_t
    970           */
    971          ZStatus_t zclGeneral_SendAlarmPublishEventLog( uint8 srcEP, afAddrType_t *dstAddr,
    972                                                         zclPublishEventLog_t *pEventLog,
    973                                                         uint8 disableDefaultRsp, uint8 seqNum )
    974          {
    975            uint8 *buf;
    976            uint8 *pBuf;
    977            uint8 bufLen;
    978            
    979            // Log ID + Command Index + Total Commands + (numSubLogs * ( Event ID + Event Time))
    980            bufLen = 1 + 1 + 1 + (pEventLog->numSubLogs * (1 + 4));
    981            
    982            buf = osal_mem_alloc( bufLen );
    983            if ( buf == NULL )
    984            {
    985              return (ZMemError);
    986            }
    987            
    988            pBuf = buf;
    989            *pBuf++ = pEventLog->logID;
    990            *pBuf++ = pEventLog->cmdIndex;
    991            *pBuf++ = pEventLog->totalCmds;
    992            
    993            for ( uint8 i = 0; i < pEventLog->numSubLogs; i++ )
    994            {
    995              zclEventLogPayload_t *pLogs = &(pEventLog->pLogs[i]);
    996              
    997              *pBuf++ = pLogs->eventId;
    998              pBuf = osal_buffer_uint32( pBuf, pLogs->eventTime );
    999            }
   1000            
   1001            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
   1002                                    COMMAND_ALARMS_PUBLISH_EVENT_LOG, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
   1003                                    disableDefaultRsp, 0, seqNum, bufLen, buf );
   1004          }
   1005          #endif // SE_UK_EXT
   1006          #endif // ZCL_ALARMS
   1007          
   1008          #ifdef ZCL_LOCATION
   1009          /*********************************************************************
   1010           * @fn      zclGeneral_SendLocationSetAbsolute
   1011           *
   1012           * @brief   Call to send out a Set Absolute Location Command
   1013           *
   1014           * @param   srcEP - Sending application's endpoint
   1015           * @param   dstAddr - where you want the message to go
   1016           * @param   absLoc - absolute location info
   1017           *
   1018           * @return  ZStatus_t
   1019           */
   1020          ZStatus_t zclGeneral_SendLocationSetAbsolute( uint8 srcEP, afAddrType_t *dstAddr,
   1021                                                        zclLocationAbsolute_t *absLoc,
   1022                                                        uint8 disableDefaultRsp, uint8 seqNum )
   1023          {
   1024             uint8 buf[10]; // 5 fields (2 octects each)
   1025          
   1026             buf[0] = LO_UINT16( absLoc->coordinate1 );
   1027             buf[1] = HI_UINT16( absLoc->coordinate1 );
   1028             buf[2] = LO_UINT16( absLoc->coordinate2 );
   1029             buf[3] = HI_UINT16( absLoc->coordinate2 );
   1030             buf[4] = LO_UINT16( absLoc->coordinate3 );
   1031             buf[5] = HI_UINT16( absLoc->coordinate3 );
   1032             buf[6] = LO_UINT16( absLoc->power );
   1033             buf[7] = HI_UINT16( absLoc->power );
   1034             buf[8] = LO_UINT16( absLoc->pathLossExponent );
   1035             buf[9] = HI_UINT16( absLoc->pathLossExponent );
   1036          
   1037             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1038                                     COMMAND_LOCATION_SET_ABSOLUTE, TRUE,
   1039                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 10, buf );
   1040          }
   1041          
   1042          /*********************************************************************
   1043           * @fn      zclGeneral_SendLocationSetDevCfg
   1044           *
   1045           * @brief   Call to send out a Set Device Configuration Command
   1046           *
   1047           * @param   srcEP - Sending application's endpoint
   1048           * @param   dstAddr - where you want the message to go
   1049           * @param   devCfg - device configuration info
   1050           *
   1051           * @return  ZStatus_t
   1052           */
   1053          ZStatus_t zclGeneral_SendLocationSetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
   1054                                                      zclLocationDevCfg_t *devCfg,
   1055                                                      uint8 disableDefaultRsp, uint8 seqNum )
   1056          {
   1057             uint8 buf[9];  // 4 fields (2 octects each) + 1 field with 1 octect
   1058          
   1059             buf[0] = LO_UINT16( devCfg->power );
   1060             buf[1] = HI_UINT16( devCfg->power );
   1061             buf[2] = LO_UINT16( devCfg->pathLossExponent );
   1062             buf[3] = HI_UINT16( devCfg->pathLossExponent );
   1063             buf[4] = LO_UINT16( devCfg->calcPeriod );
   1064             buf[5] = HI_UINT16( devCfg->calcPeriod );
   1065             buf[6] = devCfg->numMeasurements;
   1066             buf[7] = LO_UINT16( devCfg->reportPeriod );
   1067             buf[8] = HI_UINT16( devCfg->reportPeriod );
   1068          
   1069             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1070                                     COMMAND_LOCATION_SET_DEV_CFG, TRUE,
   1071                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 9, buf );
   1072          }
   1073          
   1074          /*********************************************************************
   1075           * @fn      zclGeneral_SendLocationGetDevCfg
   1076           *
   1077           * @brief   Call to send out a Get Device Configuration Command
   1078           *
   1079           * @param   srcEP - Sending application's endpoint
   1080           * @param   dstAddr - where you want the message to go
   1081           * @param   targetAddr - device for which location parameters are being requested
   1082           *
   1083           * @return  ZStatus_t
   1084           */
   1085          ZStatus_t zclGeneral_SendLocationGetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
   1086                                 uint8 *targetAddr, uint8 disableDefaultRsp, uint8 seqNum )
   1087          {
   1088            uint8 buf[8];
   1089          
   1090            osal_cpyExtAddr( buf, targetAddr );
   1091          
   1092            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1093                                    COMMAND_LOCATION_GET_DEV_CFG, TRUE,
   1094                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 8, buf );
   1095          }
   1096          
   1097          /*********************************************************************
   1098           * @fn      zclGeneral_SendLocationGetData
   1099           *
   1100           * @brief   Call to send out a Get Location Data Command
   1101           *
   1102           * @param   srcEP - Sending application's endpoint
   1103           * @param   dstAddr - where you want the message to go
   1104           * @param   locaData - location information and channel parameters that are requested.
   1105           *
   1106           * @return  ZStatus_t
   1107           */
   1108          ZStatus_t zclGeneral_SendLocationGetData( uint8 srcEP, afAddrType_t *dstAddr,
   1109                                                    zclLocationGetData_t *locData,
   1110                                                    uint8 disableDefaultRsp, uint8 seqNum )
   1111          {
   1112            uint8 buf[10]; // bitmap (1) + number responses (1) + IEEE Address (8)
   1113            uint8 *pBuf = buf;
   1114            uint8 len = 2; // bitmap + number responses
   1115          
   1116            *pBuf  = locData->absoluteOnly;
   1117            *pBuf |= locData->recalculate << 1;
   1118            *pBuf |= locData->brdcastIndicator << 2;
   1119            *pBuf |= locData->brdcastResponse << 3;
   1120            *pBuf |= locData->compactResponse << 4;
   1121            pBuf++;  // move past the bitmap field
   1122          
   1123            *pBuf++ = locData->numResponses;
   1124          
   1125            if ( locData->brdcastIndicator == 0 )
   1126            {
   1127              osal_cpyExtAddr( pBuf, locData->targetAddr );
   1128              len += 8; // ieee addr
   1129            }
   1130          
   1131            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1132                                    COMMAND_LOCATION_GET_DATA, TRUE,
   1133                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1134          }
   1135          
   1136          /*********************************************************************
   1137           * @fn      zclGeneral_SendLocationDevCfgResponse
   1138           *
   1139           * @brief   Call to send out a Device Configuration Response Command
   1140           *
   1141           * @param   srcEP - Sending application's endpoint
   1142           * @param   dstAddr - where you want the message to go
   1143           * @param   devCfg - device's location parameters that are requested
   1144           *
   1145           * @return  ZStatus_t
   1146           */
   1147          ZStatus_t zclGeneral_SendLocationDevCfgResponse( uint8 srcEP, afAddrType_t *dstAddr,
   1148                                                           zclLocationDevCfgRsp_t *devCfg,
   1149                                                           uint8 disableDefaultRsp, uint8 seqNum )
   1150          {
   1151            uint8 buf[10]; // 4 fields (2 octects each) + 2 fields (1 octect each)
   1152            uint8 len = 1; // Status
   1153          
   1154            buf[0] = devCfg->status;
   1155            if ( devCfg->status == ZCL_STATUS_SUCCESS )
   1156            {
   1157              buf[1] = LO_UINT16( devCfg->data.power );
   1158              buf[2] = HI_UINT16( devCfg->data.power );
   1159              buf[3] = LO_UINT16( devCfg->data.pathLossExponent );
   1160              buf[4] = HI_UINT16( devCfg->data.pathLossExponent );
   1161              buf[5] = LO_UINT16( devCfg->data.calcPeriod );
   1162              buf[6] = HI_UINT16( devCfg->data.calcPeriod );
   1163              buf[7] = devCfg->data.numMeasurements;
   1164              buf[8] = LO_UINT16( devCfg->data.reportPeriod );
   1165              buf[9] = HI_UINT16( devCfg->data.reportPeriod );
   1166              len += 9;
   1167            }
   1168          
   1169            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1170                                    COMMAND_LOCATION_DEV_CFG_RSP, TRUE,
   1171                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1172          }
   1173          
   1174          /*********************************************************************
   1175           * @fn      zclGeneral_SendLocationData
   1176           *
   1177           * @brief   Call to send out location data
   1178           *
   1179           * @param   srcEP - Sending application's endpoint
   1180           * @param   dstAddr - where you want the message to go
   1181           * @param   status - indicates whether response to request was successful or not
   1182           * @param   locData - location information and channel parameters being sent
   1183           *
   1184           * @return  ZStatus_t
   1185           */
   1186          ZStatus_t zclGeneral_SendLocationData( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   1187                                                 uint8 status, zclLocationData_t *locData,
   1188                                                 uint8 disableDefaultRsp, uint8 seqNum )
   1189          {
   1190            uint8 buf[16];
   1191            uint8 *pBuf = buf;
   1192            uint8 len = 0;
   1193          
   1194            if ( cmd == COMMAND_LOCATION_DATA_RSP )
   1195            {
   1196              // Only response command includes a status field
   1197              *pBuf++ = status;
   1198              len++;
   1199            }
   1200          
   1201            if ( cmd != COMMAND_LOCATION_DATA_RSP || status == ZCL_STATUS_SUCCESS )
   1202            {
   1203              // Notification or Response with successful status
   1204              *pBuf++ = locData->type;
   1205              *pBuf++ = LO_UINT16( locData->absLoc.coordinate1 );
   1206              *pBuf++ = HI_UINT16( locData->absLoc.coordinate1 );
   1207              *pBuf++ = LO_UINT16( locData->absLoc.coordinate2 );
   1208              *pBuf++ = HI_UINT16( locData->absLoc.coordinate2 );
   1209              len += 5;
   1210          
   1211              if ( locationType2D(locData->type) == 0 )
   1212              {
   1213                // 2D location doesn't have coordinate 3
   1214                *pBuf++ = LO_UINT16( locData->absLoc.coordinate3 );
   1215                *pBuf++ = HI_UINT16( locData->absLoc.coordinate3 );
   1216                len += 2;
   1217              }
   1218          
   1219              if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1220              {
   1221                // Compact notification doesn't include these fields
   1222                *pBuf++ = LO_UINT16( locData->absLoc.power );
   1223                *pBuf++ = HI_UINT16( locData->absLoc.power );
   1224                *pBuf++ = LO_UINT16( locData->absLoc.pathLossExponent );
   1225                *pBuf++ = HI_UINT16( locData->absLoc.pathLossExponent );
   1226                len += 4;
   1227              }
   1228          
   1229              if ( locationTypeAbsolute(locData->type) == 0 )
   1230              {
   1231                // Absolute location doesn't include these fields
   1232                if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1233                {
   1234                  // Compact notification doesn't include this field
   1235                  *pBuf++ = locData->calcLoc.locationMethod;
   1236                  len++;
   1237                }
   1238          
   1239                *pBuf++ = locData->calcLoc.qualityMeasure;
   1240                *pBuf++ = LO_UINT16( locData->calcLoc.locationAge );
   1241                *pBuf++ = HI_UINT16( locData->calcLoc.locationAge );
   1242                len += 3;
   1243              }
   1244            }
   1245          
   1246            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1247                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1248                                    disableDefaultRsp, 0, seqNum, len, buf );
   1249          }
   1250          #endif // ZCL_LOCATION
   1251          
   1252          /*********************************************************************
   1253           * @fn      zclGeneral_FindCallbacks
   1254           *
   1255           * @brief   Find the callbacks for an endpoint
   1256           *
   1257           * @param   endpoint - endpoint to find the application callbacks for
   1258           *
   1259           * @return  pointer to the callbacks
   1260           */
   1261          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint )
   1262          {
   1263            zclGenCBRec_t *pCBs;
   1264          
   1265            pCBs = zclGenCBs;
   1266            while ( pCBs )
   1267            {
   1268              if ( pCBs->endpoint == endpoint )
   1269                return ( pCBs->CBs );
   1270              pCBs = pCBs->next;
   1271            }
   1272            return ( (zclGeneral_AppCallbacks_t *)NULL );
   1273          }
   1274          
   1275          /*********************************************************************
   1276           * @fn      zclGeneral_HdlIncoming
   1277           *
   1278           * @brief   Callback from ZCL to process incoming Commands specific
   1279           *          to this cluster library or Profile commands for attributes
   1280           *          that aren't in the attribute list
   1281           *
   1282           *
   1283           * @param   pInMsg - pointer to the incoming message
   1284           *
   1285           * @return  ZStatus_t
   1286           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1287          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlIncoming:
   1288          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1289            ZStatus_t stat = ZSuccess;
   1290          
   1291          #if defined ( INTER_PAN )
   1292            if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
   1293              return ( stat ); // Cluster not supported thru Inter-PAN
   1294          #endif
   1295            if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   5403         ANL     A,#0x3
   \   00000E   6401         XRL     A,#0x1
   \   000010   700A         JNZ     ??zclGeneral_HdlIncoming_0
   1296            {
   1297              // Is this a manufacturer specific command?
   1298              if ( pInMsg->hdr.fc.manuSpecific == 0 )
   \   000012   E8           MOV     A,R0
   \   000013   5404         ANL     A,#0x4
   \   000015   7005         JNZ     ??zclGeneral_HdlIncoming_0
   1299              {
   1300                stat = zclGeneral_HdlInSpecificCommands( pInMsg );
   \   000017                ; Setup parameters for call to function zclGeneral_HdlInSpecificCommands
   \   000017   12....       LCALL   ??zclGeneral_HdlInSpecificCommands?relay
   \   00001A   8002         SJMP    ??zclGeneral_HdlIncoming_1
   1301              }
   1302              else
   1303              {
   1304                // We don't support any manufacturer specific command.
   1305                stat = ZFailure;
   \                     ??zclGeneral_HdlIncoming_0:
   \   00001C   7901         MOV     R1,#0x1
   1306              }
   1307            }
   1308            else
   1309            {
   1310              // Handle all the normal (Read, Write...) commands -- should never get here
   1311              stat = ZFailure;
   1312            }
   1313            return ( stat );
   \                     ??zclGeneral_HdlIncoming_1:
   \   00001E   D083         POP     DPH
   \   000020   D082         POP     DPL
   \   000022   02....       LJMP    ?BRET
   1314          }
   1315          
   1316          /*********************************************************************
   1317           * @fn      zclGeneral_HdlInSpecificCommands
   1318           *
   1319           * @brief   Callback from ZCL to process incoming Commands specific
   1320           *          to this cluster library
   1321          
   1322           * @param   pInMsg - pointer to the incoming message
   1323           *
   1324           * @return  ZStatus_t
   1325           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1326          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlInSpecificCommands:
   1327          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1328            ZStatus_t stat;
   1329            zclGeneral_AppCallbacks_t *pCBs;
   1330            
   1331            // make sure endpoint exists
   1332            pCBs = zclGeneral_FindCallbacks( pInMsg->msg->endPoint );
   \   000005   8A82         MOV     DPL,R2
   \   000007   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   00000A   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   00000D   FC           MOV     R4,A
   \   00000E   90....       MOV     DPTR,#zclGenCBs
   \                     ??zclGeneral_HdlInSpecificCommands_0:
   \   000011   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000014   49           ORL     A,R1
   \   000015   6068         JZ      ??zclGeneral_HdlInSpecificCommands_1
   \   000017   8882         MOV     DPL,R0
   \   000019   8983         MOV     DPH,R1
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   6C           XRL     A,R4
   \   00001F   8882         MOV     DPL,R0
   \   000021   8983         MOV     DPH,R1
   \   000023   70EC         JNZ     ??zclGeneral_HdlInSpecificCommands_0
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   FC           MOV     R4,A
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   FD           MOV     R5,A
   1333            if ( pCBs == NULL )
   \   00002D   EC           MOV     A,R4
   \   00002E   4D           ORL     A,R5
   \   00002F   604E         JZ      ??zclGeneral_HdlInSpecificCommands_1
   1334              return ( ZFailure );
   1335          
   1336            switch ( pInMsg->msg->clusterId )
   \   000031   8E82         MOV     DPL,R6
   \   000033   8F83         MOV     DPH,R7
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F5..         MOV     ?V0 + 0,A
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   F5..         MOV     ?V0 + 1,A
   \   000040   78..         MOV     R0,#?V0 + 0
   \   000042   12....       LCALL   ?US_SWITCH_SPARSE
   \                     `?<Jumptable for zclGeneral_HdlInSpecificComman_0`:
   \   000045   0000         DW        0
   \   000047   0300         DW        3
   \   000049   0000         DW        0
   \   00004B   ....         DW        ??zclGeneral_HdlInSpecificCommands_2
   \   00004D   0300         DW        3
   \   00004F   ....         DW        ??zclGeneral_HdlInSpecificCommands_3
   \   000051   0600         DW        6
   \   000053   ....         DW        ??zclGeneral_HdlInSpecificCommands_4
   \   000055   ....         DW        ??zclGeneral_HdlInSpecificCommands_5
   1337            {
   1338          #ifdef ZCL_BASIC
   1339              case ZCL_CLUSTER_ID_GEN_BASIC:
   1340                stat = zclGeneral_ProcessInBasic( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_2:
   \   000057   8A82         MOV     DPL,R2
   \   000059   8B83         MOV     DPH,R3
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   5408         ANL     A,#0x8
   \   000060   7050         JNZ     ??zclGeneral_HdlInSpecificCommands_6
   \   000062   8A82         MOV     DPL,R2
   \   000064   8B83         MOV     DPH,R3
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   7046         JNZ     ??zclGeneral_HdlInSpecificCommands_5
   \   000070   8C82         MOV     DPL,R4
   \   000072   8D83         MOV     DPH,R5
   \   000074   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000077   E582         MOV     A,DPL
   \   000079   4583         ORL     A,DPH
   \   00007B   6035         JZ      ??zclGeneral_HdlInSpecificCommands_6
   \   00007D                ; Setup parameters for indirect call
   \   00007D   8030         SJMP    ??zclGeneral_HdlInSpecificCommands_7
   \                     ??zclGeneral_HdlInSpecificCommands_1:
   \   00007F   8035         SJMP    ??zclGeneral_HdlInSpecificCommands_5
   1341                break;
   1342          #endif // ZCL_BASIC
   1343          
   1344          #ifdef ZCL_IDENTIFY
   1345              case ZCL_CLUSTER_ID_GEN_IDENTIFY:
   1346                stat = zclGeneral_ProcessInIdentity( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_3:
   \   000081                ; Setup parameters for call to function zclGeneral_ProcessInIdentity
   \   000081   12....       LCALL   ??zclGeneral_ProcessInIdentity?relay
   1347                break;
   \   000084   8032         SJMP    ??zclGeneral_HdlInSpecificCommands_8
   1348          #endif // ZCL_IDENTIFY
   1349          
   1350          #ifdef ZCL_GROUPS
   1351              case ZCL_CLUSTER_ID_GEN_GROUPS:
   1352                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1353                  stat = zclGeneral_ProcessInGroupsServer( pInMsg );
   1354                else
   1355                  stat = zclGeneral_ProcessInGroupsClient( pInMsg, pCBs );
   1356                break;
   1357          #endif // ZCL_GROUPS
   1358          
   1359          #ifdef ZCL_SCENES
   1360              case ZCL_CLUSTER_ID_GEN_SCENES:
   1361                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1362                  stat = zclGeneral_ProcessInScenesServer( pInMsg, pCBs );
   1363                else
   1364                  stat = zclGeneral_ProcessInScenesClient( pInMsg, pCBs );
   1365                break;
   1366          #endif // ZCL_SCENES
   1367          
   1368          #ifdef ZCL_ON_OFF
   1369              case ZCL_CLUSTER_ID_GEN_ON_OFF:
   1370                stat = zclGeneral_ProcessInOnOff( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_4:
   \   000086   8A82         MOV     DPL,R2
   \   000088   8B83         MOV     DPH,R3
   \   00008A   A3           INC     DPTR
   \   00008B   A3           INC     DPTR
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   5408         ANL     A,#0x8
   \   00008F   7021         JNZ     ??zclGeneral_HdlInSpecificCommands_6
   \   000091   8C82         MOV     DPL,R4
   \   000093   8D83         MOV     DPH,R5
   \   000095   A3           INC     DPTR
   \   000096   A3           INC     DPTR
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   00009C   6014         JZ      ??zclGeneral_HdlInSpecificCommands_6
   \   00009E                ; Setup parameters for indirect call
   \   00009E   8A82         MOV     DPL,R2
   \   0000A0   8B83         MOV     DPH,R3
   \   0000A2   A3           INC     DPTR
   \   0000A3   A3           INC     DPTR
   \   0000A4   A3           INC     DPTR
   \   0000A5   A3           INC     DPTR
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   A3           INC     DPTR
   \   0000A9   E0           MOVX    A,@DPTR
   \   0000AA   F9           MOV     R1,A
   \   0000AB   8C82         MOV     DPL,R4
   \   0000AD   8D83         MOV     DPH,R5
   \                     ??zclGeneral_HdlInSpecificCommands_7:
   \   0000AF   12....       LCALL   ?CALL_IND
   \                     ??zclGeneral_HdlInSpecificCommands_6:
   \   0000B2   7900         MOV     R1,#0x0
   1371                break;
   \   0000B4   8002         SJMP    ??zclGeneral_HdlInSpecificCommands_8
   1372          #endif // ZCL_ON_OFF
   1373          
   1374          #ifdef ZCL_LEVEL_CTRL
   1375              case ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL:
   1376                stat = zclGeneral_ProcessInLevelControl( pInMsg, pCBs );
   1377                break;
   1378          #endif // ZCL_LEVEL_CTRL
   1379          
   1380          #ifdef ZCL_ALARMS
   1381              case ZCL_CLUSTER_ID_GEN_ALARMS:
   1382                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1383                  stat = zclGeneral_ProcessInAlarmsServer( pInMsg, pCBs );
   1384                else
   1385                  stat = zclGeneral_ProcessInAlarmsClient( pInMsg, pCBs );
   1386                break;
   1387          #endif // ZCL_ALARMS
   1388          
   1389          #ifdef ZCL_LOCATION
   1390              case ZCL_CLUSTER_ID_GEN_LOCATION:
   1391                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1392                  stat = zclGeneral_ProcessInLocationServer( pInMsg, pCBs );
   1393                else
   1394                  stat = zclGeneral_ProcessInLocationClient( pInMsg, pCBs );
   1395                break;
   1396          #endif // ZCL_LOCATION
   1397          
   1398              case ZCL_CLUSTER_ID_GEN_POWER_CFG:
   1399              case ZCL_CLUSTER_ID_GEN_DEVICE_TEMP_CONFIG:
   1400              case ZCL_CLUSTER_ID_GEN_ON_OFF_SWITCH_CONFIG:
   1401              case ZCL_CLUSTER_ID_GEN_TIME:
   1402              default:
   1403                stat = ZFailure;
   \                     ??zclGeneral_HdlInSpecificCommands_5:
   \   0000B6   7901         MOV     R1,#0x1
   1404                break;
   1405            }
   1406          
   1407            return ( stat );
   \                     ??zclGeneral_HdlInSpecificCommands_8:
   \   0000B8   02....       LJMP    ??Subroutine10_0 & 0xFFFF
   1408          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   8B83         MOV     DPH,R3
   \   000002   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000005   FE           MOV     R6,A
   \   000006   E9           MOV     A,R1
   \   000007   FF           MOV     R7,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   E8           MOV     A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   EE           MOV     A,R6
   \   000001   2414         ADD     A,#0x14
   \   000003   F582         MOV     DPL,A
   \   000005   EF           MOV     A,R7
   \   000006   3400         ADDC    A,#0x0
   \   000008   F583         MOV     DPH,A
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   22           RET
   1409          
   1410          #ifdef ZCL_BASIC
   1411          /*********************************************************************
   1412           * @fn      zclGeneral_ProcessInBasic
   1413           *
   1414           * @brief   Process in the received Basic Command.
   1415           *
   1416           * @param   pInMsg - pointer to the incoming message
   1417           *
   1418           * @return  ZStatus_t
   1419           */
   1420          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg,
   1421                                                      zclGeneral_AppCallbacks_t *pCBs )
   1422          {
   1423            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1424            {
   1425              if ( pInMsg->hdr.commandID > COMMAND_BASIC_RESET_FACT_DEFAULT )
   1426                return ( ZFailure );   // Error ignore the command
   1427          
   1428              if ( pCBs->pfnBasicReset )
   1429                pCBs->pfnBasicReset();
   1430            }
   1431            // no Client command
   1432          
   1433            return ( ZSuccess );
   1434          }
   1435          #endif // ZCL_BASIC
   1436          
   1437          #ifdef ZCL_IDENTIFY
   1438          /*********************************************************************
   1439           * @fn      zclGeneral_ProcessInIdentity
   1440           *
   1441           * @brief   Process in the received Identity Command.
   1442           *
   1443           * @param   pInMsg - pointer to the incoming message
   1444           *
   1445           * @return  ZStatus_t
   1446           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1447          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg,
   \                     zclGeneral_ProcessInIdentity:
   1448                                                         zclGeneral_AppCallbacks_t *pCBs )
   1449          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   1450            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   \   00000E   8A82         MOV     DPL,R2
   \   000010   8B83         MOV     DPH,R3
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FA           MOV     R2,A
   \   00001B   85..82       MOV     DPL,?V0 + 0
   \   00001E   8B83         MOV     DPH,R3
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   5408         ANL     A,#0x8
   \   000025   6003         JZ      $+5
   \   000027   02....       LJMP    ??zclGeneral_ProcessInIdentity_0 & 0xFFFF
   1451            {
   1452              if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY )
   \   00002A   EA           MOV     A,R2
   \   00002B   C3           CLR     C
   \   00002C   9402         SUBB    A,#0x2
   \   00002E   4005         JC      ??zclGeneral_ProcessInIdentity_1
   1453                return ( ZFailure );   // Error ignore the command
   \                     ??zclGeneral_ProcessInIdentity_2:
   \   000030   7901         MOV     R1,#0x1
   \   000032   02....       LJMP    ??zclGeneral_ProcessInIdentity_3 & 0xFFFF
   1454          
   1455              if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY )
   \                     ??zclGeneral_ProcessInIdentity_1:
   \   000035   EA           MOV     A,R2
   \   000036   7007         JNZ     ??zclGeneral_ProcessInIdentity_4
   1456              {
   1457                if ( pCBs->pfnIdentify )
   \   000038   8C82         MOV     DPL,R4
   \   00003A   8D83         MOV     DPH,R5
   \   00003C   02....       LJMP    ??zclGeneral_ProcessInIdentity_5 & 0xFFFF
   1458                {
   1459                  zclIdentify_t cmd;
   1460          
   1461                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   1462                  cmd.identifyTime = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1463          
   1464                  pCBs->pfnIdentify( &cmd );
   1465                }
   1466              }
   1467              else
   1468              {
   1469                zclAttrRec_t attrRec;
   1470                uint16 identifyTime = 0;
   \                     ??zclGeneral_ProcessInIdentity_4:
   \   00003F   7404         MOV     A,#0x4
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   E4           CLR     A
   \   000045   F0           MOVX    @DPTR,A
   \   000046   A3           INC     DPTR
   \   000047   F0           MOVX    @DPTR,A
   1471          
   1472                // Retrieve Identify Time
   1473                if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, ATTRID_IDENTIFY_TIME, &attrRec ) )
   \   000048   85..82       MOV     DPL,?V0 + 0
   \   00004B   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   00004E                ; Setup parameters for call to function zclFindAttrRec
   \   00004E   7406         MOV     A,#0x6
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   8582..       MOV     ?V0 + 2,DPL
   \   000056   8583..       MOV     ?V0 + 3,DPH
   \   000059   78..         MOV     R0,#?V0 + 2
   \   00005B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005E   7C00         MOV     R4,#0x0
   \   000060   7D00         MOV     R5,#0x0
   \   000062   8E82         MOV     DPL,R6
   \   000064   8F83         MOV     DPH,R7
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   FA           MOV     R2,A
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000071   12....       LCALL   ??zclFindAttrRec?relay
   \   000074   7402         MOV     A,#0x2
   \   000076   12....       LCALL   ?DEALLOC_XSTACK8
   \   000079   E9           MOV     A,R1
   \   00007A   6024         JZ      ??zclGeneral_ProcessInIdentity_6
   1474                  zclReadAttrData( (uint8 *)&identifyTime, &attrRec, NULL );
   \   00007C                ; Setup parameters for call to function zclReadAttrData
   \   00007C   E4           CLR     A
   \   00007D   F5..         MOV     ?V0 + 2,A
   \   00007F   F5..         MOV     ?V0 + 3,A
   \   000081   78..         MOV     R0,#?V0 + 2
   \   000083   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000086   7408         MOV     A,#0x8
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   AC82         MOV     R4,DPL
   \   00008D   AD83         MOV     R5,DPH
   \   00008F   7406         MOV     A,#0x6
   \   000091   12....       LCALL   ?XSTACK_DISP0_8
   \   000094   AA82         MOV     R2,DPL
   \   000096   AB83         MOV     R3,DPH
   \   000098   12....       LCALL   ??zclReadAttrData?relay
   \   00009B   7402         MOV     A,#0x2
   \   00009D   12....       LCALL   ?DEALLOC_XSTACK8
   1475          
   1476                // Is device identifying itself?
   1477                if ( identifyTime > 0 )
   \                     ??zclGeneral_ProcessInIdentity_6:
   \   0000A0   7404         MOV     A,#0x4
   \   0000A2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A5   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   0000A8   49           ORL     A,R1
   \   0000A9   6043         JZ      ??zclGeneral_ProcessInIdentity_7
   1478                {
   1479                  zclGeneral_SendIdentifyQueryResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1480                                                        identifyTime, true, pInMsg->hdr.transSeqNum );
   \   0000AB   85..82       MOV     DPL,?V0 + 0
   \   0000AE   85..83       MOV     DPH,?V0 + 1
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   FE           MOV     R6,A
   \   0000B3   A3           INC     DPTR
   \   0000B4   E0           MOVX    A,@DPTR
   \   0000B5   FF           MOV     R7,A
   \   0000B6                ; Setup parameters for call to function zclGeneral_SendIdentifyQueryResponse
   \   0000B6   85..82       MOV     DPL,?V0 + 0
   \   0000B9   85..83       MOV     DPH,?V0 + 1
   \   0000BC   A3           INC     DPTR
   \   0000BD   A3           INC     DPTR
   \   0000BE   A3           INC     DPTR
   \   0000BF   A3           INC     DPTR
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   F5..         MOV     ?V0 + 0,A
   \   0000C5   78..         MOV     R0,#?V0 + 0
   \   0000C7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000CA   75..01       MOV     ?V0 + 0,#0x1
   \   0000CD   78..         MOV     R0,#?V0 + 0
   \   0000CF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D2   7406         MOV     A,#0x6
   \   0000D4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D7   E0           MOVX    A,@DPTR
   \   0000D8   FC           MOV     R4,A
   \   0000D9   A3           INC     DPTR
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   FD           MOV     R5,A
   \   0000DC   EE           MOV     A,R6
   \   0000DD   2406         ADD     A,#0x6
   \   0000DF   FA           MOV     R2,A
   \   0000E0   EF           MOV     A,R7
   \   0000E1   3400         ADDC    A,#0x0
   \   0000E3   12....       LCALL   ?Subroutine5 & 0xFFFF
   1481                }
   \                     ??CrossCallReturnLabel_7:
   \   0000E6   12....       LCALL   ??zclGeneral_SendIdentifyQueryResponse?relay
   \   0000E9   7402         MOV     A,#0x2
   \   0000EB   12....       LCALL   ?DEALLOC_XSTACK8
   1482          
   1483                return ( ZCL_STATUS_CMD_HAS_RSP );
   \                     ??zclGeneral_ProcessInIdentity_7:
   \   0000EE   79FF         MOV     R1,#-0x1
   \   0000F0   805E         SJMP    ??zclGeneral_ProcessInIdentity_3
   1484              }
   1485            }
   1486            else // Client Command
   1487            {
   1488              if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY_RSP )
   \                     ??zclGeneral_ProcessInIdentity_0:
   \   0000F2   EA           MOV     A,R2
   \   0000F3   6003         JZ      $+5
   \   0000F5   02....       LJMP    ??zclGeneral_ProcessInIdentity_2 & 0xFFFF
   1489                return ( ZFailure );   // Error ignore the command
   1490          
   1491              if ( pCBs->pfnIdentifyQueryRsp )
   \   0000F8   8C82         MOV     DPL,R4
   \   0000FA   8D83         MOV     DPH,R5
   \   0000FC   A3           INC     DPTR
   \   0000FD   A3           INC     DPTR
   \                     ??zclGeneral_ProcessInIdentity_5:
   \   0000FE   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000101   604B         JZ      ??zclGeneral_ProcessInIdentity_8
   1492              {
   1493                zclIdentifyQueryRsp_t rsp;
   1494          
   1495                rsp.srcAddr = &(pInMsg->msg->srcAddr);
   \   000103   85..82       MOV     DPL,?V0 + 0
   \   000106   8B83         MOV     DPH,R3
   \   000108   E0           MOVX    A,@DPTR
   \   000109   2406         ADD     A,#0x6
   \   00010B   F8           MOV     R0,A
   \   00010C   A3           INC     DPTR
   \   00010D   E0           MOVX    A,@DPTR
   \   00010E   3400         ADDC    A,#0x0
   \   000110   F9           MOV     R1,A
   \   000111   85..82       MOV     DPL,?XSP + 0
   \   000114   85..83       MOV     DPH,?XSP + 1
   \   000117   E8           MOV     A,R0
   \   000118   F0           MOVX    @DPTR,A
   \   000119   A3           INC     DPTR
   \   00011A   E9           MOV     A,R1
   \   00011B   F0           MOVX    @DPTR,A
   1496                rsp.timeout = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   \   00011C   85..82       MOV     DPL,?V0 + 0
   \   00011F   8B83         MOV     DPH,R3
   \   000121   A3           INC     DPTR
   \   000122   A3           INC     DPTR
   \   000123   A3           INC     DPTR
   \   000124   A3           INC     DPTR
   \   000125   A3           INC     DPTR
   \   000126   A3           INC     DPTR
   \   000127   A3           INC     DPTR
   \   000128   A3           INC     DPTR
   \   000129   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   00012C   E0           MOVX    A,@DPTR
   \   00012D   FA           MOV     R2,A
   \   00012E   A3           INC     DPTR
   \   00012F   E0           MOVX    A,@DPTR
   \   000130   F9           MOV     R1,A
   \   000131   EA           MOV     A,R2
   \   000132   F8           MOV     R0,A
   \   000133   7402         MOV     A,#0x2
   \   000135   12....       LCALL   ?XSTACK_DISP0_8
   \   000138   E8           MOV     A,R0
   \   000139   F0           MOVX    @DPTR,A
   \   00013A   A3           INC     DPTR
   \   00013B   E9           MOV     A,R1
   \   00013C   F0           MOVX    @DPTR,A
   1497          
   1498                pCBs->pfnIdentifyQueryRsp( &rsp );
   \   00013D                ; Setup parameters for indirect call
   \   00013D   85..82       MOV     DPL,?XSP + 0
   \   000140   85..83       MOV     DPH,?XSP + 1
   \   000143   AA82         MOV     R2,DPL
   \   000145   AB83         MOV     R3,DPH
   \   000147   8C82         MOV     DPL,R4
   \   000149   8D83         MOV     DPH,R5
   \   00014B   12....       LCALL   ?CALL_IND
   1499              }
   1500            }
   1501          
   1502            return ( ZSuccess );
   \                     ??zclGeneral_ProcessInIdentity_8:
   \   00014E   7900         MOV     R1,#0x0
   \                     ??zclGeneral_ProcessInIdentity_3:
   \   000150   740E         MOV     A,#0xe
   \   000152   12....       LCALL   ?DEALLOC_XSTACK8
   \   000155   02....       LJMP    ?Subroutine0 & 0xFFFF
   1503          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   FB           MOV     R3,A
   \   000001   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   000004   F9           MOV     R1,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000005   FC           MOV     R4,A
   \   000006   E9           MOV     A,R1
   \   000007   FD           MOV     R5,A
   \   000008   EC           MOV     A,R4
   \   000009   4D           ORL     A,R5
   \   00000A   22           RET

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_RegisterCmdCallbacks?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_RegisterCmdCallbacks

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_SendIdentify?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendIdentify

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_SendIdentifyQueryResponse?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_SendIdentifyQueryResponse

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_HdlIncoming?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_HdlIncoming

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_HdlInSpecificCommands?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_HdlInSpecificCommands

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGeneral_ProcessInIdentity?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGeneral_ProcessInIdentity
   1504          #endif // ZCL_IDENTIFY
   1505          
   1506          #ifdef ZCL_GROUPS
   1507          
   1508          /*********************************************************************
   1509           * @fn      zclGeneral_AddGroup
   1510           *
   1511           * @brief   Add a Group.
   1512           *
   1513           * @param   endPoint - application endpoint
   1514           * @param   group - group to be added
   1515           * @param   pData - pointer to the group info
   1516           *
   1517           * @return  ZStatus_t
   1518           */
   1519          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData )
   1520          {
   1521            zclAttrRec_t attrRec;
   1522            uint8 nameLen;
   1523            uint8 nameSupport = FALSE;
   1524          
   1525            pData += 2;   // Move past group ID
   1526            nameLen = *pData++;
   1527          
   1528            // Retrieve Name Support attribute
   1529            if ( zclFindAttrRec( endPoint, ZCL_CLUSTER_ID_GEN_GROUPS, ATTRID_GROUP_NAME_SUPPORT, &attrRec ) )
   1530               zclReadAttrData( &nameSupport, &attrRec, NULL );
   1531          
   1532            if ( nameSupport )
   1533            {
   1534              if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   1535                 nameLen = (APS_GROUP_NAME_LEN-1);
   1536              group->name[0] = nameLen;
   1537              osal_memcpy( &(group->name[1]), pData, nameLen );
   1538            }
   1539          
   1540            return ( aps_AddGroup( endPoint, group ) );
   1541          }
   1542          
   1543          /*********************************************************************
   1544           * @fn      zclGeneral_ProcessInGroupsServer
   1545           *
   1546           * @brief   Process in the received Groups Command.
   1547           *
   1548           * @param   pInMsg - pointer to the incoming message
   1549           *
   1550           * @return  ZStatus_t
   1551           */
   1552          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg )
   1553          {
   1554            zclAttrRec_t attrRec;
   1555            aps_Group_t group;
   1556            aps_Group_t *pGroup;
   1557            uint8 *pData;
   1558            uint8 status;
   1559            uint8 grpCnt;
   1560            uint8 grpRspCnt = 0;
   1561            uint16 *grpList;
   1562            uint16 identifyTime = 0;
   1563            uint8 i;
   1564            ZStatus_t stat = ZSuccess;
   1565          
   1566            osal_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   1567          
   1568            pData = pInMsg->pData;
   1569            group.ID = BUILD_UINT16( pData[0], pData[1] );
   1570            switch ( pInMsg->hdr.commandID )
   1571            {
   1572              case COMMAND_GROUP_ADD:
   1573                status = zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   1574                if ( status != ZSuccess )
   1575                {
   1576                  if ( status == ZApsDuplicateEntry )
   1577                    status = ZCL_STATUS_DUPLICATE_EXISTS;
   1578                  else
   1579                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   1580                }
   1581          
   1582                zclGeneral_SendGroupAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1583                                                 status, group.ID, true, pInMsg->hdr.transSeqNum );
   1584                stat = ZCL_STATUS_CMD_HAS_RSP;
   1585                break;
   1586          
   1587              case COMMAND_GROUP_VIEW:
   1588                pGroup = aps_FindGroup( pInMsg->msg->endPoint, group.ID );
   1589                if ( pGroup )
   1590                {
   1591                  status = ZCL_STATUS_SUCCESS;
   1592                }
   1593                else
   1594                {
   1595                  // Group not found
   1596                  status = ZCL_STATUS_NOT_FOUND;
   1597                  pGroup = &group;
   1598                }
   1599                zclGeneral_SendGroupViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1600                                                  status, pGroup, true, pInMsg->hdr.transSeqNum );
   1601                stat = ZCL_STATUS_CMD_HAS_RSP;
   1602                break;
   1603          
   1604              case COMMAND_GROUP_GET_MEMBERSHIP:
   1605                grpCnt = *pData++;
   1606          
   1607                // Allocate space for the group list
   1608                grpList = osal_mem_alloc( sizeof( uint16 ) * APS_MAX_GROUPS );
   1609                if ( grpList != NULL )
   1610                {
   1611                  if ( grpCnt == 0 )
   1612                  {
   1613                    // Find out all the groups of which the endpoint is a member.
   1614                    grpRspCnt = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, grpList );
   1615                  }
   1616                  else
   1617                  {
   1618                    // Find out the groups (in the list) of which the endpoint is a member.
   1619                    for ( i = 0; i < grpCnt; i++ )
   1620                    {
   1621                      group.ID = BUILD_UINT16( pData[0], pData[1] );
   1622                      pData += 2;
   1623          
   1624                      if ( aps_FindGroup( pInMsg->msg->endPoint, group.ID ) )
   1625                        grpList[grpRspCnt++] = group.ID;
   1626                    }
   1627                  }
   1628          
   1629                  if ( grpCnt == 0 ||  grpRspCnt != 0 )
   1630                  {
   1631                    zclGeneral_SendGroupGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1632                                                               aps_GroupsRemaingCapacity(), grpRspCnt,
   1633                                                               grpList, true, pInMsg->hdr.transSeqNum );
   1634                  }
   1635          
   1636                  osal_mem_free( grpList );
   1637                }
   1638                else
   1639                {
   1640                  // Couldn't allocate space for the group list -- send a Default Response command back.
   1641                  zclDefaultRspCmd_t defaultRspCmd;
   1642          
   1643                  defaultRspCmd.commandID = pInMsg->hdr.commandID;
   1644                  defaultRspCmd.statusCode = ZCL_STATUS_INSUFFICIENT_SPACE;
   1645                  zcl_SendDefaultRspCmd( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   1646                                         pInMsg->msg->clusterId, &defaultRspCmd,
   1647                                         ZCL_FRAME_SERVER_CLIENT_DIR, true, 0, pInMsg->hdr.transSeqNum );
   1648                }
   1649          
   1650                stat = ZCL_STATUS_CMD_HAS_RSP;
   1651                break;
   1652          
   1653              case COMMAND_GROUP_REMOVE:
   1654                if ( aps_RemoveGroup( pInMsg->msg->endPoint, group.ID ) )
   1655                  status = ZCL_STATUS_SUCCESS;
   1656                else
   1657                  status = ZCL_STATUS_NOT_FOUND;
   1658                zclGeneral_SendGroupRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1659                                                    status, group.ID, true, pInMsg->hdr.transSeqNum );
   1660                stat = ZCL_STATUS_CMD_HAS_RSP;
   1661                break;
   1662          
   1663              case COMMAND_GROUP_REMOVE_ALL:
   1664                aps_RemoveAllGroup( pInMsg->msg->endPoint );
   1665                break;
   1666          
   1667              case COMMAND_GROUP_ADD_IF_IDENTIFYING:
   1668                // Retrieve Identify Time
   1669                if ( zclFindAttrRec( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY, ATTRID_IDENTIFY_TIME, &attrRec ) )
   1670                  zclReadAttrData( (uint8 *)&identifyTime, &attrRec, NULL );
   1671          
   1672                // Is device identifying itself?
   1673                if ( identifyTime > 0 )
   1674                  zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   1675                break;
   1676          
   1677              default:
   1678                stat = ZFailure;
   1679                break;
   1680            }
   1681          
   1682            return ( stat );
   1683          }
   1684          
   1685          /*********************************************************************
   1686           * @fn      zclGeneral_ProcessInGroupsClient
   1687           *
   1688           * @brief   Process in the received Groups Command.
   1689           *
   1690           * @param   pInMsg - pointer to the incoming message
   1691           *
   1692           * @return  ZStatus_t
   1693           */
   1694          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg,
   1695                                                             zclGeneral_AppCallbacks_t *pCBs )
   1696          {
   1697            aps_Group_t group;
   1698            uint8 *pData = pInMsg->pData;
   1699            uint8 grpCnt;
   1700            uint8 nameLen;
   1701            zclGroupRsp_t rsp;
   1702            uint8 i;
   1703            ZStatus_t stat = ZSuccess;
   1704          
   1705            osal_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   1706            osal_memset( (uint8*)&rsp, 0, sizeof( zclGroupRsp_t ) );
   1707          
   1708            switch ( pInMsg->hdr.commandID )
   1709            {
   1710              case COMMAND_GROUP_ADD_RSP:
   1711              case COMMAND_GROUP_VIEW_RSP:
   1712              case COMMAND_GROUP_REMOVE_RSP:
   1713                rsp.status = *pData++;
   1714                group.ID = BUILD_UINT16( pData[0], pData[1] );
   1715          
   1716                if ( rsp.status == ZCL_STATUS_SUCCESS && pInMsg->hdr.commandID == COMMAND_GROUP_VIEW_RSP )
   1717                {
   1718                  pData += 2;   // Move past ID
   1719                  nameLen = *pData++;
   1720                  if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   1721                    nameLen = (APS_GROUP_NAME_LEN-1);
   1722                  group.name[0] = nameLen;
   1723                  osal_memcpy( &(group.name[1]), pData, nameLen );
   1724                  rsp.grpName = group.name;
   1725                }
   1726          
   1727                if ( pCBs->pfnGroupRsp )
   1728                {
   1729                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   1730                  rsp.cmdID = pInMsg->hdr.commandID;
   1731                  rsp.grpCnt = 1;
   1732                  rsp.grpList = &group.ID;
   1733                  rsp.capacity = 0;
   1734          
   1735                  pCBs->pfnGroupRsp( &rsp );
   1736                }
   1737                break;
   1738          
   1739              case COMMAND_GROUP_GET_MEMBERSHIP_RSP:
   1740                {
   1741                  uint16 *grpList = NULL;
   1742                  rsp.capacity = *pData++;
   1743                  grpCnt = *pData++;
   1744          
   1745                  if ( grpCnt > 0 )
   1746                  {
   1747                    // Allocate space for the group list
   1748                    grpList = osal_mem_alloc( sizeof( uint16 ) * grpCnt );
   1749                    if ( grpList != NULL )
   1750                    {
   1751                      rsp.grpCnt = grpCnt;
   1752                      for ( i = 0; i < grpCnt; i++ )
   1753                      {
   1754                        grpList[i] = BUILD_UINT16( pData[0], pData[1] );
   1755                        pData += 2;
   1756                      }
   1757                    }
   1758                  }
   1759          
   1760                  if ( pCBs->pfnGroupRsp )
   1761                  {
   1762                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   1763                    rsp.cmdID = pInMsg->hdr.commandID;
   1764                    rsp.grpList = grpList;
   1765          
   1766                    pCBs->pfnGroupRsp( &rsp );
   1767                  }
   1768          
   1769                  if ( grpList != NULL )
   1770                  {
   1771                    osal_mem_free( grpList );
   1772                  }
   1773                }
   1774                break;
   1775          
   1776              default:
   1777                stat = ZFailure;
   1778                break;
   1779            }
   1780          
   1781            return ( stat );
   1782          }
   1783          #endif // ZCL_GROUPS
   1784          
   1785          #ifdef ZCL_SCENES
   1786          /*********************************************************************
   1787           * @fn      zclGeneral_AddScene
   1788           *
   1789           * @brief   Add a scene for an endpoint
   1790           *
   1791           * @param   endpoint -
   1792           * @param   scene - new scene item
   1793           *
   1794           * @return  ZStatus_t
   1795           */
   1796          ZStatus_t zclGeneral_AddScene( uint8 endpoint, zclGeneral_Scene_t *scene )
   1797          {
   1798            zclGenSceneItem_t *pNewItem;
   1799            zclGenSceneItem_t *pLoop;
   1800          
   1801            // Fill in the new profile list
   1802            pNewItem = osal_mem_alloc( sizeof( zclGenSceneItem_t ) );
   1803            if ( pNewItem == NULL )
   1804              return ( ZMemError );
   1805          
   1806            // Fill in the plugin record.
   1807            pNewItem->next = (zclGenSceneItem_t *)NULL;
   1808            pNewItem->endpoint = endpoint;
   1809            osal_memcpy( (uint8*)&(pNewItem->scene), (uint8*)scene, sizeof ( zclGeneral_Scene_t ));
   1810          
   1811            // Find spot in list
   1812            if (  zclGenSceneTable == NULL )
   1813            {
   1814              zclGenSceneTable = pNewItem;
   1815            }
   1816            else
   1817            {
   1818              // Look for end of list
   1819              pLoop = zclGenSceneTable;
   1820              while ( pLoop->next != NULL )
   1821                pLoop = pLoop->next;
   1822          
   1823              // Put new item at end of list
   1824              pLoop->next = pNewItem;
   1825            }
   1826          
   1827            // Update NV
   1828            zclGeneral_ScenesWriteNV();
   1829          
   1830            return ( ZSuccess );
   1831          }
   1832          
   1833          /*********************************************************************
   1834           * @fn      zclGeneral_FindScene
   1835           *
   1836           * @brief   Find a scene with endpoint and sceneID
   1837           *
   1838           * @param   endpoint -
   1839           * @param   groupID - what group the scene belongs to
   1840           * @param   sceneID - ID to look for scene
   1841           *
   1842           * @return  a pointer to the scene information, NULL if not found
   1843           */
   1844          zclGeneral_Scene_t *zclGeneral_FindScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   1845          {
   1846            zclGenSceneItem_t *pLoop;
   1847          
   1848            // Look for end of list
   1849            pLoop = zclGenSceneTable;
   1850            while ( pLoop )
   1851            {
   1852              if ( (pLoop->endpoint == endpoint || endpoint == 0xFF)
   1853                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   1854              {
   1855                return ( &(pLoop->scene) );
   1856              }
   1857              pLoop = pLoop->next;
   1858            }
   1859          
   1860            return ( (zclGeneral_Scene_t *)NULL );
   1861          }
   1862          
   1863          /*********************************************************************
   1864           * @fn      aps_FindAllScensForGroup
   1865           *
   1866           * @brief   Find all the scenes with groupID
   1867           *
   1868           * @param   endpoint - endpoint to look for
   1869           * @param   sceneList - List to hold scene IDs (should hold APS_MAX_SCENES entries)
   1870           *
   1871           * @return  number of scenes copied to sceneList
   1872           */
   1873          uint8 zclGeneral_FindAllScenesForGroup( uint8 endpoint, uint16 groupID, uint8 *sceneList )
   1874          {
   1875            zclGenSceneItem_t *pLoop;
   1876            uint8 cnt = 0;
   1877          
   1878            // Look for end of list
   1879            pLoop = zclGenSceneTable;
   1880            while ( pLoop )
   1881            {
   1882              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   1883                sceneList[cnt++] = pLoop->scene.ID;
   1884              pLoop = pLoop->next;
   1885            }
   1886            return ( cnt );
   1887          }
   1888          
   1889          /*********************************************************************
   1890           * @fn      zclGeneral_RemoveScene
   1891           *
   1892           * @brief   Remove a scene with endpoint and sceneID
   1893           *
   1894           * @param   endpoint -
   1895           * @param   groupID - what group the scene belongs to
   1896           * @param   sceneID - ID to look for scene
   1897           *
   1898           * @return  TRUE if removed, FALSE if not found
   1899           */
   1900          uint8 zclGeneral_RemoveScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   1901          {
   1902            zclGenSceneItem_t *pLoop;
   1903            zclGenSceneItem_t *pPrev;
   1904          
   1905            // Look for end of list
   1906            pLoop = zclGenSceneTable;
   1907            pPrev = NULL;
   1908            while ( pLoop )
   1909            {
   1910              if ( pLoop->endpoint == endpoint
   1911                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   1912              {
   1913                if ( pPrev == NULL )
   1914                  zclGenSceneTable = pLoop->next;
   1915                else
   1916                  pPrev->next = pLoop->next;
   1917          
   1918                // Free the memory
   1919                osal_mem_free( pLoop );
   1920          
   1921                // Update NV
   1922                zclGeneral_ScenesWriteNV();
   1923          
   1924                return ( TRUE );
   1925              }
   1926              pPrev = pLoop;
   1927              pLoop = pLoop->next;
   1928            }
   1929          
   1930            return ( FALSE );
   1931          }
   1932          
   1933          /*********************************************************************
   1934           * @fn      zclGeneral_RemoveAllScenes
   1935           *
   1936           * @brief   Remove all scenes with endpoint and group Id
   1937           *
   1938           * @param   endpoint -
   1939           * @param   groupID - ID to look for group
   1940           *
   1941           * @return  none
   1942           */
   1943          void zclGeneral_RemoveAllScenes( uint8 endpoint, uint16 groupID )
   1944          {
   1945            zclGenSceneItem_t *pLoop;
   1946            zclGenSceneItem_t *pPrev;
   1947            zclGenSceneItem_t *pNext;
   1948          
   1949            // Look for end of list
   1950            pLoop = zclGenSceneTable;
   1951            pPrev = NULL;
   1952            while ( pLoop )
   1953            {
   1954              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   1955              {
   1956                if ( pPrev == NULL )
   1957                  zclGenSceneTable = pLoop->next;
   1958                else
   1959                  pPrev->next = pLoop->next;
   1960                pNext = pLoop->next;
   1961          
   1962                // Free the memory
   1963                osal_mem_free( pLoop );
   1964                pLoop = pNext;
   1965              }
   1966              else
   1967              {
   1968                pPrev = pLoop;
   1969                pLoop = pLoop->next;
   1970              }
   1971            }
   1972          
   1973            // Update NV
   1974            zclGeneral_ScenesWriteNV();
   1975          }
   1976          
   1977          /*********************************************************************
   1978           * @fn      zclGeneral_CountScenes
   1979           *
   1980           * @brief   Count the number of scenes for an endpoint
   1981           *
   1982           * @param   endpoint -
   1983           *
   1984           * @return  number of scenes assigned to an endpoint
   1985           */
   1986          uint8 zclGeneral_CountScenes( uint8 endpoint )
   1987          {
   1988            zclGenSceneItem_t *pLoop;
   1989            uint8 cnt = 0;
   1990          
   1991            // Look for end of list
   1992            pLoop = zclGenSceneTable;
   1993            while ( pLoop )
   1994            {
   1995              if ( pLoop->endpoint == endpoint  )
   1996                cnt++;
   1997              pLoop = pLoop->next;
   1998            }
   1999            return ( cnt );
   2000          }
   2001          
   2002          /*********************************************************************
   2003           * @fn      zclGeneral_CountAllScenes
   2004           *
   2005           * @brief   Count the total number of scenes
   2006           *
   2007           * @param   none
   2008           *
   2009           * @return  number of scenes
   2010           */
   2011          uint8 zclGeneral_CountAllScenes( void )
   2012          {
   2013            zclGenSceneItem_t *pLoop;
   2014            uint8 cnt = 0;
   2015          
   2016            // Look for end of list
   2017            pLoop = zclGenSceneTable;
   2018            while ( pLoop )
   2019            {
   2020              cnt++;
   2021              pLoop = pLoop->next;
   2022            }
   2023            return ( cnt );
   2024          }
   2025          
   2026          /*********************************************************************
   2027           * @fn      zclGeneral_ReadSceneCountCB
   2028           *
   2029           * @brief   Read the number of scenes currently in the device's
   2030           *          scene table (i.e., the Scene Count attribute).
   2031           *
   2032           *          Note: This function gets called only when the pointer
   2033           *                'dataPtr' to the Scene Count attribute value is
   2034           *                NULL in the attribute database registered with
   2035           *                the ZCL.
   2036           *
   2037           * @param   clusterId - cluster that attribute belongs to
   2038           * @param   attrId - attribute to be read
   2039           * @param   oper - ZCL_OPER_LEN, ZCL_OPER_READ
   2040           * @param   pValue - pointer to attribute value
   2041           * @param   pLen - pointer to length of attribute value read
   2042           *
   2043           * @return  status
   2044           */
   2045          ZStatus_t zclGeneral_ReadSceneCountCB( uint16 clusterId, uint16 attrId,
   2046                                                 uint8 oper, uint8 *pValue, uint16 *pLen )
   2047          {
   2048            ZStatus_t status = ZCL_STATUS_SUCCESS;
   2049          
   2050            // This callback function should only be called for the Scene Count attribute
   2051            switch ( oper )
   2052            {
   2053              case ZCL_OPER_LEN:
   2054                *pLen = 1; // uint8
   2055                break;
   2056          
   2057              case ZCL_OPER_READ:
   2058                *pValue = zclGeneral_CountAllScenes();
   2059          
   2060                if ( pLen != NULL )
   2061                {
   2062                  *pLen = 1;
   2063                }
   2064                break;
   2065          
   2066              default:
   2067                status = ZCL_STATUS_SOFTWARE_FAILURE; // should never get here!
   2068                break;
   2069            }
   2070          
   2071            return ( status );
   2072          }
   2073          
   2074          /*********************************************************************
   2075           * @fn      zclGeneral_ProcessInScenesServer
   2076           *
   2077           * @brief   Process in the received Scenes Command.
   2078           *
   2079           * @param   pInMsg - pointer to the incoming message
   2080           *
   2081           * @return  ZStatus_t
   2082           */
   2083          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg,
   2084                                                             zclGeneral_AppCallbacks_t *pCBs )
   2085          {
   2086            zclAttrRec_t attrRec;
   2087            zclGeneral_Scene_t scene;
   2088            zclGeneral_Scene_t *pScene;
   2089            uint8 *pData = pInMsg->pData;
   2090            uint8 nameLen;
   2091            uint8 status;
   2092            uint8 sceneCnt = 0;
   2093            uint8 *sceneList = NULL;
   2094            uint8 sendRsp = FALSE;
   2095            uint8 nameSupport = FALSE;
   2096            ZStatus_t stat = ZSuccess;
   2097          
   2098            osal_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   2099          
   2100            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   2101            pData += 2;   // Move past group ID
   2102            scene.ID = *pData++;
   2103          
   2104            switch ( pInMsg->hdr.commandID )
   2105            {
   2106              case COMMAND_SCENE_ADD:
   2107                // Parse the rest of the incoming message
   2108                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   2109                pData += 2;
   2110                nameLen= *pData++; // Name length
   2111          
   2112                // Retrieve Name Support attribute
   2113                if ( zclFindAttrRec( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_SCENES, ATTRID_SCENES_NAME_SUPPORT, &attrRec ) )
   2114                {
   2115                  zclReadAttrData( &nameSupport, &attrRec, NULL );
   2116                }
   2117          
   2118                if ( nameSupport )
   2119                {
   2120                  if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   2121                  {
   2122                    // truncate to maximum size
   2123                    scene.name[0] = ZCL_GEN_SCENE_NAME_LEN-1;
   2124                  }
   2125                  else
   2126                  {
   2127                    scene.name[0] = nameLen;
   2128                  }
   2129                  osal_memcpy( &(scene.name[1]), pData, scene.name[0] );
   2130                }
   2131          
   2132                pData += nameLen; // move past name, use original length
   2133          
   2134                scene.extLen = pInMsg->pDataLen - ( (uint16)( pData - pInMsg->pData ) );
   2135                if ( scene.extLen > 0 )
   2136                {
   2137                  // Copy the extention field(s)
   2138                  if ( scene.extLen > ZCL_GEN_SCENE_EXT_LEN )
   2139                  {
   2140                    scene.extLen = ZCL_GEN_SCENE_EXT_LEN;
   2141                  }
   2142                  osal_memcpy( scene.extField, pData, scene.extLen );
   2143                }
   2144          
   2145                if ( scene.groupID == 0x0000 ||
   2146                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2147                {
   2148                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2149                  // does and the corresponding Group exits
   2150                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2151                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2152                  {
   2153                    status = ZCL_STATUS_SUCCESS;
   2154                    if ( pScene != NULL )
   2155                    {
   2156                      // The Scene already exists so update it
   2157                      pScene->transTime = scene.transTime;
   2158                      osal_memcpy( pScene->name, scene.name, ZCL_GEN_SCENE_NAME_LEN );
   2159          
   2160                      // Use the new extention field(s)
   2161                      osal_memcpy( pScene->extField, scene.extField, scene.extLen );
   2162                      pScene->extLen = scene.extLen;
   2163          
   2164                      // Update NV
   2165                      zclGeneral_ScenesWriteNV();
   2166                    }
   2167                    else
   2168                    {
   2169                      // The Scene doesn't exist so add it
   2170                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2171                    }
   2172                  }
   2173                  else
   2174                  {
   2175                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2176                  }
   2177                }
   2178                else
   2179                {
   2180                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2181                }
   2182          
   2183                zclGeneral_SendSceneAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2184                                                 status, scene.groupID, scene.ID,
   2185                                                 true, pInMsg->hdr.transSeqNum );
   2186                stat = ZCL_STATUS_CMD_HAS_RSP;
   2187                break;
   2188          
   2189              case COMMAND_SCENE_VIEW:
   2190                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2191                if ( pScene != NULL )
   2192                {
   2193                  status = ZCL_STATUS_SUCCESS;
   2194                }
   2195                else
   2196                {
   2197                  // Scene not found
   2198                  if ( scene.groupID != 0x0000 &&
   2199                       aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2200                  {
   2201                    status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2202                  }
   2203                  else
   2204                  {
   2205                    status = ZCL_STATUS_NOT_FOUND;
   2206                  }
   2207                  pScene = &scene;
   2208                }
   2209                zclGeneral_SendSceneViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2210                                                  status, pScene, true, pInMsg->hdr.transSeqNum );
   2211                stat = ZCL_STATUS_CMD_HAS_RSP;
   2212                break;
   2213          
   2214              case COMMAND_SCENE_REMOVE:
   2215                if ( zclGeneral_RemoveScene( pInMsg->msg->endPoint, scene.groupID, scene.ID ) )
   2216                {
   2217                  status = ZCL_STATUS_SUCCESS;
   2218                }
   2219                else
   2220                {
   2221                  // Scene not found
   2222                  if ( aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2223                  {
   2224                    // The Group is not in the Group Table
   2225                    status = ZCL_STATUS_INVALID_FIELD;
   2226                  }
   2227                  else
   2228                  {
   2229                    status = ZCL_STATUS_NOT_FOUND;
   2230                  }
   2231                }
   2232          
   2233                if ( UNICAST_MSG( pInMsg->msg ) )
   2234                {
   2235                  // Addressed to this device (not to a group) - send a response back
   2236                  zclGeneral_SendSceneRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2237                                                      status, scene.groupID,
   2238                                                      scene.ID, true, pInMsg->hdr.transSeqNum );
   2239                }
   2240                stat = ZCL_STATUS_CMD_HAS_RSP;
   2241                break;
   2242          
   2243              case COMMAND_SCENE_REMOVE_ALL:
   2244                if ( scene.groupID == 0x0000 ||
   2245                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2246                {
   2247                  zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, scene.groupID );
   2248                  status = ZCL_STATUS_SUCCESS;
   2249                }
   2250                else
   2251                {
   2252                  status = ZCL_STATUS_INVALID_FIELD;
   2253                }
   2254          
   2255                if ( UNICAST_MSG( pInMsg->msg ) )
   2256                {
   2257                  // Addressed to this device (not to a group) - send a response back
   2258                  zclGeneral_SendSceneRemoveAllResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2259                                                         status, scene.groupID, true, pInMsg->hdr.transSeqNum );
   2260                }
   2261                stat = ZCL_STATUS_CMD_HAS_RSP;
   2262                break;
   2263          
   2264              case COMMAND_SCENE_STORE:
   2265                if ( scene.groupID == 0x0000 ||
   2266                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2267                {
   2268                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2269                  // does and the corresponding Group exits
   2270                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2271                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2272                  {
   2273                    uint8 sceneChanged = FALSE;
   2274          
   2275                    status = ZCL_STATUS_SUCCESS;
   2276                    if ( pScene == NULL )
   2277                    {
   2278                      // Haven't been added yet
   2279                      pScene = &scene;
   2280                    }
   2281          
   2282                    if ( pCBs->pfnSceneStoreReq )
   2283                    {
   2284                      zclSceneReq_t req;
   2285          
   2286                      req.srcAddr = &(pInMsg->msg->srcAddr);
   2287                      req.scene = pScene;
   2288          
   2289                      // Get the latest Scene info
   2290                      if ( pCBs->pfnSceneStoreReq( &req ) )
   2291                      {
   2292                        sceneChanged = TRUE;
   2293                      }
   2294                    }
   2295          
   2296                    if ( pScene == &scene )
   2297                    {
   2298                      // The Scene doesn't exist so add it
   2299                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2300                    }
   2301                    else if ( sceneChanged )
   2302                    {
   2303                      // The Scene already exists so update only NV
   2304                      zclGeneral_ScenesWriteNV();
   2305                    }
   2306                  }
   2307                  else
   2308                  {
   2309                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2310                  }
   2311                }
   2312                else
   2313                {
   2314                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2315                }
   2316          
   2317                if ( UNICAST_MSG( pInMsg->msg ) )
   2318                {
   2319                  // Addressed to this device (not to a group) - send a response back
   2320                  zclGeneral_SendSceneStoreResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2321                                                     status, scene.groupID, scene.ID,
   2322                                                     true, pInMsg->hdr.transSeqNum );
   2323                }
   2324                stat = ZCL_STATUS_CMD_HAS_RSP;
   2325                break;
   2326          
   2327              case COMMAND_SCENE_RECALL:
   2328                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2329                if ( pScene && pCBs->pfnSceneRecallReq )
   2330                {
   2331                  zclSceneReq_t req;
   2332          
   2333                  req.srcAddr = &(pInMsg->msg->srcAddr);
   2334                  req.scene = pScene;
   2335          
   2336                  pCBs->pfnSceneRecallReq( &req );
   2337                }
   2338                // No response
   2339                break;
   2340          
   2341              case COMMAND_SCENE_GET_MEMBERSHIP:
   2342                // Find all the Scenes corresponding to the Group ID
   2343                if ( scene.groupID == 0x0000 ||
   2344                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2345                {
   2346                  // Allocate space for the scene list
   2347                  sceneList = osal_mem_alloc( ZCL_GEN_MAX_SCENES );
   2348                  if ( sceneList != NULL )
   2349                  {
   2350                    sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint,
   2351                                                                 scene.groupID, sceneList );
   2352                    status = ZCL_STATUS_SUCCESS;
   2353                    if ( UNICAST_MSG( pInMsg->msg ) )
   2354                    {
   2355                      // Addressed only to this device - send a response back
   2356                      sendRsp = TRUE;
   2357                    }
   2358                    else
   2359                    {
   2360                      // Addressed to the Group - ONLY send a response if an entry within the
   2361                      // Scene Table corresponds to the Group ID
   2362                      if ( sceneCnt != 0 )
   2363                      {
   2364                        sendRsp = TRUE;
   2365                      }
   2366                    }
   2367                  }
   2368                  else
   2369                  {
   2370                    // Couldn't allocate space for the scene list!
   2371                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   2372                    sendRsp = TRUE;
   2373                  }
   2374                }
   2375                else
   2376                {
   2377                  // The Group is not in the Group Table - send a response back
   2378                  status = ZCL_STATUS_INVALID_FIELD;
   2379                  sendRsp = TRUE;
   2380                }
   2381          
   2382                if ( sendRsp )
   2383                {
   2384                  zclGeneral_SendSceneGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2385                                              status, zclGeneral_ScenesRemaingCapacity(), sceneCnt, sceneList,
   2386                                              scene.groupID, true, pInMsg->hdr.transSeqNum );
   2387                }
   2388          
   2389                if ( sceneList != NULL )
   2390                {
   2391                  osal_mem_free( sceneList );
   2392                }
   2393          
   2394                stat = ZCL_STATUS_CMD_HAS_RSP;
   2395                break;
   2396          
   2397              default:
   2398                stat = ZFailure;
   2399              break;
   2400            }
   2401          
   2402            return ( stat );
   2403          }
   2404          
   2405          /*********************************************************************
   2406           * @fn      zclGeneral_ProcessInScenesClient
   2407           *
   2408           * @brief   Process in the received Scenes Command.
   2409           *
   2410           * @param   pInMsg - pointer to the incoming message
   2411           *
   2412           * @return  ZStatus_t
   2413           */
   2414          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg,
   2415                                                             zclGeneral_AppCallbacks_t *pCBs )
   2416          {
   2417            zclGeneral_Scene_t scene;
   2418            uint8 *pData = pInMsg->pData;
   2419            uint8 nameLen;
   2420            zclSceneRsp_t rsp;
   2421            uint8 i;
   2422            ZStatus_t stat = ZSuccess;
   2423          
   2424            osal_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   2425            osal_memset( (uint8*)&rsp, 0, sizeof( zclSceneRsp_t ) );
   2426          
   2427            // Get the status field first
   2428            rsp.status = *pData++;
   2429          
   2430            if ( pInMsg->hdr.commandID == COMMAND_SCENE_GET_MEMBERSHIP_RSP )
   2431            {
   2432              rsp.capacity = *pData++;
   2433            }
   2434          
   2435            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   2436            pData += 2;   // Move past group ID
   2437          
   2438            switch ( pInMsg->hdr.commandID )
   2439            {
   2440              case COMMAND_SCENE_VIEW_RSP:
   2441                // Parse the rest of the incoming message
   2442                scene.ID = *pData++; // Not applicable to Remove All Response command
   2443                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   2444                pData += 2;
   2445                nameLen = *pData++; // Name length
   2446                if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   2447                {
   2448                  // truncate to maximum size
   2449                  scene.name[0] = ZCL_GEN_SCENE_NAME_LEN-1;
   2450                }
   2451                else
   2452                {
   2453                  scene.name[0] = nameLen;
   2454                }
   2455                osal_memcpy( &(scene.name[1]), pData, scene.name[0] );
   2456          
   2457                pData += nameLen; // move past name, use original length
   2458          
   2459                //*** Do something with the extension field(s)
   2460          
   2461                // Fall through to callback - break is left off intentionally
   2462          
   2463              case COMMAND_SCENE_ADD_RSP:
   2464              case COMMAND_SCENE_REMOVE_RSP:
   2465              case COMMAND_SCENE_REMOVE_ALL_RSP:
   2466              case COMMAND_SCENE_STORE_RSP:
   2467                if ( pCBs->pfnSceneRsp )
   2468                {
   2469                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2470                  rsp.cmdID = pInMsg->hdr.commandID;
   2471                  rsp.scene = &scene;
   2472          
   2473                  pCBs->pfnSceneRsp( &rsp );
   2474                }
   2475                break;
   2476          
   2477              case COMMAND_SCENE_GET_MEMBERSHIP_RSP:
   2478                {
   2479                  uint8 *sceneList = NULL;
   2480          
   2481                  if ( rsp.status == ZCL_STATUS_SUCCESS )
   2482                  {
   2483                    uint8 sceneCnt = *pData++;
   2484          
   2485                    if ( sceneCnt > 0 )
   2486                    {
   2487                      // Allocate space for the scene list
   2488                      sceneList = osal_mem_alloc( sceneCnt );
   2489                      if ( sceneList != NULL )
   2490                      {
   2491                        rsp.sceneCnt = sceneCnt;
   2492                        for ( i = 0; i < sceneCnt; i++ )
   2493                          sceneList[i] = *pData++;
   2494                      }
   2495                    }
   2496                  }
   2497          
   2498                  if ( pCBs->pfnSceneRsp )
   2499                  {
   2500                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2501                    rsp.cmdID = pInMsg->hdr.commandID;
   2502                    rsp.sceneList = sceneList;
   2503                    rsp.scene = &scene;
   2504          
   2505                    pCBs->pfnSceneRsp( &rsp);
   2506                  }
   2507          
   2508                  if ( sceneList != NULL )
   2509                  {
   2510                    osal_mem_free( sceneList );
   2511                  }
   2512                }
   2513                break;
   2514          
   2515              default:
   2516                stat = ZFailure;
   2517                break;
   2518            }
   2519          
   2520            return ( stat );
   2521          }
   2522          #endif // ZCL_SCENES
   2523          
   2524          #ifdef ZCL_ON_OFF
   2525          /*********************************************************************
   2526           * @fn      zclGeneral_ProcessInCmdOnOff
   2527           *
   2528           * @brief   Process in the received On/Off Command.
   2529           *
   2530           * @param   pInMsg - pointer to the incoming message
   2531           *
   2532           * @return  ZStatus_t
   2533           */
   2534          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg,
   2535                                                      zclGeneral_AppCallbacks_t *pCBs )
   2536          {
   2537            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   2538            {
   2539              /*if ( pInMsg->hdr.commandID > COMMAND_TOGGLE )
   2540                return ( ZFailure );   // Error ignore the command
   2541          */
   2542              if ( pCBs->pfnOnOff )
   2543                pCBs->pfnOnOff( pInMsg->hdr.commandID );
   2544            }
   2545            // no Client command
   2546          
   2547            return ( ZSuccess );
   2548          }
   2549          #endif // ZCL_ON_OFF
   2550          
   2551          #ifdef ZCL_LEVEL_CTRL
   2552          /*********************************************************************
   2553           * @fn      zclGeneral_ProcessInLevelControl
   2554           *
   2555           * @brief   Process in the received Level Control Command.
   2556           *
   2557           * @param   pInMsg - pointer to the incoming message
   2558           *
   2559           * @return  ZStatus_t
   2560           */
   2561          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg,
   2562                                                             zclGeneral_AppCallbacks_t *pCBs )
   2563          {
   2564            uint8 withOnOff = FALSE;
   2565            ZStatus_t stat = ZSuccess;
   2566          
   2567            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   2568            {
   2569              switch ( pInMsg->hdr.commandID )
   2570              {
   2571                case COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF:
   2572                  withOnOff = TRUE;
   2573                  // fall through
   2574                case COMMAND_LEVEL_MOVE_TO_LEVEL:
   2575                  if ( pCBs->pfnLevelControlMoveToLevel )
   2576                  {
   2577                    zclLCMoveToLevel_t cmd;
   2578          
   2579                    cmd.level = pInMsg->pData[0];
   2580                    cmd.transitionTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   2581                    cmd.withOnOff = withOnOff;
   2582          
   2583                    pCBs->pfnLevelControlMoveToLevel( &cmd );
   2584                  }
   2585                  break;
   2586          
   2587                case COMMAND_LEVEL_MOVE_WITH_ON_OFF:
   2588                  withOnOff = TRUE;
   2589                  // fall through
   2590                case COMMAND_LEVEL_MOVE:
   2591                  if ( pCBs->pfnLevelControlMove )
   2592                  {
   2593                    zclLCMove_t cmd;
   2594          
   2595                    cmd.moveMode = pInMsg->pData[0];
   2596                    cmd.rate = pInMsg->pData[1];
   2597                    cmd.withOnOff = withOnOff;
   2598          
   2599                    pCBs->pfnLevelControlMove( &cmd );
   2600                  }
   2601                  break;
   2602          
   2603                case COMMAND_LEVEL_STEP_WITH_ON_OFF:
   2604                  withOnOff = TRUE;
   2605                  // fall through
   2606                case COMMAND_LEVEL_STEP:
   2607                  if ( pCBs->pfnLevelControlStep )
   2608                  {
   2609                    zclLCStep_t cmd;
   2610          
   2611                    cmd.stepMode = pInMsg->pData[0];
   2612                    cmd.amount =  pInMsg->pData[1];
   2613                    cmd.transitionTime = BUILD_UINT16( pInMsg->pData[2], pInMsg->pData[3] );
   2614                    cmd.withOnOff = withOnOff;
   2615          
   2616                    pCBs->pfnLevelControlStep( &cmd );
   2617                  }
   2618                  break;
   2619          
   2620                case COMMAND_LEVEL_STOP:
   2621                case COMMAND_LEVEL_STOP_WITH_ON_OFF:
   2622                  // Both Stop commands are identical
   2623                  if ( pCBs->pfnLevelControlStop )
   2624                  {
   2625                    pCBs->pfnLevelControlStop();
   2626                  }
   2627                  break;
   2628          
   2629                default:
   2630                  stat = ZFailure;
   2631                  break;
   2632              }
   2633            }
   2634            // no Client command
   2635          
   2636            return ( stat );
   2637          }
   2638          #endif // ZCL_LEVEL_CTRL
   2639          
   2640          #ifdef ZCL_ALARMS
   2641          /*********************************************************************
   2642           * @fn      zclGeneral_AddAlarm
   2643           *
   2644           * @brief   Add an alarm for a cluster
   2645           *
   2646           * @param   endpoint -
   2647           * @param   alarm - new alarm item
   2648           *
   2649           * @return  ZStatus_t
   2650           */
   2651          ZStatus_t zclGeneral_AddAlarm( uint8 endpoint, zclGeneral_Alarm_t *alarm )
   2652          {
   2653            zclGenAlarmItem_t *pNewItem;
   2654            zclGenAlarmItem_t *pLoop;
   2655          
   2656            // Fill in the new profile list
   2657            pNewItem = osal_mem_alloc( sizeof( zclGenAlarmItem_t ) );
   2658            if ( pNewItem == NULL )
   2659              return ( ZMemError );
   2660          
   2661            // Fill in the plugin record.
   2662            pNewItem->next = (zclGenAlarmItem_t *)NULL;
   2663            pNewItem->endpoint =  endpoint;
   2664            osal_memcpy( (uint8*)(&pNewItem->alarm), (uint8*)alarm, sizeof ( zclGeneral_Alarm_t ) );
   2665          
   2666            // Find spot in list
   2667            if (  zclGenAlarmTable == NULL )
   2668            {
   2669              zclGenAlarmTable = pNewItem;
   2670            }
   2671            else
   2672            {
   2673              // Look for end of list
   2674              pLoop = zclGenAlarmTable;
   2675              while ( pLoop->next != NULL )
   2676                pLoop = pLoop->next;
   2677          
   2678              // Put new item at end of list
   2679              pLoop->next = pNewItem;
   2680            }
   2681          
   2682            return ( ZSuccess );
   2683          }
   2684          
   2685          /*********************************************************************
   2686           * @fn      zclGeneral_FindAlarm
   2687           *
   2688           * @brief   Find an alarm with alarmCode and clusterID
   2689           *
   2690           * @param   endpoint -
   2691           * @param   groupID - what group the scene belongs to
   2692           * @param   sceneID - ID to look for scene
   2693           *
   2694           * @return  a pointer to the alarm information, NULL if not found
   2695           */
   2696          zclGeneral_Alarm_t *zclGeneral_FindAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   2697          {
   2698            zclGenAlarmItem_t *pLoop;
   2699          
   2700            // Look for the alarm
   2701            pLoop = zclGenAlarmTable;
   2702            while ( pLoop )
   2703            {
   2704              if ( pLoop->endpoint == endpoint &&
   2705                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   2706              {
   2707                return ( &(pLoop->alarm) );
   2708              }
   2709              pLoop = pLoop->next;
   2710            }
   2711          
   2712            return ( (zclGeneral_Alarm_t *)NULL );
   2713          }
   2714          
   2715          /*********************************************************************
   2716           * @fn      zclGeneral_FindEarliestAlarm
   2717           *
   2718           * @brief   Find an alarm with the earliest timestamp
   2719           *
   2720           * @param   endpoint -
   2721           *
   2722           * @return  a pointer to the alarm information, NULL if not found
   2723           */
   2724          zclGeneral_Alarm_t *zclGeneral_FindEarliestAlarm( uint8 endpoint )
   2725          {
   2726            zclGenAlarmItem_t *pLoop;
   2727            zclGenAlarmItem_t earliestAlarm;
   2728            zclGenAlarmItem_t *pEarliestAlarm = &earliestAlarm;
   2729          
   2730            pEarliestAlarm->alarm.timeStamp = 0xFFFFFFFF;
   2731          
   2732            // Look for alarm with earliest time
   2733            pLoop = zclGenAlarmTable;
   2734            while ( pLoop )
   2735            {
   2736              if ( pLoop->endpoint == endpoint &&
   2737                   pLoop->alarm.timeStamp < pEarliestAlarm->alarm.timeStamp )
   2738              {
   2739                pEarliestAlarm = pLoop;
   2740              }
   2741              pLoop = pLoop->next;
   2742            }
   2743          
   2744            if ( pEarliestAlarm->alarm.timeStamp != 0xFFFFFFFF )
   2745              return ( &(pEarliestAlarm->alarm) );
   2746          
   2747            // No alarm
   2748            return ( (zclGeneral_Alarm_t *)NULL );
   2749          }
   2750          
   2751          /*********************************************************************
   2752           * @fn      zclGeneral_ResetAlarm
   2753           *
   2754           * @brief   Remove a scene with endpoint and sceneID
   2755           *
   2756           * @param   endpoint -
   2757           * @param   alarmCode -
   2758           * @param   clusterID -
   2759           *
   2760           * @return  TRUE if removed, FALSE if not found
   2761           */
   2762          void zclGeneral_ResetAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   2763          {
   2764            zclGenAlarmItem_t *pLoop;
   2765            zclGenAlarmItem_t *pPrev;
   2766          
   2767            // Look for end of list
   2768            pLoop = zclGenAlarmTable;
   2769            pPrev = NULL;
   2770            while ( pLoop )
   2771            {
   2772              if ( pLoop->endpoint == endpoint &&
   2773                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   2774              {
   2775                if ( pPrev == NULL )
   2776                  zclGenAlarmTable = pLoop->next;
   2777                else
   2778                  pPrev->next = pLoop->next;
   2779          
   2780                // Free the memory
   2781                osal_mem_free( pLoop );
   2782          
   2783                // Notify the Application so that if the alarm condition still active then
   2784                // a new notification will be generated, and a new alarm record will be
   2785                // added to the alarm log
   2786                // zclGeneral_NotifyReset( alarmCode, clusterID ); // callback function?
   2787                return;
   2788              }
   2789              pPrev = pLoop;
   2790              pLoop = pLoop->next;
   2791            }
   2792          }
   2793          
   2794          /*********************************************************************
   2795           * @fn      zclGeneral_ResetAllAlarms
   2796           *
   2797           * @brief   Remove all alarms with endpoint
   2798           *
   2799           * @param   endpoint -
   2800           * @param   notifyApp -
   2801           *
   2802           * @return  none
   2803           */
   2804          void zclGeneral_ResetAllAlarms( uint8 endpoint, uint8 notifyApp )
   2805          {
   2806            zclGenAlarmItem_t *pLoop;
   2807            zclGenAlarmItem_t *pPrev;
   2808            zclGenAlarmItem_t *pNext;
   2809          
   2810            // Look for end of list
   2811            pLoop = zclGenAlarmTable;
   2812            pPrev = NULL;
   2813            while ( pLoop )
   2814            {
   2815              if (  pLoop->endpoint == endpoint )
   2816              {
   2817                if ( pPrev == NULL )
   2818                  zclGenAlarmTable = pLoop->next;
   2819                else
   2820                  pPrev->next = pLoop->next;
   2821          
   2822                pNext = pLoop->next;
   2823          
   2824                // Free the memory
   2825                osal_mem_free( pLoop );
   2826          
   2827                pLoop = pNext;
   2828              }
   2829              else
   2830              {
   2831                pPrev = pLoop;
   2832                pLoop = pLoop->next;
   2833              }
   2834            }
   2835          
   2836            if ( notifyApp )
   2837            {
   2838              // Notify the Application so that if any alarm conditions still active then
   2839              // a new notification will be generated, and a new alarm record will be
   2840              // added to the alarm log
   2841              // zclGeneral_NotifyResetAll(); // callback function?
   2842            }
   2843          }
   2844          
   2845          /*********************************************************************
   2846           * @fn      zclGeneral_ProcessInAlarmsServer
   2847           *
   2848           * @brief   Process in the received Alarms Command.
   2849           *
   2850           * @param   pInMsg - pointer to the incoming message
   2851           *
   2852           * @return  ZStatus_t
   2853           */
   2854          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg,
   2855                                                             zclGeneral_AppCallbacks_t *pCBs )
   2856          {
   2857            zclGeneral_Alarm_t *pAlarm;
   2858            uint8 *pData = pInMsg->pData;
   2859            ZStatus_t stat = ZSuccess;
   2860          
   2861            switch ( pInMsg->hdr.commandID )
   2862            {
   2863              case COMMAND_ALARMS_RESET:
   2864                zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pData[0],
   2865                                       BUILD_UINT16( pData[1], pData[2] ) );
   2866                break;
   2867          
   2868              case COMMAND_ALARMS_RESET_ALL:
   2869                zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, TRUE );
   2870                break;
   2871          
   2872              case COMMAND_ALARMS_GET:
   2873                pAlarm = zclGeneral_FindEarliestAlarm( pInMsg->msg->endPoint );
   2874                if ( pAlarm )
   2875                {
   2876                  // Send a response back
   2877                  zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2878                                                   ZCL_STATUS_SUCCESS, pAlarm->code,
   2879                                                   pAlarm->clusterID, pAlarm->timeStamp,
   2880                                                   true, pInMsg->hdr.transSeqNum );
   2881                  // Remove the entry from the Alarm table
   2882                  zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pAlarm->code, pAlarm->clusterID );
   2883                }
   2884                else
   2885                {
   2886                  // Send a response back
   2887                  zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2888                                                   ZCL_STATUS_NOT_FOUND, 0, 0, 0,
   2889                                                   true, pInMsg->hdr.transSeqNum );
   2890                }
   2891                stat = ZCL_STATUS_CMD_HAS_RSP;
   2892                break;
   2893          
   2894              case COMMAND_ALARMS_RESET_LOG:
   2895                zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, FALSE );
   2896                break;
   2897          
   2898          #ifdef SE_UK_EXT
   2899              case COMMAND_ALARMS_PUBLISH_EVENT_LOG:
   2900                if ( pCBs->pfnPublishEventLog )
   2901                {
   2902                  zclPublishEventLog_t eventLog;
   2903                  
   2904                  eventLog.logID = *pData++;
   2905                  eventLog.cmdIndex = *pData++;
   2906                  eventLog.totalCmds = *pData++;
   2907                    
   2908                  // First try to find out number of Sub Log Payloads
   2909                  eventLog.numSubLogs = (pInMsg->pDataLen-3)/(1+4); // event ID + event time
   2910                  if ( eventLog.numSubLogs > 0 )
   2911                  {
   2912                    // Try to alloc space for Log Payload
   2913                    eventLog.pLogs = (zclEventLogPayload_t *)osal_mem_alloc( sizeof( zclEventLogPayload_t ) *
   2914                                                                             eventLog.numSubLogs );
   2915                    if ( eventLog.pLogs != NULL )
   2916                    {
   2917                      // Copy Log Payload
   2918                      for ( uint8 i = 0; i < eventLog.numSubLogs; i++ )
   2919                      {
   2920                        eventLog.pLogs[i].eventId = *pData++;
   2921                        eventLog.pLogs[i].eventTime = osal_build_uint32( pData, 4 );
   2922                        pData += 4;
   2923                      }
   2924                    }
   2925                    else
   2926                    {
   2927                      stat = ZCL_STATUS_SOFTWARE_FAILURE;
   2928                    }
   2929                  }
   2930                  else
   2931                  {
   2932                    eventLog.pLogs = NULL;
   2933                  }
   2934                  
   2935                  if ( stat == ZSuccess )
   2936                  { 
   2937                    pCBs->pfnPublishEventLog( &(pInMsg->msg->srcAddr), &eventLog );
   2938                  }
   2939                  
   2940                  if ( eventLog.pLogs != NULL )
   2941                  {
   2942                    osal_mem_free( eventLog.pLogs );
   2943                  }
   2944                }
   2945                break;
   2946          #endif // SE_UK_EXT
   2947                
   2948              default:
   2949                stat = ZFailure;
   2950                break;
   2951            }
   2952          
   2953            return ( stat );
   2954          }
   2955          
   2956          /*********************************************************************
   2957           * @fn      zclGeneral_ProcessInAlarmsClient
   2958           *
   2959           * @brief   Process in the received Alarms Command.
   2960           *
   2961           * @param   pInMsg - pointer to the incoming message
   2962           *
   2963           * @return  ZStatus_t
   2964           */
   2965          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg,
   2966                                                             zclGeneral_AppCallbacks_t *pCBs )
   2967          {
   2968            uint8 *pData = pInMsg->pData;
   2969            zclAlarm_t alarm;
   2970            ZStatus_t stat = ZSuccess;
   2971          
   2972            osal_memset( (uint8*)&alarm, 0, sizeof( zclAlarm_t ) );
   2973          
   2974            switch ( pInMsg->hdr.commandID )
   2975            {
   2976              case COMMAND_ALARMS_ALARM:
   2977                if ( pCBs->pfnAlarm )
   2978                {
   2979                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   2980                  alarm.cmdID = pInMsg->hdr.commandID;
   2981                  alarm.status = *pData++;
   2982                  alarm.alarmCode = *pData++;
   2983                  alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
   2984                  pData += 2;
   2985                  alarm.timeStamp = osal_build_uint32( pData, 4 );
   2986          
   2987                  pCBs->pfnAlarm( &alarm );
   2988                }
   2989                break;
   2990          
   2991              case COMMAND_ALARMS_GET_RSP:
   2992                if ( pCBs->pfnAlarm )
   2993                {
   2994                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   2995                  alarm.cmdID = pInMsg->hdr.commandID;
   2996                  alarm.alarmCode = *pData++;
   2997                  alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
   2998          
   2999                  pCBs->pfnAlarm( &alarm );
   3000                }
   3001                break;
   3002          
   3003          #ifdef SE_UK_EXT
   3004              case COMMAND_ALARMS_GET_EVENT_LOG:
   3005                if ( pCBs->pfnGetEventLog )
   3006                {
   3007                  zclGetEventLog_t eventLog;
   3008                  
   3009                  eventLog.logID = *pData++;
   3010                  eventLog.startTime = osal_build_uint32( pData, 4 );
   3011                  pData += 4;
   3012                  eventLog.endTime = osal_build_uint32( pData, 4 );
   3013                  pData += 4;
   3014                  eventLog.numEvents = *pData;
   3015            
   3016                  pCBs->pfnGetEventLog( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3017                                        &eventLog, pInMsg->hdr.transSeqNum );
   3018                }
   3019                break;
   3020          #endif // SE_UK_EXT
   3021                
   3022              default:
   3023                stat = ZFailure;
   3024                break;
   3025            }
   3026          
   3027            return ( stat );
   3028          }
   3029          #endif // ZCL_ALARMS
   3030          
   3031          #ifdef ZCL_LOCATION
   3032          /*********************************************************************
   3033           * @fn      zclGeneral_ProcessInLocationServer
   3034           *
   3035           * @brief   Process in the received Location Command.
   3036           *
   3037           * @param   pInMsg - pointer to the incoming message
   3038           *
   3039           * @return  ZStatus_t
   3040           */
   3041          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg,
   3042                                                               zclGeneral_AppCallbacks_t *pCBs )
   3043          {
   3044            uint8 *pData = pInMsg->pData;
   3045            zclLocation_t cmd;
   3046            ZStatus_t stat = ZSuccess;
   3047          
   3048            osal_memset( (uint8*)&cmd, 0, sizeof( zclLocation_t ) );
   3049          
   3050            switch ( pInMsg->hdr.commandID )
   3051            {
   3052              case COMMAND_LOCATION_SET_ABSOLUTE:
   3053                cmd.un.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   3054                pData += 2;
   3055                cmd.un.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   3056                pData += 2;
   3057                cmd.un.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   3058                pData += 2;
   3059                cmd.un.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   3060                pData += 2;
   3061                cmd.un.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3062          
   3063                if ( pCBs->pfnLocation )
   3064                {
   3065                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3066                  cmd.cmdID = pInMsg->hdr.commandID;
   3067          
   3068                  // Update the absolute location info
   3069                  pCBs->pfnLocation( &cmd );
   3070                }
   3071                break;
   3072          
   3073              case COMMAND_LOCATION_SET_DEV_CFG:
   3074                cmd.un.devCfg.power = BUILD_UINT16( pData[0], pData[1] );
   3075                pData += 2;
   3076                cmd.un.devCfg.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3077                pData += 2;
   3078                cmd.un.devCfg.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   3079                pData += 2;
   3080                cmd.un.devCfg.numMeasurements = *pData++;
   3081                cmd.un.devCfg.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   3082          
   3083                if ( pCBs->pfnLocation )
   3084                {
   3085                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3086                  cmd.cmdID = pInMsg->hdr.commandID;
   3087          
   3088                  // Update the device configuration info
   3089                  pCBs->pfnLocation( &cmd );
   3090                }
   3091                break;
   3092          
   3093              case COMMAND_LOCATION_GET_DEV_CFG:
   3094                cmd.un.ieeeAddr = pData;
   3095          
   3096                if ( pCBs->pfnLocation )
   3097                {
   3098                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3099                  cmd.cmdID = pInMsg->hdr.commandID;
   3100                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   3101          
   3102                  // Retreive the Device Configuration
   3103                  pCBs->pfnLocation( &cmd );
   3104                }
   3105                stat = ZCL_STATUS_CMD_HAS_RSP;
   3106                break;
   3107          
   3108              case COMMAND_LOCATION_GET_DATA:
   3109                cmd.un.loc.bitmap.locByte = *pData++;
   3110                cmd.un.loc.numResponses = *pData++;
   3111          
   3112                if ( cmd.un.loc.brdcastResponse == 0 ) // command is sent as a unicast
   3113                  osal_cpyExtAddr( cmd.un.loc.targetAddr, pData );
   3114          
   3115                if ( pCBs->pfnLocation )
   3116                {
   3117                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   3118                  cmd.cmdID = pInMsg->hdr.commandID;
   3119                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   3120          
   3121                  // Retreive the Location Data
   3122                  pCBs->pfnLocation( &cmd );
   3123                }
   3124                stat = ZCL_STATUS_CMD_HAS_RSP;
   3125                break;
   3126          
   3127              default:
   3128                stat = ZFailure;
   3129                break;
   3130            }
   3131          
   3132            return ( stat );
   3133          }
   3134          
   3135          /*********************************************************************
   3136           * @fn      zclGeneral_ProcessInLocationDataRsp
   3137           *
   3138           * @brief   Process in the received Location Command.
   3139           *
   3140           * @param   pInMsg - pointer to the incoming message
   3141           *
   3142           * @return  ZStatus_t
   3143           */
   3144          static void zclGeneral_ProcessInLocationDataRsp( zclIncoming_t *pInMsg,
   3145                                                           zclGeneral_AppCallbacks_t *pCBs )
   3146          {
   3147            uint8 *pData = pInMsg->pData;
   3148            zclLocationRsp_t rsp;
   3149          
   3150            osal_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   3151          
   3152            if ( pCBs->pfnLocationRsp )
   3153            {
   3154              if ( pInMsg->hdr.commandID == COMMAND_LOCATION_DATA_RSP )
   3155                rsp.un.loc.status = *pData++;
   3156          
   3157              if ( pInMsg->hdr.commandID != COMMAND_LOCATION_DATA_RSP ||
   3158                   rsp.un.loc.status == ZCL_STATUS_SUCCESS )
   3159              {
   3160                rsp.un.loc.data.type = *pData++;
   3161                rsp.un.loc.data.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   3162                pData += 2;
   3163                rsp.un.loc.data.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   3164                pData += 2;
   3165          
   3166                if ( locationType2D( rsp.un.loc.data.type ) == 0 )
   3167                {
   3168                  rsp.un.loc.data.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   3169                  pData += 2;
   3170                }
   3171          
   3172                if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   3173                {
   3174                  rsp.un.loc.data.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   3175                  pData += 2;
   3176                  rsp.un.loc.data.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3177                  pData += 2;
   3178                }
   3179          
   3180                if ( locationTypeAbsolute( rsp.un.loc.data.type ) == 0 )
   3181                {
   3182                  if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   3183                    rsp.un.loc.data.calcLoc.locationMethod = *pData++;
   3184          
   3185                  rsp.un.loc.data.calcLoc.qualityMeasure = *pData++;
   3186                  rsp.un.loc.data.calcLoc.locationAge = BUILD_UINT16( pData[0], pData[1] );
   3187                }
   3188              }
   3189          
   3190              rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3191              rsp.cmdID = pInMsg->hdr.commandID;
   3192          
   3193              // Notify the Application
   3194              pCBs->pfnLocationRsp( &rsp );
   3195            }
   3196          }
   3197          
   3198          /*********************************************************************
   3199           * @fn      zclGeneral_ProcessInLocationClient
   3200           *
   3201           * @brief   Process in the received Location Command.
   3202           *
   3203           * @param   pInMsg - pointer to the incoming message
   3204           *
   3205           * @return  ZStatus_t
   3206           */
   3207          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg,
   3208                                                               zclGeneral_AppCallbacks_t *pCBs )
   3209          {
   3210            uint8 *pData = pInMsg->pData;
   3211            zclLocationRsp_t rsp;
   3212            ZStatus_t stat = ZSuccess;
   3213          
   3214            osal_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   3215          
   3216            switch ( pInMsg->hdr.commandID )
   3217            {
   3218              case COMMAND_LOCATION_DEV_CFG_RSP:
   3219                if ( pCBs->pfnLocationRsp )
   3220                {
   3221                  rsp.un.devCfg.status = *pData++;
   3222                  if ( rsp.un.devCfg.status == ZCL_STATUS_SUCCESS )
   3223                  {
   3224                    rsp.un.devCfg.data.power = BUILD_UINT16( pData[0], pData[1] );
   3225                    pData += 2;
   3226                    rsp.un.devCfg.data.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3227                    pData += 2;
   3228                    rsp.un.devCfg.data.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   3229                    pData += 2;
   3230                    rsp.un.devCfg.data.numMeasurements = *pData++;
   3231                    rsp.un.devCfg.data.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   3232          
   3233                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3234                    rsp.cmdID = pInMsg->hdr.commandID;
   3235          
   3236                    // Notify the Application
   3237                    pCBs->pfnLocationRsp( &rsp );
   3238                  }
   3239                }
   3240                break;
   3241          
   3242              case COMMAND_LOCATION_DATA_RSP:
   3243              case COMMAND_LOCATION_DATA_NOTIF:
   3244              case COMMAND_LOCATION_COMPACT_DATA_NOTIF:
   3245                zclGeneral_ProcessInLocationDataRsp( pInMsg, pCBs );
   3246                break;
   3247          
   3248              case COMMAND_LOCATION_RSSI_PING:
   3249                if ( pCBs->pfnLocationRsp )
   3250                {
   3251                  rsp.un.locationType = *pData;
   3252          
   3253                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3254                  rsp.cmdID = pInMsg->hdr.commandID;
   3255          
   3256                  // Notify the Application
   3257                  pCBs->pfnLocationRsp( &rsp );
   3258                }
   3259                break;
   3260          
   3261              default:
   3262                stat = ZFailure;
   3263                break;
   3264            }
   3265          
   3266            return ( stat );
   3267          }
   3268          #endif // ZCL_LOCATION
   3269          
   3270          #ifdef ZCL_SCENES
   3271          /*********************************************************************
   3272           * @fn      zclGeneral_ScenesInitNV
   3273           *
   3274           * @brief   Initialize the NV Scene Table Items
   3275           *
   3276           * @param   none
   3277           *
   3278           * @return  number of scenes
   3279           */
   3280          static uint8 zclGeneral_ScenesInitNV( void )
   3281          {
   3282            uint8  status;
   3283            uint16 size;
   3284          
   3285            size = (uint16)((sizeof ( nvGenScenesHdr_t ))
   3286                            + ( sizeof( zclGenSceneNVItem_t ) * ZCL_GEN_MAX_SCENES ));
   3287          
   3288            status = osal_nv_item_init( ZCD_NV_SCENE_TABLE, size, NULL );
   3289          
   3290            if ( status != ZSUCCESS )
   3291            {
   3292              zclGeneral_ScenesSetDefaultNV();
   3293            }
   3294          
   3295            return status;
   3296          }
   3297          
   3298          /*********************************************************************
   3299           * @fn          zclGeneral_ScenesSetDefaultNV
   3300           *
   3301           * @brief       Write the defaults to NV
   3302           *
   3303           * @param       none
   3304           *
   3305           * @return      none
   3306           */
   3307          static void zclGeneral_ScenesSetDefaultNV( void )
   3308          {
   3309            nvGenScenesHdr_t hdr;
   3310          
   3311            // Initialize the header
   3312            hdr.numRecs = 0;
   3313          
   3314            // Save off the header
   3315            osal_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3316          }
   3317          
   3318          /*********************************************************************
   3319           * @fn          zclGeneral_ScenesWriteNV
   3320           *
   3321           * @brief       Save the Scene Table in NV
   3322           *
   3323           * @param       none
   3324           *
   3325           * @return      none
   3326           */
   3327          static void zclGeneral_ScenesWriteNV( void )
   3328          {
   3329            nvGenScenesHdr_t hdr;
   3330            zclGenSceneItem_t *pLoop;
   3331            zclGenSceneNVItem_t item;
   3332          
   3333            hdr.numRecs = 0;
   3334          
   3335            // Look for end of list
   3336            pLoop = zclGenSceneTable;
   3337            while ( pLoop )
   3338            {
   3339              // Build the record
   3340              item.endpoint = pLoop->endpoint;
   3341              osal_memcpy( &(item.scene), &(pLoop->scene), sizeof ( zclGeneral_Scene_t ) );
   3342          
   3343              // Save the record to NV
   3344              osal_nv_write( ZCD_NV_SCENE_TABLE,
   3345                      (uint16)((sizeof( nvGenScenesHdr_t )) + (hdr.numRecs * sizeof ( zclGenSceneNVItem_t ))),
   3346                              sizeof ( zclGenSceneNVItem_t ), &item );
   3347          
   3348              hdr.numRecs++;
   3349          
   3350              pLoop = pLoop->next;
   3351            }
   3352          
   3353            // Save off the header
   3354            osal_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3355          }
   3356          
   3357          /*********************************************************************
   3358           * @fn          zclGeneral_ScenesRestoreFromNV
   3359           *
   3360           * @brief       Restore the Scene table from NV
   3361           *
   3362           * @param       none
   3363           *
   3364           * @return      Number of entries restored
   3365           */
   3366          static uint16 zclGeneral_ScenesRestoreFromNV( void )
   3367          {
   3368            uint16 x;
   3369            nvGenScenesHdr_t hdr;
   3370          
   3371            zclGenSceneNVItem_t item;
   3372            uint16 numAdded = 0;
   3373          
   3374            if ( osal_nv_read( ZCD_NV_SCENE_TABLE, 0, sizeof(nvGenScenesHdr_t), &hdr ) == ZSuccess )
   3375            {
   3376              // Read in the device list
   3377              for ( x = 0; x < hdr.numRecs; x++ )
   3378              {
   3379                if ( osal_nv_read( ZCD_NV_SCENE_TABLE,
   3380                          (uint16)(sizeof(nvGenScenesHdr_t) + (x * sizeof ( zclGenSceneNVItem_t ))),
   3381                                            sizeof ( zclGenSceneNVItem_t ), &item ) == ZSUCCESS )
   3382                {
   3383                  // Add the scene
   3384                  if ( zclGeneral_AddScene( item.endpoint, &(item.scene) ) == ZSuccess )
   3385                  {
   3386                    numAdded++;
   3387                  }
   3388                }
   3389              }
   3390            }
   3391          
   3392            return ( numAdded );
   3393          }
   3394          #endif // ZCL_SCENES
   3395          
   3396          /***************************************************************************
   3397          ****************************************************************************/

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     zclGeneral_HdlInSpecificCommands
                                        0      0     10
       -> zclGeneral_ProcessInIdentity
                                        0      0     20
     zclGeneral_HdlIncoming             2      0      0
       -> zclGeneral_HdlInSpecificCommands
                                        4      0      0
     zclGeneral_ProcessInIdentity       0      0     38
       -> zclFindAttrRec                0      0     56
       -> zclReadAttrData               0      0     56
       -> zclGeneral_SendIdentifyQueryResponse
                                        0      0     56
     zclGeneral_RegisterCmdCallbacks
                                        1      0     14
       -> zcl_registerPlugin            0      0     28
       -> osal_mem_alloc                0      0     24
     zclGeneral_SendIdentify            1      0     25
       -> zcl_SendCommand               0      0     46
     zclGeneral_SendIdentifyQueryResponse
                                        1      0     51
       -> zcl_SendCommand               0      0     46


   Segment part sizes:

     Function/Label                               Bytes
     --------------                               -----
     zclGenCBs                                       2
     zclGenPluginRegisted                            1
     zclGeneral_RegisterCmdCallbacks
                                                   151
     ?Subroutine0                                    5
     zclGeneral_SendIdentify                        82
     ?Subroutine1                                   32
     ??Subroutine10_0                                5
     ?Subroutine3                                   13
     ?Subroutine2                                   17
     zclGeneral_SendIdentifyQueryResponse
                                                    81
     zclGeneral_HdlIncoming                         37
     zclGeneral_HdlInSpecificCommands
                                                   187
     ?Subroutine7                                   10
     ?Subroutine6                                    9
     ?Subroutine8                                    7
     ?Subroutine9                                   12
     zclGeneral_ProcessInIdentity                  344
     ?Subroutine5                                    6
     ?Subroutine4                                   11
     ??zclGeneral_RegisterCmdCallbacks?relay         6
     ??zclGeneral_SendIdentify?relay                 6
     ??zclGeneral_SendIdentifyQueryResponse?relay    6
     ??zclGeneral_HdlIncoming?relay                  6
     ??zclGeneral_HdlInSpecificCommands?relay        6
     ??zclGeneral_ProcessInIdentity?relay            6

 
 1 009 bytes in segment BANKED_CODE
    36 bytes in segment BANK_RELAYS
     3 bytes in segment XDATA_Z
 
 1 045 bytes of CODE  memory
     3 bytes of XDATA memory

Errors: none
Warnings: none
