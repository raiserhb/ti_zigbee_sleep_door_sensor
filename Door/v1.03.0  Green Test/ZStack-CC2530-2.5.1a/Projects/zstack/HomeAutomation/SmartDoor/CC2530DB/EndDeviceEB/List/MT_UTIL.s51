///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.10.1.10194/W32 for 8051        08/Aug/2017  09:57:13 /
// Copyright 2004-2011 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data_rom                                          /
//    Dptr setup         =  1,16                                              /
//    Source file        =  D:\work space\Smart Product\Two YHY\Door\v1.03.0  /
//                           Green\ZStack-CC2530-2.5.1a\Components\mt\MT_UTIL /
//                          .c                                                /
//    Command line       =  -f "D:\work space\Smart Product\Two               /
//                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proj /
//                          ects\zstack\HomeAutomation\SmartDoor\CC2530DB\..\ /
//                          Tools\CC2530DB\f8wEndev.cfg" (-DCPU32MHZ          /
//                          -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3        /
//                          -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3             /
//                          -DHAL_KEY=FALSE -DHAL_LED=FALSE -DHAL_LCD=FALSE   /
//                          -DHAL_ADC=FALSE -DNV_RESTORE -DNV_INIT            /
//                          -DPOWER_SAVING -DTC_LINKKEY_JOIN) -f "D:\work     /
//                          space\Smart Product\Two YHY\Door\v1.03.0          /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\Tools\CC2530DB\f8w /
//                          Config.cfg" (-DZIGBEEPRO -DSECURE=1               /
//                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                 /
//                          -DDEFAULT_CHANLIST=0x06108800                     /
//                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                      /
//                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M /
//                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             /
//                          -DBEACON_REQ_DELAY_MASK=0x00FF                    /
//                          -DLINK_STATUS_JITTER_MASK=0x007F                  /
//                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P /
//                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           /
//                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3   /
//                          -DNWK_MAX_DATA_RETRIES=2                          /
//                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        /
//                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40          /
//                          -DNWK_MAX_BINDING_ENTRIES=4                       /
//                          -DMAX_BINDING_CLUSTER_IDS=4                       /
//                          -DDEFAULT_KEY={0x58,0x69,0x6E,0x67,0x48,0x75,     /
//                          0x6F,0x59,0x75,0x61,0x6E,0x53,0x6D,0x61,0x72,     /
//                          0x74} -DMAC_MAX_FRAME_SIZE=116                    /
//                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const    /
//                          __code" -DGENERIC=__generic                       /
//                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=0          /
//                          -DQUEUED_POLL_RATE=0 -DRESPONSE_POLL_RATE=0       /
//                          -DREJOIN_POLL_RATE=440) -f "D:\work space\Smart   /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\Tools\CC2530DB\f8w /
//                          ZCL.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_REPORT     /
//                          -DZCL_BASIC -DZCL_IDENTIFY -DZCL_ON_OFF           /
//                          -DZCL_KEY_ESTABLISH -DZCL_KEY_ESTABLISHMENT_KEY_G /
//                          ENERATE_TIMEOUT=4 -DZCL_KEY_ESTABLISHMENT_MAC_GEN /
//                          ERATE_TIMEOUT=10 -DZCL_KEY_ESTABLISHMENT_EKEY_GEN /
//                          ERATE_TIMEOUT=10 -DZCL_LOAD_CONTROL               /
//                          -DZCL_SIMPLE_METERING -DZCL_PRICING               /
//                          -DZCL_MESSAGE -DZCL_TUNNELING -DZCL_TOU)          /
//                          -DZCL_DEVICE_MGMT "D:\work space\Smart            /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Components\mt\MT_UTIL. /
//                          c" -lC "D:\work space\Smart Product\Two           /
//                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proj /
//                          ects\zstack\HomeAutomation\SmartDoor\CC2530DB\End /
//                          DeviceEB\List\" -lA "D:\work space\Smart          /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\EndDeviceEB\List\"    /
//                          --diag_suppress Pe001,Pa010 -o "D:\work           /
//                          space\Smart Product\Two YHY\Door\v1.03.0          /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\EndDeviceEB\Obj\" -e  /
//                          --debug --core=plain --dptr=16,1                  /
//                          --data_model=large --code_model=banked            /
//                          --calling_convention=xdata_reentrant              /
//                          --place_constants=data_rom --nr_virtual_regs 16   /
//                          -I "D:\work space\Smart Product\Two               /
//                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proj /
//                          ects\zstack\HomeAutomation\SmartDoor\CC2530DB\"   /
//                          -I "D:\work space\Smart Product\Two               /
//                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proj /
//                          ects\zstack\HomeAutomation\SmartDoor\CC2530DB\..\ /
//                          Source\" -I "D:\work space\Smart Product\Two      /
//                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proj /
//                          ects\zstack\HomeAutomation\SmartDoor\CC2530DB\..\ /
//                          ..\Source\" -I "D:\work space\Smart Product\Two   /
//                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proj /
//                          ects\zstack\HomeAutomation\SmartDoor\CC2530DB\..\ /
//                          ..\..\ZMain\TI2530DB\" -I "D:\work space\Smart    /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\hal\include\" -I "D:\work space\Smart        /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\hal\target\CC2530EB\" -I "D:\work            /
//                          space\Smart Product\Two YHY\Door\v1.03.0          /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\mac\include\" -I "D:\work space\Smart        /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\mac\high_level\" -I "D:\work space\Smart     /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\mac\low_level\srf04\" -I "D:\work            /
//                          space\Smart Product\Two YHY\Door\v1.03.0          /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\mac\low_level\srf04\single_chip\" -I         /
//                          "D:\work space\Smart Product\Two                  /
//                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proj /
//                          ects\zstack\HomeAutomation\SmartDoor\CC2530DB\..\ /
//                          ..\..\..\..\Components\mt\" -I "D:\work           /
//                          space\Smart Product\Two YHY\Door\v1.03.0          /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\osal\include\" -I "D:\work space\Smart       /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\services\saddr\" -I "D:\work space\Smart     /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\services\sdata\" -I "D:\work space\Smart     /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\stack\af\" -I "D:\work space\Smart           /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\stack\nwk\" -I "D:\work space\Smart          /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\stack\sapi\" -I "D:\work space\Smart         /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\stack\sec\" -I "D:\work space\Smart          /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\stack\sys\" -I "D:\work space\Smart          /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\stack\zcl\" -I "D:\work space\Smart          /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\stack\zdo\" -I "D:\work space\Smart          /
//                          Product\Two YHY\Door\v1.03.0                      /
//                          Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeAu /
//                          tomation\SmartDoor\CC2530DB\..\..\..\..\..\Compon /
//                          ents\zmac\" -I "D:\work space\Smart Product\Two   /
//                          YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Proj /
//                          ects\zstack\HomeAutomation\SmartDoor\CC2530DB\..\ /
//                          ..\..\..\..\Components\zmac\f8w\" -Oh             /
//                          --require_prototypes                              /
//    List file          =  D:\work space\Smart Product\Two YHY\Door\v1.03.0  /
//                           Green\ZStack-CC2530-2.5.1a\Projects\zstack\HomeA /
//                          utomation\SmartDoor\CC2530DB\EndDeviceEB\List\MT_ /
//                          UTIL.s51                                          /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME MT_UTIL

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN __INIT_XDATA_Z

        PUBLIC zcl_key_establish_task_id
// D:\work space\Smart Product\Two YHY\Door\v1.03.0  Green\ZStack-CC2530-2.5.1a\Components\mt\MT_UTIL.c
//    1 /***************************************************************************************************
//    2   Filename:       MT_UTIL.c
//    3   Revised:        $Date: 2012-02-25 17:43:09 -0800 (Sat, 25 Feb 2012) $
//    4   Revision:       $Revision: 29520 $
//    5 
//    6   Description:    MonitorTest Utility Functions
//    7 
//    8   Copyright 2007-2012 Texas Instruments Incorporated. All rights reserved.
//    9 
//   10   IMPORTANT: Your use of this Software is limited to those specific rights
//   11   granted under the terms of a software license agreement between the user
//   12   who downloaded the software, his/her employer (which must be your employer)
//   13   and Texas Instruments Incorporated (the "License"). You may not use this
//   14   Software unless you agree to abide by the terms of the License. The License
//   15   limits your use, and you acknowledge, that the Software may not be modified,
//   16   copied or distributed unless embedded on a Texas Instruments microcontroller
//   17   or used solely and exclusively in conjunction with a Texas Instruments radio
//   18   frequency transceiver, which is integrated into your product. Other than for
//   19   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   20   works of, modify, distribute, perform, display or sell this Software and/or
//   21   its documentation for any purpose.
//   22 
//   23   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   24   PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   25   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   26   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   27   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   28   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   29   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   30   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   31   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   32   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   33   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   34 
//   35   Should you have any questions regarding your right to use this Software,
//   36   contact Texas Instruments Incorporated at www.TI.com.
//   37 
//   38  ***************************************************************************************************/
//   39 
//   40 /***************************************************************************************************
//   41  * INCLUDES
//   42  ***************************************************************************************************/
//   43 #include "ZComDef.h"
//   44 
//   45 #include "AddrMgr.h"
//   46 
//   47 #include "OnBoard.h"   /* This is here because of the key reading */
//   48 #include "hal_key.h"
//   49 #include "hal_led.h"
//   50 #include "OSAL_Nv.h"
//   51 #include "osal.h"
//   52 #include "NLMEDE.h"
//   53 #include "MT.h"
//   54 #include "MT_UTIL.h"
//   55 #include "MT_MAC.h"
//   56 #include "ssp.h"
//   57 #if defined ZCL_KEY_ESTABLISH
//   58 #include "zcl_key_establish.h"
//   59 #endif
//   60 #if defined TC_LINKKEY_JOIN
//   61 #include "zcl_se.h"
//   62 #endif
//   63 
//   64 #if !defined NONWK
//   65 #include "MT_ZDO.h"
//   66 #include "MT_SAPI.h"
//   67 #include "MT_NWK.h"
//   68 #include "MT_AF.h"
//   69 #include "AssocList.h"
//   70 #include "ZDApp.h"
//   71 #include "ZDSecMgr.h"
//   72 #endif
//   73 /***************************************************************************************************
//   74  * CONSTANTS
//   75  ***************************************************************************************************/
//   76 #define MT_UTIL_DEVICE_INFO_RESPONSE_LEN 14
//   77 #define MT_UTIL_STATUS_LEN    1
//   78 #define MT_UTIL_FRM_CTR_LEN   4
//   79 // Status + LinkKeyDataLen + Tx+Rx Frame counter.
//   80 #define MT_APSME_LINKKEY_GET_RSP_LEN (MT_UTIL_STATUS_LEN + SEC_KEY_LEN + (MT_UTIL_FRM_CTR_LEN * 2))
//   81 // Status + NV id
//   82 #define MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN (MT_UTIL_STATUS_LEN + 2)
//   83 
//   84 /***************************************************************************************************
//   85  * LOCAL VARIABLES
//   86  ***************************************************************************************************/
//   87 #if defined ZCL_KEY_ESTABLISH

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//   88 uint8 zcl_key_establish_task_id;
zcl_key_establish_task_id:
        DS 1
        REQUIRE __INIT_XDATA_Z

        END
//   89 #endif
//   90 
//   91 /***************************************************************************************************
//   92  * LOCAL FUNCTIONS
//   93  ***************************************************************************************************/
//   94 #ifdef AUTO_PEND
//   95 static void MT_UtilRevExtCpy( uint8 *pDst, uint8 *pSrc );
//   96 static void MT_UtilSpi2Addr( zAddrType_t *pDst, uint8 *pSrc );
//   97 #endif
//   98 
//   99 #if defined (MT_UTIL_FUNC)
//  100 void MT_UtilGetDeviceInfo(void);
//  101 void MT_UtilGetNvInfo(void);
//  102 void MT_UtilSetPanID(uint8 *pBuf);
//  103 void MT_UtilGetPanID(uint8 *pBuf);
//  104 void MT_UtilSetChannels(uint8 *pBuf);
//  105 void MT_UtilSetSecLevel(uint8 *pBuf);
//  106 void MT_UtilSetPreCfgKey(uint8 *pBuf);
//  107 void MT_UtilCallbackSub(uint8 *pData);
//  108 void MT_UtilKeyEvent(uint8 *pBuf);
//  109 void MT_UtilTimeAlive(void);
//  110 void MT_UtilLedControl(uint8 *pBuf);
//  111 void MT_UtilSrcMatchEnable (uint8 *pBuf);
//  112 void MT_UtilSrcMatchAddEntry (uint8 *pBuf);
//  113 void MT_UtilSrcMatchDeleteEntry (uint8 *pBuf);
//  114 void MT_UtilSrcMatchCheckSrcAddr (uint8 *pBuf);
//  115 void MT_UtilSrcMatchAckAllPending (uint8 *pBuf);
//  116 void MT_UtilSrcMatchCheckAllPending (uint8 *pBuf);
//  117 
//  118 #if !defined NONWK
//  119 void MT_UtilDataReq(uint8 *pBuf);
//  120 static void MT_UtilAddrMgrEntryLookupExt(uint8 *pBuf);
//  121 static void MT_UtilAddrMgrEntryLookupNwk(uint8 *pBuf);
//  122 #if defined MT_SYS_KEY_MANAGEMENT
//  123 static void MT_UtilAPSME_LinkKeyDataGet(uint8 *pBuf);
//  124 static void MT_UtilAPSME_LinkKeyNvIdGet(uint8 *pBuf);
//  125 #endif //MT_SYS_KEY_MANAGEMENT
//  126 static void MT_UtilAPSME_RequestKeyCmd(uint8 *pBuf);
//  127 static void MT_UtilAssocCount(uint8 *pBuf);
//  128 static void MT_UtilAssocFindDevice(uint8 *pBuf);
//  129 static void MT_UtilAssocGetWithAddress(uint8 *pBuf);
//  130 static void packDev_t(uint8 *pBuf, associated_devices_t *pDev);
//  131 #if defined ZCL_KEY_ESTABLISH
//  132 static void MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(uint8 *pBuf);
//  133 static void MT_UtilzclGeneral_KeyEstablishment_ECDSASign(uint8 *pBuf);
//  134 #endif // ZCL_KEY_ESTABLISH
//  135 static void MT_UtilSync(void);
//  136 #endif // !defined NONWK
//  137 #endif // MT_UTIL_FUNC
//  138 
//  139 #if defined (MT_UTIL_FUNC)
//  140 /***************************************************************************************************
//  141  * @fn      MT_UtilProcessing
//  142  *
//  143  * @brief   Process all the DEBUG commands that are issued by test tool
//  144  *
//  145  * @param   pBuf  - pointer to received SPI data message
//  146  *
//  147  * @return  status
//  148  ***************************************************************************************************/
//  149 uint8 MT_UtilCommandProcessing(uint8 *pBuf)
//  150 {
//  151   uint8 status = MT_RPC_SUCCESS;
//  152 
//  153   switch (pBuf[MT_RPC_POS_CMD1])
//  154   {
//  155 // CC253X MAC Network Processor does not have NV support
//  156 #if !defined(CC253X_MACNP)
//  157     case MT_UTIL_GET_DEVICE_INFO:
//  158       MT_UtilGetDeviceInfo();
//  159       break;
//  160 
//  161     case MT_UTIL_GET_NV_INFO:
//  162       MT_UtilGetNvInfo();
//  163       break;
//  164 
//  165     case MT_UTIL_SET_PANID:
//  166       MT_UtilSetPanID(pBuf);
//  167       break;
//  168 
//  169     case MT_UTIL_GET_PANID:
//  170       MT_UtilGetPanID(pBuf);
//  171       break;
//  172 
//  173     case MT_UTIL_SET_CHANNELS:
//  174       MT_UtilSetChannels(pBuf);
//  175       break;
//  176 
//  177     case MT_UTIL_SET_SECLEVEL:
//  178       MT_UtilSetSecLevel(pBuf);
//  179       break;
//  180 
//  181     case MT_UTIL_SET_PRECFGKEY:
//  182       MT_UtilSetPreCfgKey(pBuf);
//  183       break;
//  184 #endif
//  185     case MT_UTIL_CALLBACK_SUB_CMD:
//  186       MT_UtilCallbackSub(pBuf);
//  187       break;
//  188 
//  189     case MT_UTIL_KEY_EVENT:
//  190 #if (defined HAL_KEY) && (HAL_KEY == TRUE)
//  191       MT_UtilKeyEvent(pBuf);
//  192 #endif
//  193       break;
//  194 
//  195     case MT_UTIL_TIME_ALIVE:
//  196       MT_UtilTimeAlive();
//  197       break;
//  198 
//  199     case MT_UTIL_LED_CONTROL:
//  200 #if (defined HAL_LED) && (HAL_LED == TRUE)
//  201       MT_UtilLedControl(pBuf);
//  202 #endif
//  203       break;
//  204 
//  205     case MT_UTIL_SRC_MATCH_ENABLE:
//  206       MT_UtilSrcMatchEnable(pBuf);
//  207       break;
//  208 
//  209     case MT_UTIL_SRC_MATCH_ADD_ENTRY:
//  210       MT_UtilSrcMatchAddEntry(pBuf);
//  211       break;
//  212 
//  213     case MT_UTIL_SRC_MATCH_DEL_ENTRY:
//  214       MT_UtilSrcMatchDeleteEntry(pBuf);
//  215       break;
//  216 
//  217     case MT_UTIL_SRC_MATCH_CHECK_SRC_ADDR:
//  218       MT_UtilSrcMatchCheckSrcAddr(pBuf);
//  219       break;
//  220 
//  221     case MT_UTIL_SRC_MATCH_ACK_ALL_PENDING:
//  222       MT_UtilSrcMatchAckAllPending(pBuf);
//  223       break;
//  224 
//  225     case MT_UTIL_SRC_MATCH_CHECK_ALL_PENDING:
//  226       MT_UtilSrcMatchCheckAllPending(pBuf);
//  227       break;
//  228 
//  229     case MT_UTIL_TEST_LOOPBACK:
//  230       MT_BuildAndSendZToolResponse((MT_RPC_CMD_SRSP|(uint8)MT_RPC_SYS_UTIL), MT_UTIL_TEST_LOOPBACK,
//  231                                     pBuf[MT_RPC_POS_LEN], (pBuf+MT_RPC_FRAME_HDR_SZ));
//  232       break;
//  233 
//  234 #if !defined NONWK
//  235     case MT_UTIL_DATA_REQ:
//  236       MT_UtilDataReq(pBuf);
//  237       break;
//  238 
//  239     case MT_UTIL_ADDRMGR_EXT_ADDR_LOOKUP:
//  240       MT_UtilAddrMgrEntryLookupExt(pBuf);
//  241       break;
//  242 
//  243     case MT_UTIL_ADDRMGR_NWK_ADDR_LOOKUP:
//  244       MT_UtilAddrMgrEntryLookupNwk(pBuf);
//  245       break;
//  246 
//  247 #if defined MT_SYS_KEY_MANAGEMENT
//  248     case MT_UTIL_APSME_LINK_KEY_DATA_GET:
//  249       MT_UtilAPSME_LinkKeyDataGet(pBuf);
//  250       break;
//  251 
//  252     case MT_UTIL_APSME_LINK_KEY_NV_ID_GET:
//  253       MT_UtilAPSME_LinkKeyNvIdGet(pBuf);
//  254       break;
//  255 #endif // MT_SYS_KEY_MANAGEMENT
//  256 
//  257     case MT_UTIL_APSME_REQUEST_KEY_CMD:
//  258       MT_UtilAPSME_RequestKeyCmd(pBuf);
//  259       break;
//  260 
//  261     case MT_UTIL_ASSOC_COUNT:
//  262       MT_UtilAssocCount(pBuf);
//  263       break;
//  264 
//  265     case MT_UTIL_ASSOC_FIND_DEVICE:
//  266       MT_UtilAssocFindDevice(pBuf);
//  267       break;
//  268 
//  269     case MT_UTIL_ASSOC_GET_WITH_ADDRESS:
//  270       MT_UtilAssocGetWithAddress(pBuf);
//  271       break;
//  272 
//  273 #if defined ZCL_KEY_ESTABLISH
//  274     case MT_UTIL_ZCL_KEY_EST_INIT_EST:
//  275       MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(pBuf);
//  276       break;
//  277 
//  278     case MT_UTIL_ZCL_KEY_EST_SIGN:
//  279       MT_UtilzclGeneral_KeyEstablishment_ECDSASign(pBuf);
//  280       break;
//  281 #endif
//  282 
//  283     case MT_UTIL_SYNC_REQ:
//  284       MT_UtilSync();
//  285       break;
//  286 #endif /* !defined NONWK */
//  287 
//  288     default:
//  289       status = MT_RPC_ERR_COMMAND_ID;
//  290       break;
//  291   }
//  292 
//  293   return status;
//  294 }
//  295 
//  296 /***************************************************************************************************
//  297  * @fn      MT_UtilGetDeviceInfo
//  298  *
//  299  * @brief   The Get Device Info serial message.
//  300  *
//  301  * @param   None.
//  302  *
//  303  * @return  void
//  304  ***************************************************************************************************/
//  305 void MT_UtilGetDeviceInfo(void)
//  306 {
//  307   uint8  *buf;
//  308   uint8  *pBuf;
//  309   uint8  bufLen = MT_UTIL_DEVICE_INFO_RESPONSE_LEN;
//  310   uint16 *assocList = NULL;
//  311 
//  312 #if !defined NONWK
//  313   uint8  assocCnt = 0;
//  314 
//  315   if (ZG_DEVICE_RTR_TYPE)
//  316   {
//  317     assocList = AssocMakeList( &assocCnt );
//  318     bufLen += (assocCnt * sizeof(uint16));
//  319   }
//  320 #endif
//  321 
//  322   buf = osal_mem_alloc( bufLen );
//  323   if ( buf )
//  324   {
//  325     pBuf = buf;
//  326 
//  327     *pBuf++ = ZSUCCESS; // Status
//  328 
//  329     osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf );
//  330     pBuf += Z_EXTADDR_LEN;
//  331 
//  332 #if defined NONWK
//  333     // Skip past ZStack only parameters for NONWK
//  334     *pBuf++ = 0;
//  335     *pBuf++ = 0;
//  336     *pBuf++ = 0;
//  337     *pBuf++ = 0;
//  338     *pBuf = 0;
//  339 #else
//  340     {
//  341       uint16 shortAddr = NLME_GetShortAddr();
//  342       *pBuf++ = LO_UINT16( shortAddr );
//  343       *pBuf++ = HI_UINT16( shortAddr );
//  344     }
//  345 
//  346     /* Return device type */
//  347     *pBuf++ = ZSTACK_DEVICE_BUILD;
//  348 
//  349     /*Return device state */
//  350     *pBuf++ = (uint8)devState;
//  351 
//  352     if (ZG_DEVICE_RTR_TYPE)
//  353     {
//  354       *pBuf++ = assocCnt;
//  355 
//  356       if ( assocCnt )
//  357       {
//  358         uint8 x;
//  359         uint16 *puint16 = assocList;
//  360 
//  361         for ( x = 0; x < assocCnt; x++, puint16++ )
//  362         {
//  363           *pBuf++ = LO_UINT16( *puint16 );
//  364           *pBuf++ = HI_UINT16( *puint16 );
//  365         }
//  366       }
//  367     }
//  368     else
//  369     {
//  370       *pBuf++ = 0;
//  371     }
//  372 #endif
//  373 
//  374     MT_BuildAndSendZToolResponse( ((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
//  375                                  MT_UTIL_GET_DEVICE_INFO,
//  376                                  bufLen, buf );
//  377 
//  378     osal_mem_free( buf );
//  379   }
//  380 
//  381   if ( assocList )
//  382   {
//  383     osal_mem_free( assocList );
//  384   }
//  385 }
//  386 
//  387 /***************************************************************************************************
//  388  * @fn      MT_UtilGetNvInfo
//  389  *
//  390  * @brief   The Get NV Info serial message.
//  391  *
//  392  * @param   None.
//  393  *
//  394  * @return  void
//  395  ***************************************************************************************************/
//  396 void MT_UtilGetNvInfo(void)
//  397 {
//  398   uint8 len;
//  399   uint8 stat;
//  400   uint8 *buf;
//  401   uint8 *pBuf;
//  402   uint16 tmp16;
//  403   uint32 tmp32;
//  404 
//  405   /*
//  406     Get required length of buffer
//  407     Status + ExtAddr + ChanList + PanID  + SecLevel + PreCfgKey
//  408   */
//  409   len = 1 + Z_EXTADDR_LEN + 4 + 2 + 1 + SEC_KEY_LEN;
//  410 
//  411   buf = osal_mem_alloc( len );
//  412   if ( buf )
//  413   {
//  414     /* Assume NV not available */
//  415     osal_memset( buf, 0xFF, len );
//  416 
//  417     /* Skip over status */
//  418     pBuf = buf + 1;
//  419 
//  420     /* Start with 64-bit extended address */
//  421     stat = osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf );
//  422     if ( stat ) stat = 0x01;
//  423     pBuf += Z_EXTADDR_LEN;
//  424 
//  425     /* Scan channel list (bit mask) */
//  426     if (  osal_nv_read( ZCD_NV_CHANLIST, 0, sizeof( tmp32 ), &tmp32 ) )
//  427       stat |= 0x02;
//  428     else
//  429     {
//  430       pBuf[0] = BREAK_UINT32( tmp32, 3 );
//  431       pBuf[1] = BREAK_UINT32( tmp32, 2 );
//  432       pBuf[2] = BREAK_UINT32( tmp32, 1 );
//  433       pBuf[3] = BREAK_UINT32( tmp32, 0 );
//  434     }
//  435     pBuf += sizeof( tmp32 );
//  436 
//  437     /* ZigBee PanID */
//  438     if ( osal_nv_read( ZCD_NV_PANID, 0, sizeof( tmp16 ), &tmp16 ) )
//  439       stat |= 0x04;
//  440     else
//  441     {
//  442       pBuf[0] = LO_UINT16( tmp16 );
//  443       pBuf[1] = HI_UINT16( tmp16 );
//  444     }
//  445     pBuf += sizeof( tmp16 );
//  446 
//  447     /* Security level */
//  448     if ( osal_nv_read( ZCD_NV_SECURITY_LEVEL, 0, sizeof( uint8 ), pBuf++ ) )
//  449       stat |= 0x08;
//  450 
//  451     /* Pre-configured security key */
//  452     if ( osal_nv_read( ZCD_NV_PRECFGKEY, 0, SEC_KEY_LEN, pBuf ) )
//  453       stat |= 0x10;
//  454 
//  455     /* Status bit mask - bit=1 indicates failure */
//  456     *buf = stat;
//  457 
//  458     MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_GET_NV_INFO,
//  459                                   len, buf );
//  460 
//  461     osal_mem_free( buf );
//  462   }
//  463 }
//  464 
//  465 /***************************************************************************************************
//  466  * @fn      MT_UtilSetPanID
//  467  *
//  468  * @brief   Set PanID message
//  469  *
//  470  * @param   pBuf - pointer to the data
//  471  *
//  472  * @return  void
//  473  ***************************************************************************************************/
//  474 void MT_UtilSetPanID(uint8 *pBuf)
//  475 {
//  476   uint16 temp16;
//  477   uint8 retValue = ZFailure;
//  478   uint8 cmdId;
//  479 
//  480   /* parse header */
//  481   cmdId = pBuf[MT_RPC_POS_CMD1];
//  482   pBuf += MT_RPC_FRAME_HDR_SZ;
//  483 
//  484   temp16 = BUILD_UINT16(pBuf[0], pBuf[1]);
//  485   pBuf += sizeof(uint16);
//  486 
//  487   retValue = osal_nv_write(ZCD_NV_PANID, 0, osal_nv_item_len( ZCD_NV_PANID ), &temp16);
//  488 
//  489   /* Build and send back the response */
//  490   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
//  491 }
//  492 
//  493 /***************************************************************************************************
//  494  * @fn      MT_UtilGetPanID
//  495  *
//  496  * @brief   Get PanID message
//  497  *
//  498  * @param   pBuf - pointer to the data
//  499  *
//  500  * @return  void
//  501  ***************************************************************************************************/
//  502 void MT_UtilGetPanID(uint8 *pBuf)
//  503 {
//  504   uint16 temp16;
//  505   uint8 retValue = ZFailure;
//  506   uint8 cmdId;
//  507 
//  508   /* parse header */
//  509   cmdId = pBuf[MT_RPC_POS_CMD1];
//  510   pBuf += MT_RPC_FRAME_HDR_SZ;
//  511 
//  512   temp16 = BUILD_UINT16(pBuf[0], pBuf[1]);
//  513   pBuf += sizeof(uint16);
//  514 
//  515   retValue = osal_nv_write(ZCD_NV_PANID, 0, osal_nv_item_len( ZCD_NV_PANID ), &temp16);
//  516 
//  517   /* Build and send back the response */
//  518   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
//  519 }
//  520 
//  521 
//  522 /***************************************************************************************************
//  523  * @fn      MT_UtilSetChannels
//  524  *
//  525  * @brief   Set Channels
//  526  *
//  527  * @param   pBuf - pointer to the data
//  528  *
//  529  * @return  void
//  530  ***************************************************************************************************/
//  531 void MT_UtilSetChannels(uint8 *pBuf)
//  532 {
//  533   uint32 tmp32;
//  534   uint8 retValue = ZFailure;
//  535   uint8 cmdId;
//  536 
//  537   /* parse header */
//  538   cmdId = pBuf[MT_RPC_POS_CMD1];
//  539   pBuf += MT_RPC_FRAME_HDR_SZ;
//  540 
//  541   tmp32 = BUILD_UINT32(pBuf[0], pBuf[1], pBuf[2], pBuf[3]);
//  542 
//  543   retValue = osal_nv_write(ZCD_NV_CHANLIST, 0, osal_nv_item_len( ZCD_NV_CHANLIST ), &tmp32);
//  544 
//  545   /* Build and send back the response */
//  546   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
//  547 }
//  548 
//  549 /***************************************************************************************************
//  550  * @fn      MT_UtilSetSecLevel
//  551  *
//  552  * @brief   Set Sec Level
//  553  *
//  554  * @param   byte *msg - pointer to the data
//  555  *
//  556  * @return  void
//  557  ***************************************************************************************************/
//  558 void MT_UtilSetSecLevel(uint8 *pBuf)
//  559 {
//  560   uint8 retValue = ZFailure;
//  561   uint8 cmdId;
//  562 
//  563   /* parse header */
//  564   cmdId = pBuf[MT_RPC_POS_CMD1];
//  565   pBuf += MT_RPC_FRAME_HDR_SZ;
//  566 
//  567   retValue = osal_nv_write( ZCD_NV_SECURITY_LEVEL, 0, osal_nv_item_len( ZCD_NV_SECURITY_LEVEL ), pBuf);
//  568 
//  569   /* Build and send back the response */
//  570   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  571 
//  572 }
//  573 
//  574 /***************************************************************************************************
//  575  * @fn      MT_UtilSetPreCfgKey
//  576  *
//  577  * @brief   Set Pre Cfg Key
//  578  *
//  579  * @param   pBuf - pointer to the data
//  580  *
//  581  * @return  void
//  582  ***************************************************************************************************/
//  583 void MT_UtilSetPreCfgKey(uint8 *pBuf)
//  584 {
//  585   uint8 retValue = ZFailure;
//  586   uint8 cmdId;
//  587 
//  588   /* parse header */
//  589   cmdId = pBuf[MT_RPC_POS_CMD1];
//  590   pBuf += MT_RPC_FRAME_HDR_SZ;
//  591 
//  592   retValue = osal_nv_write( ZCD_NV_PRECFGKEY, 0, osal_nv_item_len( ZCD_NV_PRECFGKEY ), pBuf);
//  593 
//  594   /* Build and send back the response */
//  595   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  596 
//  597 }
//  598 
//  599 /***************************************************************************************************
//  600  * @fn      MT_UtilCallbackSub
//  601  *
//  602  * @brief   The Callback subscribe.
//  603  *
//  604  * @param   pBuf - pointer to the data
//  605  *
//  606  * @return  void
//  607  ***************************************************************************************************/
//  608 void MT_UtilCallbackSub(uint8 *pBuf)
//  609 {
//  610   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
//  611   uint8 retValue = ZFailure;
//  612 
//  613 #if defined(MT_MAC_CB_FUNC) || defined(MT_NWK_CB_FUNC) || defined(MT_ZDO_CB_FUNC) || defined(MT_AF_CB_FUNC) || defined(MT_SAPI_CB_FUNC)
//  614   uint8 subSystem;
//  615   uint16 subscribed_command;
//  616 
//  617   // Move past header
//  618   retValue = ZSuccess;
//  619   pBuf += MT_RPC_FRAME_HDR_SZ;
//  620 
//  621   /* Command */
//  622   subscribed_command = BUILD_UINT16(pBuf[0], pBuf[1]);
//  623   pBuf += 2;
//  624 
//  625   /* Subsystem - 5 bits on the MSB of the command */
//  626   subSystem = HI_UINT16(subscribed_command) & 0x1F ;
//  627 
//  628   /* What is the action - SUBSCRIBE or !SUBSCRIBE */
//  629   if (*pBuf)
//  630   {
//  631     /* Turn ON */
//  632   #if defined( MT_MAC_CB_FUNC )
//  633     if ((subSystem == MT_RPC_SYS_MAC) || (subscribed_command == 0xFFFF))
//  634       _macCallbackSub = 0xFFFF;
//  635   #endif
//  636 
//  637   #if defined( MT_NWK_CB_FUNC )
//  638     if ((subSystem == MT_RPC_SYS_NWK) || (subscribed_command == 0xFFFF))
//  639       _nwkCallbackSub = 0xFFFF;
//  640   #endif
//  641 
//  642   #if defined( MT_ZDO_CB_FUNC )
//  643     if ((subSystem == MT_RPC_SYS_ZDO) || (subscribed_command == 0xFFFF))
//  644       _zdoCallbackSub = 0xFFFFFFFF;
//  645   #endif
//  646 
//  647   #if defined( MT_AF_CB_FUNC )
//  648     if ((subSystem == MT_RPC_SYS_AF) || (subscribed_command == 0xFFFF))
//  649       _afCallbackSub = 0xFFFF;
//  650   #endif
//  651 
//  652   #if defined( MT_SAPI_CB_FUNC )
//  653     if ((subSystem == MT_RPC_SYS_SAPI) || (subscribed_command == 0xFFFF))
//  654       _sapiCallbackSub = 0xFFFF;
//  655   #endif
//  656   }
//  657   else
//  658   {
//  659     /* Turn OFF */
//  660   #if defined( MT_MAC_CB_FUNC )
//  661     if ((subSystem == MT_RPC_SYS_MAC) || (subscribed_command == 0xFFFF))
//  662       _macCallbackSub = 0x0000;
//  663   #endif
//  664 
//  665   #if defined( MT_NWK_CB_FUNC )
//  666     if ((subSystem == MT_RPC_SYS_NWK) || (subscribed_command == 0xFFFF))
//  667       _nwkCallbackSub = 0x0000;
//  668   #endif
//  669 
//  670   #if defined( MT_ZDO_CB_FUNC )
//  671     if ((subSystem == MT_RPC_SYS_ZDO) || (subscribed_command == 0xFFFF))
//  672       _zdoCallbackSub = 0x00000000;
//  673   #endif
//  674 
//  675   #if defined( MT_AF_CB_FUNC )
//  676     if ((subSystem == MT_RPC_SYS_AF) || (subscribed_command == 0xFFFF))
//  677       _afCallbackSub = 0x0000;
//  678   #endif
//  679 
//  680   #if defined( MT_SAPI_CB_FUNC )
//  681     if ((subSystem == MT_RPC_SYS_SAPI) || (subscribed_command == 0xFFFF))
//  682         _sapiCallbackSub = 0x0000;
//  683   #endif
//  684   }
//  685 #endif  // MT_MAC_CB_FUNC || MT_NWK_CB_FUNC || MT_ZDO_CB_FUNC || MT_AF_CB_FUNC || MT_SAPI_CB_FUNC || MT_SAPI_CB_FUNC
//  686 
//  687   /* Build and send back the response */
//  688   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  689 }
//  690 
//  691 #if (defined HAL_KEY) && (HAL_KEY == TRUE)
//  692 /***************************************************************************************************
//  693  * @fn      MT_UtilKeyEvent
//  694  *
//  695  * @brief   Process Key Event
//  696  *
//  697  * @param   pBuf - pointer to the data
//  698  *
//  699  * @return  void
//  700  ***************************************************************************************************/
//  701 void MT_UtilKeyEvent(uint8 *pBuf)
//  702 {
//  703   uint8 x = 0;
//  704   uint8 retValue = ZFailure;
//  705   uint8 cmdId;
//  706 
//  707   /* parse header */
//  708   cmdId = pBuf[MT_RPC_POS_CMD1];
//  709   pBuf += MT_RPC_FRAME_HDR_SZ;
//  710 
//  711   /* Translate between SPI values to device values */
//  712   if ( *pBuf & 0x01 )
//  713     x |= HAL_KEY_SW_1;
//  714   if ( *pBuf & 0x02 )
//  715     x |= HAL_KEY_SW_2;
//  716   if ( *pBuf & 0x04 )
//  717     x |= HAL_KEY_SW_3;
//  718   if ( *pBuf & 0x08 )
//  719   x |= HAL_KEY_SW_4;
//  720 #if defined ( HAL_KEY_SW_5 )
//  721   if ( *pBuf & 0x10 )
//  722     x |= HAL_KEY_SW_5;
//  723 #endif
//  724 #if defined ( HAL_KEY_SW_6 )
//  725   if ( *pBuf & 0x20 )
//  726     x |= HAL_KEY_SW_6;
//  727 #endif
//  728 #if defined ( HAL_KEY_SW_7 )
//  729   if ( *pBuf & 0x40 )
//  730     x |= HAL_KEY_SW_7;
//  731 #endif
//  732 #if defined ( HAL_KEY_SW_8 )
//  733   if ( *pBuf & 0x80 )
//  734     x |= HAL_KEY_SW_8;
//  735 #endif
//  736   pBuf++;
//  737 
//  738   retValue = OnBoard_SendKeys(x, *pBuf);
//  739 
//  740   /* Build and send back the response */
//  741   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  742 }
//  743 #endif
//  744 
//  745 /***************************************************************************************************
//  746  * @fn      MT_UtilTimeAlive
//  747  *
//  748  * @brief   Process Time Alive
//  749  *
//  750  * @param   None.
//  751  *
//  752  * @return  None
//  753  ***************************************************************************************************/
//  754 void MT_UtilTimeAlive(void)
//  755 {
//  756   uint8 timeAlive[4];
//  757   uint32 tmp32;
//  758 
//  759   /* Time since last reset (seconds) */
//  760   tmp32 = osal_GetSystemClock() / 1000;
//  761 
//  762   /* Convert to high byte first into temp buffer */
//  763   timeAlive[0] = BREAK_UINT32(tmp32, 0);
//  764   timeAlive[1] = BREAK_UINT32(tmp32, 1);
//  765   timeAlive[2] = BREAK_UINT32(tmp32, 2);
//  766   timeAlive[3] = BREAK_UINT32(tmp32, 3);
//  767 
//  768   /* Build and send back the response */
//  769   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
//  770                                        MT_UTIL_TIME_ALIVE, sizeof(timeAlive), timeAlive);
//  771 }
//  772 
//  773 #if (defined HAL_LED) && (HAL_LED == TRUE)
//  774 /***************************************************************************************************
//  775  * @fn      MT_UtilLedControl
//  776  *
//  777  * @brief   Process the LED Control Message
//  778  *
//  779  * @param   pBuf - pointer to the received data
//  780  *
//  781  * @return  None
//  782  ***************************************************************************************************/
//  783 void MT_UtilLedControl(uint8 *pBuf)
//  784 {
//  785   uint8 iLed, Led, iMode, Mode, cmdId;
//  786   uint8 retValue = ZFailure;
//  787 
//  788   /* parse header */
//  789   cmdId = pBuf[MT_RPC_POS_CMD1];
//  790   pBuf += MT_RPC_FRAME_HDR_SZ;
//  791 
//  792   /* LED and Mode */
//  793   iLed = *pBuf++;
//  794   iMode = *pBuf;
//  795 
//  796   if ( iLed == 1 )
//  797     Led = HAL_LED_1;
//  798   else if ( iLed == 2 )
//  799     Led = HAL_LED_2;
//  800   else if ( iLed == 3 )
//  801     Led = HAL_LED_3;
//  802   else if ( iLed == 4 )
//  803     Led = HAL_LED_4;
//  804   else if ( iLed == 0xFF )
//  805     Led = HAL_LED_ALL;
//  806   else
//  807     Led = 0;
//  808 
//  809   if ( iMode == 0 )
//  810     Mode = HAL_LED_MODE_OFF;
//  811   else if ( iMode == 1 )
//  812     Mode = HAL_LED_MODE_ON;
//  813   else if ( iMode == 2 )
//  814     Mode = HAL_LED_MODE_BLINK;
//  815   else if ( iMode == 3 )
//  816     Mode = HAL_LED_MODE_FLASH;
//  817   else if ( iMode == 4 )
//  818     Mode = HAL_LED_MODE_TOGGLE;
//  819   else
//  820     Led = 0;
//  821 
//  822   if ( Led != 0 )
//  823   {
//  824     HalLedSet (Led, Mode);
//  825     retValue = ZSuccess;
//  826   }
//  827 
//  828   /* Build and send back the response */
//  829   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  830 }
//  831 #endif /* HAL_LED */
//  832 
//  833 
//  834 /***************************************************************************************************
//  835  * @fn          MT_UtilSrcMatchEnable
//  836  *
//  837  * @brief      Enabled AUTOPEND and source address matching.
//  838  *
//  839  * @param      pBuf - Buffer contains the data
//  840  *
//  841  * @return     void
//  842  ***************************************************************************************************/
//  843 void MT_UtilSrcMatchEnable (uint8 *pBuf)
//  844 {
//  845   uint8 retValue, cmdId;
//  846 
//  847   /* Parse header */
//  848   cmdId = pBuf[MT_RPC_POS_CMD1];
//  849   pBuf += MT_RPC_FRAME_HDR_SZ;
//  850 
//  851 #ifdef AUTO_PEND
//  852   /* Call the routine */
//  853   retValue = ZMacSrcMatchEnable (pBuf[0], pBuf[1]);
//  854 #else
//  855   retValue = ZMacUnsupported;
//  856 #endif
//  857 
//  858   /* Build and send back the response */
//  859   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  860 
//  861 }
//  862 
//  863 /***************************************************************************************************
//  864  * @fn          MT_UtilSrcMatchAddEntry
//  865  *
//  866  * @brief       Add a short or extended address to source address table.
//  867  *
//  868  * @param       pBuf - Buffer contains the data
//  869  *
//  870  * @return      void
//  871  ***************************************************************************************************/
//  872 void MT_UtilSrcMatchAddEntry (uint8 *pBuf)
//  873 {
//  874   uint8 retValue, cmdId;
//  875 
//  876   /* Parse header */
//  877   cmdId = pBuf[MT_RPC_POS_CMD1];
//  878   pBuf += MT_RPC_FRAME_HDR_SZ;
//  879 
//  880 #ifdef AUTO_PEND
//  881   uint16 panID;
//  882   zAddrType_t devAddr;
//  883 
//  884   /* Address mode */
//  885   devAddr.addrMode = *pBuf++;
//  886 
//  887   /* Address based on the address mode */
//  888   MT_UtilSpi2Addr( &devAddr, pBuf);
//  889   pBuf += Z_EXTADDR_LEN;
//  890 
//  891   /* PanID */
//  892   panID = BUILD_UINT16( pBuf[0] , pBuf[1] );
//  893 
//  894   /* Call the routine */
//  895   retValue =  ZMacSrcMatchAddEntry (&devAddr, panID);
//  896 #else
//  897   retValue = ZMacUnsupported;
//  898 #endif
//  899 
//  900   /* Build and send back the response */
//  901   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  902 }
//  903 
//  904 /***************************************************************************************************
//  905  * @fn          MT_UtilSrcMatchDeleteEntry
//  906  *
//  907  * @brief      Delete a short or extended address from source address table.
//  908  *
//  909  * @param      pBuf - Buffer contains the data
//  910  *
//  911  * @return     void
//  912  ***************************************************************************************************/
//  913 void MT_UtilSrcMatchDeleteEntry (uint8 *pBuf)
//  914 {
//  915   uint8 retValue, cmdId;
//  916 
//  917   /* Parse header */
//  918   cmdId = pBuf[MT_RPC_POS_CMD1];
//  919   pBuf += MT_RPC_FRAME_HDR_SZ;
//  920 
//  921 #ifdef AUTO_PEND
//  922   uint16 panID;
//  923   zAddrType_t devAddr;
//  924 
//  925   /* Address mode */
//  926   devAddr.addrMode = *pBuf++;
//  927 
//  928   /* Address based on the address mode */
//  929   MT_UtilSpi2Addr( &devAddr, pBuf);
//  930   pBuf += Z_EXTADDR_LEN;
//  931 
//  932   /* PanID */
//  933   panID = BUILD_UINT16( pBuf[0] , pBuf[1] );
//  934 
//  935   /* Call the routine */
//  936   retValue =  ZMacSrcMatchDeleteEntry (&devAddr, panID);
//  937 #else
//  938   retValue = ZMacUnsupported;
//  939 #endif
//  940 
//  941   /* Build and send back the response */
//  942   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  943 }
//  944 
//  945 /***************************************************************************************************
//  946  * @fn          MT_UtilSrcMatchCheckSrcAddr
//  947  *
//  948  * @brief      Check if a short or extended address is in the source address table.
//  949  *
//  950  * @param      pBuf - Buffer contains the data
//  951  *
//  952  * @return     void
//  953  ***************************************************************************************************/
//  954 void MT_UtilSrcMatchCheckSrcAddr (uint8 *pBuf)
//  955 {
//  956   uint8 cmdId;
//  957   uint8 retArray[2];
//  958 
//  959   /* Parse header */
//  960   cmdId = pBuf[MT_RPC_POS_CMD1];
//  961   pBuf += MT_RPC_FRAME_HDR_SZ;
//  962 
//  963 #if 0  /* Unsupported  */
//  964   uint16 panID;
//  965   zAddrType_t devAddr;
//  966 
//  967   /* Address mode */
//  968   devAddr.addrMode = *pBuf++;
//  969 
//  970   /* Address based on the address mode */
//  971   MT_UtilSpi2Addr( &devAddr, pBuf);
//  972   pBuf += Z_EXTADDR_LEN;
//  973 
//  974   /* PanID */
//  975   panID = BUILD_UINT16( pBuf[0] , pBuf[1] );
//  976 
//  977   /* Call the routine */
//  978   retArray[1] =  ZMacSrcMatchCheckSrcAddr (&devAddr, panID);
//  979 
//  980     /* Return failure if the index is invalid */
//  981   if (retArray[1] == ZMacSrcMatchInvalidIndex )
//  982   {
//  983     retArray[0] = ZFailure;
//  984   }
//  985   else
//  986   {
//  987     retArray[0] = ZSuccess;
//  988   }
//  989 #else
//  990   retArray[0] = ZMacUnsupported;
//  991   retArray[1] = ZMacSrcMatchInvalidIndex;
//  992 #endif
//  993 
//  994   /* Build and send back the response */
//  995   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, retArray );
//  996 }
//  997 
//  998 /***************************************************************************************************
//  999  * @fn          MT_UtilSrcMatchAckAllPending
// 1000  *
// 1001  * @brief       Enabled/disable acknowledging all packets with pending bit set
// 1002  *              It is normally enabled when adding new entries to
// 1003  *              the source address table fails due to the table is full, or
// 1004  *              disabled when more entries are deleted and the table has
// 1005  *              empty slots.
// 1006  *
// 1007  * @param       pBuf - Buffer contains the data
// 1008  *
// 1009  * @return      void
// 1010  ***************************************************************************************************/
// 1011 void MT_UtilSrcMatchAckAllPending (uint8 *pBuf)
// 1012 {
// 1013   uint8 retValue, cmdId;
// 1014 
// 1015   /* Parse header */
// 1016   cmdId = pBuf[MT_RPC_POS_CMD1];
// 1017   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1018 
// 1019 #ifdef AUTO_PEND
// 1020   /* Call the routine */
// 1021   retValue = ZMacSrcMatchAckAllPending(*pBuf);
// 1022 #else
// 1023   retValue = ZMacUnsupported;
// 1024 #endif
// 1025 
// 1026   /* Build and send back the response */
// 1027   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
// 1028 }
// 1029 
// 1030 /***************************************************************************************************
// 1031  * @fn          MT_UtilSrcMatchCheckAllPending
// 1032  *
// 1033  * @brief       Check if acknowledging all packets with pending bit set
// 1034  *              is enabled.
// 1035  *
// 1036  * @param       pBuf - Buffer contains the data
// 1037  *
// 1038  * @return      void
// 1039  ***************************************************************************************************/
// 1040 void MT_UtilSrcMatchCheckAllPending (uint8 *pBuf)
// 1041 {
// 1042   uint8 retArray[2], cmdId;
// 1043 
// 1044   /* Parse header */
// 1045   cmdId = pBuf[MT_RPC_POS_CMD1];
// 1046   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1047 
// 1048 #ifdef AUTO_PEND
// 1049   /* Call the routine */
// 1050   retArray[0] = ZMacSuccess;
// 1051   retArray[1] = ZMacSrcMatchCheckAllPending();
// 1052 #else
// 1053   retArray[0] = ZMacUnsupported;
// 1054   retArray[1] = FALSE;
// 1055 #endif
// 1056 
// 1057   /* Build and send back the response */
// 1058   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, retArray );
// 1059 }
// 1060 
// 1061 /***************************************************************************************************
// 1062  * SUPPORT
// 1063  ***************************************************************************************************/
// 1064 
// 1065 #ifdef AUTO_PEND
// 1066 /***************************************************************************************************
// 1067  * @fn      MT_UtilRevExtCpy
// 1068  *
// 1069  * @brief
// 1070  *
// 1071  *   Reverse-copy an extended address.
// 1072  *
// 1073  * @param   pDst - Pointer to data destination
// 1074  * @param   pSrc - Pointer to data source
// 1075  *
// 1076  * @return  void
// 1077  ***************************************************************************************************/
// 1078 static void MT_UtilRevExtCpy( uint8 *pDst, uint8 *pSrc )
// 1079 {
// 1080   int8 i;
// 1081 
// 1082   for ( i = Z_EXTADDR_LEN - 1; i >= 0; i-- )
// 1083   {
// 1084     *pDst++ = pSrc[i];
// 1085   }
// 1086 }
// 1087 
// 1088 /***************************************************************************************************
// 1089  * @fn      MT_UtilSpi2Addr
// 1090  *
// 1091  * @brief   Copy an address from an SPI message to an address struct.  The
// 1092  *          addrMode in pAddr must already be set.
// 1093  *
// 1094  * @param   pDst - Pointer to address struct
// 1095  * @param   pSrc - Pointer SPI message byte array
// 1096  *
// 1097  * @return  void
// 1098  ***************************************************************************************************/
// 1099 static void MT_UtilSpi2Addr( zAddrType_t *pDst, uint8 *pSrc )
// 1100 {
// 1101   if ( pDst->addrMode == Addr16Bit )
// 1102   {
// 1103     pDst->addr.shortAddr = BUILD_UINT16( pSrc[0] , pSrc[1] );
// 1104   }
// 1105   else if ( pDst->addrMode == Addr64Bit )
// 1106   {
// 1107     MT_UtilRevExtCpy( pDst->addr.extAddr, pSrc );
// 1108   }
// 1109 }
// 1110 #endif // AUTO_PEND
// 1111 
// 1112 #if !defined NONWK
// 1113 /**************************************************************************************************
// 1114  * @fn      MT_UtilDataReq
// 1115  *
// 1116  * @brief   Process the MAC Data Request command.
// 1117  *
// 1118  * @param   pBuf - pointer to the received data
// 1119  *
// 1120  * @return  None
// 1121 **************************************************************************************************/
// 1122 void MT_UtilDataReq(uint8 *pBuf)
// 1123 {
// 1124   uint8 rtrn = NwkPollReq(pBuf[MT_RPC_POS_DAT0]);
// 1125   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_DATA_REQ,
// 1126                                                                                1, &rtrn);
// 1127 }
// 1128 
// 1129 /***************************************************************************************************
// 1130  * @fn      MT_UtilAddrMgrEntryLookupExt
// 1131  *
// 1132  * @brief   Proxy the AddrMgrEntryLookupExt() function.
// 1133  *
// 1134  * @param   pBuf - pointer to the received buffer
// 1135  *
// 1136  * @return  void
// 1137  ***************************************************************************************************/
// 1138 static void MT_UtilAddrMgrEntryLookupExt(uint8 *pBuf)
// 1139 {
// 1140   uint8 nwkAddr[2];
// 1141   AddrMgrEntry_t entry;
// 1142   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1143   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1144 
// 1145   osal_memcpy(entry.extAddr, pBuf, Z_EXTADDR_LEN);
// 1146   (void)AddrMgrEntryLookupExt(&entry);
// 1147   
// 1148   nwkAddr[0] = LO_UINT16(entry.nwkAddr);
// 1149   nwkAddr[1] = HI_UINT16(entry.nwkAddr);
// 1150   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
// 1151                                        cmdId, sizeof(uint16), nwkAddr);
// 1152 }
// 1153 
// 1154 /***************************************************************************************************
// 1155  * @fn      MT_UtilAddrMgrEntryLookupNwk
// 1156  *
// 1157  * @brief   Proxy the AddrMgrEntryLookupNwk() function.
// 1158  *
// 1159  * @param   pBuf - pointer to the received buffer
// 1160  *
// 1161  * @return  void
// 1162  ***************************************************************************************************/
// 1163 static void MT_UtilAddrMgrEntryLookupNwk(uint8 *pBuf)
// 1164 {
// 1165   AddrMgrEntry_t entry;
// 1166   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1167   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1168 
// 1169   entry.nwkAddr = BUILD_UINT16(pBuf[0], pBuf[1]);
// 1170   (void)AddrMgrEntryLookupNwk(&entry);
// 1171 
// 1172   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
// 1173                                        cmdId, Z_EXTADDR_LEN, entry.extAddr);
// 1174 }
// 1175 
// 1176 #if defined MT_SYS_KEY_MANAGEMENT
// 1177 /***************************************************************************************************
// 1178  * @fn      MT_UtilAPSME_LinkKeyDataGet
// 1179  *
// 1180  * @brief   Retrieves APS Link Key data from NV.
// 1181  *
// 1182  * @param   pBuf - pointer to the received buffer
// 1183  *
// 1184  * @return  void
// 1185  ***************************************************************************************************/
// 1186 static void MT_UtilAPSME_LinkKeyDataGet(uint8 *pBuf)
// 1187 {
// 1188   uint8 rsp[MT_APSME_LINKKEY_GET_RSP_LEN];
// 1189   APSME_LinkKeyData_t *pData = NULL;
// 1190   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1191   uint16 apsLinkKeyNvId;
// 1192   uint32 *apsRxFrmCntr;
// 1193   uint32 *apsTxFrmCntr;
// 1194 
// 1195   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1196 
// 1197   *rsp = APSME_LinkKeyNVIdGet(pBuf, &apsLinkKeyNvId);
// 1198 
// 1199   if (SUCCESS == *rsp)
// 1200   {
// 1201     pData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
// 1202 
// 1203     if (pData != NULL)
// 1204     {
// 1205       // retrieve key from NV
// 1206       if ( osal_nv_read( apsLinkKeyNvId, 0,
// 1207                         sizeof(APSME_LinkKeyData_t), pData) == SUCCESS)
// 1208 
// 1209       {
// 1210         apsRxFrmCntr = &ApsLinkKeyFrmCntr[apsLinkKeyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr;
// 1211         apsTxFrmCntr = &ApsLinkKeyFrmCntr[apsLinkKeyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr;
// 1212 
// 1213         uint8 *ptr = rsp+1;
// 1214         (void)osal_memcpy(ptr, pData->key, SEC_KEY_LEN);
// 1215         ptr += SEC_KEY_LEN;
// 1216         *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 0);
// 1217         *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 1);
// 1218         *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 2);
// 1219         *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 3);
// 1220         *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 0);
// 1221         *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 1);
// 1222         *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 2);
// 1223         *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 3);
// 1224       }
// 1225 
// 1226       // clear copy of key in RAM
// 1227       osal_memset( pData, 0x00, sizeof(APSME_LinkKeyData_t) );
// 1228 
// 1229       osal_mem_free(pData);
// 1230     }
// 1231   }
// 1232   else
// 1233   {
// 1234     // set data key and counters 0xFF
// 1235     osal_memset(&rsp[1], 0xFF, SEC_KEY_LEN + (MT_UTIL_FRM_CTR_LEN * 2));
// 1236   }
// 1237 
// 1238   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1239                                        MT_APSME_LINKKEY_GET_RSP_LEN, rsp);
// 1240 
// 1241   // clear key data
// 1242   osal_memset(rsp, 0x00, MT_APSME_LINKKEY_GET_RSP_LEN);
// 1243 
// 1244 }
// 1245 
// 1246 /***************************************************************************************************
// 1247  * @fn      MT_UtilAPSME_LinkKeyNvIdGet
// 1248  *
// 1249  * @brief   Retrieves APS Link Key NV ID from the entry table.
// 1250  *
// 1251  * @param   pBuf - pointer to the received buffer
// 1252  *
// 1253  * @return  void
// 1254  ***************************************************************************************************/
// 1255 static void MT_UtilAPSME_LinkKeyNvIdGet(uint8 *pBuf)
// 1256 {
// 1257   uint8 rsp[MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN];
// 1258   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1259   uint16 apsLinkKeyNvId;
// 1260 
// 1261   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1262 
// 1263   *rsp = APSME_LinkKeyNVIdGet(pBuf, &apsLinkKeyNvId);
// 1264 
// 1265   if (SUCCESS == *rsp)
// 1266   {
// 1267     rsp[1] = LO_UINT16(apsLinkKeyNvId);
// 1268     rsp[2] = HI_UINT16(apsLinkKeyNvId);
// 1269   }
// 1270   else
// 1271   {
// 1272     // send failure response with invalid NV ID
// 1273     osal_memset(&rsp[1], 0xFF, 2);
// 1274   }
// 1275 
// 1276   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1277                                        MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN, rsp);
// 1278 }
// 1279 #endif // MT_SYS_KEY_MANAGEMENT
// 1280 
// 1281 /***************************************************************************************************
// 1282  * @fn      MT_UtilAPSME_RequestKeyCmd
// 1283  *
// 1284  * @brief   Send RequestKey command message to TC for a specific partner Address.
// 1285  *
// 1286  * @param   pBuf  - pointer to the received buffer
// 1287  *
// 1288  * @return  void
// 1289  ***************************************************************************************************/
// 1290 void MT_UtilAPSME_RequestKeyCmd(uint8 *pBuf)
// 1291 {
// 1292   uint8 cmdId;
// 1293   uint8 partnerAddr[Z_EXTADDR_LEN];
// 1294   uint8 retValue;
// 1295 
// 1296   // parse header
// 1297   cmdId = pBuf[MT_RPC_POS_CMD1];
// 1298   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1299 
// 1300   /* PartnerAddress */
// 1301   osal_memcpy(partnerAddr, pBuf, Z_EXTADDR_LEN);
// 1302 
// 1303   retValue = (uint8)ZDSecMgrRequestAppKey(partnerAddr);
// 1304 
// 1305   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
// 1306 }
// 1307 
// 1308 /***************************************************************************************************
// 1309  * @fn      MT_UtilAssocCount
// 1310  *
// 1311  * @brief   Proxy the AssocCount() function.
// 1312  *
// 1313  * @param   pBuf - pointer to the received buffer
// 1314  *
// 1315  * @return  void
// 1316  ***************************************************************************************************/
// 1317 static void MT_UtilAssocCount(uint8 *pBuf)
// 1318 {
// 1319   uint16 cnt;
// 1320   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1321   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1322 
// 1323   cnt = AssocCount(pBuf[0], pBuf[1]);
// 1324   pBuf[0] = LO_UINT16(cnt);
// 1325   pBuf[1] = HI_UINT16(cnt);
// 1326 
// 1327   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, pBuf);
// 1328 }
// 1329 
// 1330 /***************************************************************************************************
// 1331  * @fn      MT_UtilAssocFindDevice
// 1332  *
// 1333  * @brief   Get an associated device by index.
// 1334  *
// 1335  * @param   pBuf - pointer to the received buffer
// 1336  *
// 1337  * @return  void
// 1338  ***************************************************************************************************/
// 1339 static void MT_UtilAssocFindDevice(uint8 *pBuf)
// 1340 {
// 1341   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1342   uint8 buf[sizeof(associated_devices_t)];
// 1343 
// 1344   packDev_t(buf, AssocFindDevice(pBuf[MT_RPC_FRAME_HDR_SZ]));
// 1345   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1346                                        sizeof(associated_devices_t), buf);
// 1347 }
// 1348 
// 1349 /***************************************************************************************************
// 1350  * @fn      MT_UtilAssocGetWithAddress
// 1351  *
// 1352  * @brief   Get an associated device by address.
// 1353  *
// 1354  * @param   pBuf - pointer to the received buffer
// 1355  *
// 1356  * @return  void
// 1357  ***************************************************************************************************/
// 1358 static void MT_UtilAssocGetWithAddress(uint8 *pBuf)
// 1359 {
// 1360   extern associated_devices_t *AssocGetWithAddress(uint8 *extAddr, uint16 shortAddr);
// 1361   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1362   uint8 buf[sizeof(associated_devices_t)];
// 1363 
// 1364   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1365   packDev_t(buf, AssocGetWithAddress(((AddrMgrExtAddrValid(pBuf)) ? pBuf : NULL),
// 1366                                   BUILD_UINT16(pBuf[Z_EXTADDR_LEN], pBuf[Z_EXTADDR_LEN+1])));
// 1367 
// 1368   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1369                                        sizeof(associated_devices_t), buf);
// 1370 }
// 1371 
// 1372 /***************************************************************************************************
// 1373  * @fn      packDev_t
// 1374  *
// 1375  * @brief   Pack an associated_devices_t structure into a byte buffer (pack INVALID_NODE_ADDR if
// 1376  *          the pDev parameter is NULL).
// 1377  *
// 1378  * @param   pBuf - pointer to the buffer into which to pack the structure.
// 1379  * @param   pDev - pointer to the structure.
// 1380  *
// 1381  * @return  void
// 1382  ***************************************************************************************************/
// 1383 static void packDev_t(uint8 *pBuf, associated_devices_t *pDev)
// 1384 {
// 1385   if (NULL == pDev)
// 1386   {
// 1387     uint16 rtrn = INVALID_NODE_ADDR;
// 1388     *pBuf++ = LO_UINT16(rtrn);
// 1389     *pBuf++ = HI_UINT16(rtrn);
// 1390   }
// 1391   else
// 1392   {
// 1393     *pBuf++ = LO_UINT16(pDev->shortAddr);
// 1394     *pBuf++ = HI_UINT16(pDev->shortAddr);
// 1395     *pBuf++ = LO_UINT16(pDev->addrIdx);
// 1396     *pBuf++ = HI_UINT16(pDev->addrIdx);
// 1397     *pBuf++ = pDev->nodeRelation;
// 1398     *pBuf++ = pDev->devStatus;
// 1399     *pBuf++ = pDev->assocCnt;
// 1400     *pBuf++ = pDev->age;
// 1401     *pBuf++ = pDev->linkInfo.txCounter;
// 1402     *pBuf++ = pDev->linkInfo.txCost;
// 1403     *pBuf++ = pDev->linkInfo.rxLqi;
// 1404     *pBuf++ = pDev->linkInfo.inKeySeqNum;
// 1405     *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 0);
// 1406     *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 1);
// 1407     *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 2);
// 1408     *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 3);
// 1409     *pBuf++ = LO_UINT16(pDev->linkInfo.txFailure);
// 1410     *pBuf++ = HI_UINT16(pDev->linkInfo.txFailure);
// 1411   }
// 1412 }
// 1413 
// 1414 #if defined ZCL_KEY_ESTABLISH
// 1415 /***************************************************************************************************
// 1416  * @fn      MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment
// 1417  *
// 1418  * @brief   Proxy the zclGeneral_KeyEstablish_InitiateKeyEstablishment() function.
// 1419  *
// 1420  * @param   pBuf - pointer to the received buffer
// 1421  *
// 1422  * @return  void
// 1423  ***************************************************************************************************/
// 1424 static void MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(uint8 *pBuf)
// 1425 {
// 1426   afAddrType_t partnerAddr;
// 1427   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1428   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1429 
// 1430   partnerAddr.panId = 0;  // Not an inter-pan message.
// 1431   partnerAddr.endPoint = pBuf[2];
// 1432   partnerAddr.addrMode = (afAddrMode_t)pBuf[3];
// 1433   if (afAddr64Bit == partnerAddr.addrMode)
// 1434   {
// 1435     (void)osal_memcpy(partnerAddr.addr.extAddr, pBuf+4, Z_EXTADDR_LEN);
// 1436   }
// 1437   else
// 1438   {
// 1439     partnerAddr.addr.shortAddr = BUILD_UINT16(pBuf[4], pBuf[5]);
// 1440   }
// 1441 
// 1442   zcl_key_establish_task_id = pBuf[0];
// 1443   *pBuf = zclGeneral_KeyEstablish_InitiateKeyEstablishment(MT_TaskID, &partnerAddr, pBuf[1]);
// 1444   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, pBuf);
// 1445 }
// 1446 
// 1447 /***************************************************************************************************
// 1448  * @fn      MT_UtilzclGeneral_KeyEstablishment_ECDSASign
// 1449  *
// 1450  * @brief   Proxy the zclGeneral_KeyEstablishment_ECDSASign() function.
// 1451  *
// 1452  * @param   pBuf - pointer to the received buffer
// 1453  *
// 1454  * @return  void
// 1455  ***************************************************************************************************/
// 1456 static void MT_UtilzclGeneral_KeyEstablishment_ECDSASign(uint8 *pBuf)
// 1457 {
// 1458 #if defined TC_LINKKEY_JOIN
// 1459   uint8 *output = osal_mem_alloc(SE_PROFILE_SIGNATURE_LENGTH+1);
// 1460   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1461   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1462 
// 1463   if (NULL == output)
// 1464   {
// 1465     *pBuf = FAILURE;
// 1466     MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, pBuf);
// 1467   }
// 1468   else
// 1469   {
// 1470     *output = zclGeneral_KeyEstablishment_ECDSASign(pBuf+1, *pBuf, output+1);
// 1471     MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1472                                          SE_PROFILE_SIGNATURE_LENGTH+1, output);
// 1473     osal_mem_free(output);
// 1474   }
// 1475 #endif
// 1476 }
// 1477 
// 1478 /***************************************************************************************************
// 1479  * @fn      MT_UtilKeyEstablishInd
// 1480  *
// 1481  * @brief   Proxy the ZCL_KEY_ESTABLISH_IND command.
// 1482  *
// 1483  * @param   pInd - Pointer to a keyEstablishmentInd_t structure.
// 1484  *
// 1485  * @return  None
// 1486  ***************************************************************************************************/
// 1487 void MT_UtilKeyEstablishInd(keyEstablishmentInd_t *pInd)
// 1488 {
// 1489   uint8 msg[6];
// 1490 
// 1491   msg[0] = zcl_key_establish_task_id;
// 1492   msg[1] = pInd->hdr.event;
// 1493   msg[2] = pInd->hdr.status;
// 1494   msg[3] = pInd->waitTime;
// 1495   msg[4] = LO_UINT16(pInd->keyEstablishmentSuite);
// 1496   msg[5] = HI_UINT16(pInd->keyEstablishmentSuite);
// 1497 
// 1498   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_UTIL),
// 1499                                        MT_UTIL_ZCL_KEY_ESTABLISH_IND, 6, msg);
// 1500 }
// 1501 #endif
// 1502 
// 1503 /***************************************************************************************************
// 1504  * @fn      MT_UtilSync
// 1505  *
// 1506  * @brief   Process the MT_UTIL_SYNC command
// 1507  *
// 1508  * @param   None
// 1509  *
// 1510  * @return  None
// 1511  ***************************************************************************************************/
// 1512 static void MT_UtilSync(void)
// 1513 {
// 1514  MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ|(uint8)MT_RPC_SYS_UTIL),MT_UTIL_SYNC_REQ,0,0);
// 1515 }
// 1516 #endif /* !defined NONWK */
// 1517 #endif /* MT_UTIL_FUNC */
// 1518 /**************************************************************************************************
// 1519  **************************************************************************************************/
// 
// 1 byte in segment XDATA_Z
// 
// 1 byte of XDATA memory
//
//Errors: none
//Warnings: none
